import Pn, { useRef as vf, useEffect as xf, useState as Af } from "react";
var co = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function bi(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Vs = { exports: {} }, xr = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var lo;
function Df() {
  if (lo) return xr;
  lo = 1;
  var e = Pn, t = Symbol.for("react.element"), a = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, n = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function i(o, c, u) {
    var d, m = {}, h = null, y = null;
    u !== void 0 && (h = "" + u), c.key !== void 0 && (h = "" + c.key), c.ref !== void 0 && (y = c.ref);
    for (d in c) r.call(c, d) && !s.hasOwnProperty(d) && (m[d] = c[d]);
    if (o && o.defaultProps) for (d in c = o.defaultProps, c) m[d] === void 0 && (m[d] = c[d]);
    return { $$typeof: t, type: o, key: h, ref: y, props: m, _owner: n.current };
  }
  return xr.Fragment = a, xr.jsx = i, xr.jsxs = i, xr;
}
var Ar = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var uo;
function Cf() {
  return uo || (uo = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Pn, t = Symbol.for("react.element"), a = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), i = Symbol.for("react.provider"), o = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), d = Symbol.for("react.suspense_list"), m = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), y = Symbol.for("react.offscreen"), w = Symbol.iterator, v = "@@iterator";
    function F(_) {
      if (_ === null || typeof _ != "object")
        return null;
      var R = w && _[w] || _[v];
      return typeof R == "function" ? R : null;
    }
    var z = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function C(_) {
      {
        for (var R = arguments.length, H = new Array(R > 1 ? R - 1 : 0), X = 1; X < R; X++)
          H[X - 1] = arguments[X];
        U("error", _, H);
      }
    }
    function U(_, R, H) {
      {
        var X = z.ReactDebugCurrentFrame, ce = X.getStackAddendum();
        ce !== "" && (R += "%s", H = H.concat([ce]));
        var he = H.map(function(oe) {
          return String(oe);
        });
        he.unshift("Warning: " + R), Function.prototype.apply.call(console[_], console, he);
      }
    }
    var $ = !1, O = !1, p = !1, M = !1, te = !1, Z;
    Z = Symbol.for("react.module.reference");
    function P(_) {
      return !!(typeof _ == "string" || typeof _ == "function" || _ === r || _ === s || te || _ === n || _ === u || _ === d || M || _ === y || $ || O || p || typeof _ == "object" && _ !== null && (_.$$typeof === h || _.$$typeof === m || _.$$typeof === i || _.$$typeof === o || _.$$typeof === c || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      _.$$typeof === Z || _.getModuleId !== void 0));
    }
    function re(_, R, H) {
      var X = _.displayName;
      if (X)
        return X;
      var ce = R.displayName || R.name || "";
      return ce !== "" ? H + "(" + ce + ")" : H;
    }
    function ae(_) {
      return _.displayName || "Context";
    }
    function ue(_) {
      if (_ == null)
        return null;
      if (typeof _.tag == "number" && C("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof _ == "function")
        return _.displayName || _.name || null;
      if (typeof _ == "string")
        return _;
      switch (_) {
        case r:
          return "Fragment";
        case a:
          return "Portal";
        case s:
          return "Profiler";
        case n:
          return "StrictMode";
        case u:
          return "Suspense";
        case d:
          return "SuspenseList";
      }
      if (typeof _ == "object")
        switch (_.$$typeof) {
          case o:
            var R = _;
            return ae(R) + ".Consumer";
          case i:
            var H = _;
            return ae(H._context) + ".Provider";
          case c:
            return re(_, _.render, "ForwardRef");
          case m:
            var X = _.displayName || null;
            return X !== null ? X : ue(_.type) || "Memo";
          case h: {
            var ce = _, he = ce._payload, oe = ce._init;
            try {
              return ue(oe(he));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var de = Object.assign, fe = 0, Se, Ne, je, et, S, Me, Re;
    function N() {
    }
    N.__reactDisabledLog = !0;
    function tt() {
      {
        if (fe === 0) {
          Se = console.log, Ne = console.info, je = console.warn, et = console.error, S = console.group, Me = console.groupCollapsed, Re = console.groupEnd;
          var _ = {
            configurable: !0,
            enumerable: !0,
            value: N,
            writable: !0
          };
          Object.defineProperties(console, {
            info: _,
            log: _,
            warn: _,
            error: _,
            group: _,
            groupCollapsed: _,
            groupEnd: _
          });
        }
        fe++;
      }
    }
    function st() {
      {
        if (fe--, fe === 0) {
          var _ = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: de({}, _, {
              value: Se
            }),
            info: de({}, _, {
              value: Ne
            }),
            warn: de({}, _, {
              value: je
            }),
            error: de({}, _, {
              value: et
            }),
            group: de({}, _, {
              value: S
            }),
            groupCollapsed: de({}, _, {
              value: Me
            }),
            groupEnd: de({}, _, {
              value: Re
            })
          });
        }
        fe < 0 && C("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Fe = z.ReactCurrentDispatcher, Ke;
    function He(_, R, H) {
      {
        if (Ke === void 0)
          try {
            throw Error();
          } catch (ce) {
            var X = ce.stack.trim().match(/\n( *(at )?)/);
            Ke = X && X[1] || "";
          }
        return `
` + Ke + _;
      }
    }
    var at = !1, $e;
    {
      var $t = typeof WeakMap == "function" ? WeakMap : Map;
      $e = new $t();
    }
    function ia(_, R) {
      if (!_ || at)
        return "";
      {
        var H = $e.get(_);
        if (H !== void 0)
          return H;
      }
      var X;
      at = !0;
      var ce = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var he;
      he = Fe.current, Fe.current = null, tt();
      try {
        if (R) {
          var oe = function() {
            throw Error();
          };
          if (Object.defineProperty(oe.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(oe, []);
            } catch (Ie) {
              X = Ie;
            }
            Reflect.construct(_, [], oe);
          } else {
            try {
              oe.call();
            } catch (Ie) {
              X = Ie;
            }
            _.call(oe.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ie) {
            X = Ie;
          }
          _();
        }
      } catch (Ie) {
        if (Ie && X && typeof Ie.stack == "string") {
          for (var se = Ie.stack.split(`
`), ze = X.stack.split(`
`), be = se.length - 1, Ee = ze.length - 1; be >= 1 && Ee >= 0 && se[be] !== ze[Ee]; )
            Ee--;
          for (; be >= 1 && Ee >= 0; be--, Ee--)
            if (se[be] !== ze[Ee]) {
              if (be !== 1 || Ee !== 1)
                do
                  if (be--, Ee--, Ee < 0 || se[be] !== ze[Ee]) {
                    var Ue = `
` + se[be].replace(" at new ", " at ");
                    return _.displayName && Ue.includes("<anonymous>") && (Ue = Ue.replace("<anonymous>", _.displayName)), typeof _ == "function" && $e.set(_, Ue), Ue;
                  }
                while (be >= 1 && Ee >= 0);
              break;
            }
        }
      } finally {
        at = !1, Fe.current = he, st(), Error.prepareStackTrace = ce;
      }
      var Dt = _ ? _.displayName || _.name : "", pt = Dt ? He(Dt) : "";
      return typeof _ == "function" && $e.set(_, pt), pt;
    }
    function Fa(_, R, H) {
      return ia(_, !1);
    }
    function oa(_) {
      var R = _.prototype;
      return !!(R && R.isReactComponent);
    }
    function mt(_, R, H) {
      if (_ == null)
        return "";
      if (typeof _ == "function")
        return ia(_, oa(_));
      if (typeof _ == "string")
        return He(_);
      switch (_) {
        case u:
          return He("Suspense");
        case d:
          return He("SuspenseList");
      }
      if (typeof _ == "object")
        switch (_.$$typeof) {
          case c:
            return Fa(_.render);
          case m:
            return mt(_.type, R, H);
          case h: {
            var X = _, ce = X._payload, he = X._init;
            try {
              return mt(he(ce), R, H);
            } catch {
            }
          }
        }
      return "";
    }
    var ct = Object.prototype.hasOwnProperty, Rt = {}, Ft = z.ReactDebugCurrentFrame;
    function lt(_) {
      if (_) {
        var R = _._owner, H = mt(_.type, _._source, R ? R.type : null);
        Ft.setExtraStackFrame(H);
      } else
        Ft.setExtraStackFrame(null);
    }
    function Qa(_, R, H, X, ce) {
      {
        var he = Function.call.bind(ct);
        for (var oe in _)
          if (he(_, oe)) {
            var se = void 0;
            try {
              if (typeof _[oe] != "function") {
                var ze = Error((X || "React class") + ": " + H + " type `" + oe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof _[oe] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw ze.name = "Invariant Violation", ze;
              }
              se = _[oe](R, oe, X, H, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (be) {
              se = be;
            }
            se && !(se instanceof Error) && (lt(ce), C("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", X || "React class", H, oe, typeof se), lt(null)), se instanceof Error && !(se.message in Rt) && (Rt[se.message] = !0, lt(ce), C("Failed %s type: %s", H, se.message), lt(null));
          }
      }
    }
    var pr = Array.isArray;
    function ca(_) {
      return pr(_);
    }
    function gr(_) {
      {
        var R = typeof Symbol == "function" && Symbol.toStringTag, H = R && _[Symbol.toStringTag] || _.constructor.name || "Object";
        return H;
      }
    }
    function yr(_) {
      try {
        return Oa(_), !1;
      } catch {
        return !0;
      }
    }
    function Oa(_) {
      return "" + _;
    }
    function q(_) {
      if (yr(_))
        return C("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", gr(_)), Oa(_);
    }
    var K = z.ReactCurrentOwner, _e = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, we, De, rt;
    rt = {};
    function qt(_) {
      if (ct.call(_, "ref")) {
        var R = Object.getOwnPropertyDescriptor(_, "ref").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return _.ref !== void 0;
    }
    function vt(_) {
      if (ct.call(_, "key")) {
        var R = Object.getOwnPropertyDescriptor(_, "key").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return _.key !== void 0;
    }
    function la(_, R) {
      if (typeof _.ref == "string" && K.current && R && K.current.stateNode !== R) {
        var H = ue(K.current.type);
        rt[H] || (C('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', ue(K.current.type), _.ref), rt[H] = !0);
      }
    }
    function ua(_, R) {
      {
        var H = function() {
          we || (we = !0, C("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        H.isReactWarning = !0, Object.defineProperty(_, "key", {
          get: H,
          configurable: !0
        });
      }
    }
    function ut(_, R) {
      {
        var H = function() {
          De || (De = !0, C("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        H.isReactWarning = !0, Object.defineProperty(_, "ref", {
          get: H,
          configurable: !0
        });
      }
    }
    var Xt = function(_, R, H, X, ce, he, oe) {
      var se = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: _,
        key: R,
        ref: H,
        props: oe,
        // Record the component responsible for creating this element.
        _owner: he
      };
      return se._store = {}, Object.defineProperty(se._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(se, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: X
      }), Object.defineProperty(se, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ce
      }), Object.freeze && (Object.freeze(se.props), Object.freeze(se)), se;
    };
    function xt(_, R, H, X, ce) {
      {
        var he, oe = {}, se = null, ze = null;
        H !== void 0 && (q(H), se = "" + H), vt(R) && (q(R.key), se = "" + R.key), qt(R) && (ze = R.ref, la(R, ce));
        for (he in R)
          ct.call(R, he) && !_e.hasOwnProperty(he) && (oe[he] = R[he]);
        if (_ && _.defaultProps) {
          var be = _.defaultProps;
          for (he in be)
            oe[he] === void 0 && (oe[he] = be[he]);
        }
        if (se || ze) {
          var Ee = typeof _ == "function" ? _.displayName || _.name || "Unknown" : _;
          se && ua(oe, Ee), ze && ut(oe, Ee);
        }
        return Xt(_, se, ze, ce, X, K.current, oe);
      }
    }
    var La = z.ReactCurrentOwner, _r = z.ReactDebugCurrentFrame;
    function At(_) {
      if (_) {
        var R = _._owner, H = mt(_.type, _._source, R ? R.type : null);
        _r.setExtraStackFrame(H);
      } else
        _r.setExtraStackFrame(null);
    }
    var Ma;
    Ma = !1;
    function Ba(_) {
      return typeof _ == "object" && _ !== null && _.$$typeof === t;
    }
    function br() {
      {
        if (La.current) {
          var _ = ue(La.current.type);
          if (_)
            return `

Check the render method of \`` + _ + "`.";
        }
        return "";
      }
    }
    function rs(_) {
      return "";
    }
    var kr = {};
    function ns(_) {
      {
        var R = br();
        if (!R) {
          var H = typeof _ == "string" ? _ : _.displayName || _.name;
          H && (R = `

Check the top-level render call using <` + H + ">.");
        }
        return R;
      }
    }
    function wr(_, R) {
      {
        if (!_._store || _._store.validated || _.key != null)
          return;
        _._store.validated = !0;
        var H = ns(R);
        if (kr[H])
          return;
        kr[H] = !0;
        var X = "";
        _ && _._owner && _._owner !== La.current && (X = " It was passed a child from " + ue(_._owner.type) + "."), At(_), C('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', H, X), At(null);
      }
    }
    function Er(_, R) {
      {
        if (typeof _ != "object")
          return;
        if (ca(_))
          for (var H = 0; H < _.length; H++) {
            var X = _[H];
            Ba(X) && wr(X, R);
          }
        else if (Ba(_))
          _._store && (_._store.validated = !0);
        else if (_) {
          var ce = F(_);
          if (typeof ce == "function" && ce !== _.entries)
            for (var he = ce.call(_), oe; !(oe = he.next()).done; )
              Ba(oe.value) && wr(oe.value, R);
        }
      }
    }
    function ss(_) {
      {
        var R = _.type;
        if (R == null || typeof R == "string")
          return;
        var H;
        if (typeof R == "function")
          H = R.propTypes;
        else if (typeof R == "object" && (R.$$typeof === c || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        R.$$typeof === m))
          H = R.propTypes;
        else
          return;
        if (H) {
          var X = ue(R);
          Qa(H, _.props, "prop", X, _);
        } else if (R.PropTypes !== void 0 && !Ma) {
          Ma = !0;
          var ce = ue(R);
          C("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ce || "Unknown");
        }
        typeof R.getDefaultProps == "function" && !R.getDefaultProps.isReactClassApproved && C("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function is(_) {
      {
        for (var R = Object.keys(_.props), H = 0; H < R.length; H++) {
          var X = R[H];
          if (X !== "children" && X !== "key") {
            At(_), C("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", X), At(null);
            break;
          }
        }
        _.ref !== null && (At(_), C("Invalid attribute `ref` supplied to `React.Fragment`."), At(null));
      }
    }
    var Tr = {};
    function vr(_, R, H, X, ce, he) {
      {
        var oe = P(_);
        if (!oe) {
          var se = "";
          (_ === void 0 || typeof _ == "object" && _ !== null && Object.keys(_).length === 0) && (se += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var ze = rs();
          ze ? se += ze : se += br();
          var be;
          _ === null ? be = "null" : ca(_) ? be = "array" : _ !== void 0 && _.$$typeof === t ? (be = "<" + (ue(_.type) || "Unknown") + " />", se = " Did you accidentally export a JSX literal instead of a component?") : be = typeof _, C("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", be, se);
        }
        var Ee = xt(_, R, H, ce, he);
        if (Ee == null)
          return Ee;
        if (oe) {
          var Ue = R.children;
          if (Ue !== void 0)
            if (X)
              if (ca(Ue)) {
                for (var Dt = 0; Dt < Ue.length; Dt++)
                  Er(Ue[Dt], _);
                Object.freeze && Object.freeze(Ue);
              } else
                C("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Er(Ue, _);
        }
        if (ct.call(R, "key")) {
          var pt = ue(_), Ie = Object.keys(R).filter(function(hs) {
            return hs !== "key";
          }), Pa = Ie.length > 0 ? "{key: someKey, " + Ie.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Tr[pt + Pa]) {
            var fs = Ie.length > 0 ? "{" + Ie.join(": ..., ") + ": ...}" : "{}";
            C(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Pa, pt, fs, pt), Tr[pt + Pa] = !0;
          }
        }
        return _ === r ? is(Ee) : ss(Ee), Ee;
      }
    }
    function os(_, R, H) {
      return vr(_, R, H, !0);
    }
    function cs(_, R, H) {
      return vr(_, R, H, !1);
    }
    var ls = cs, us = os;
    Ar.Fragment = r, Ar.jsx = ls, Ar.jsxs = us;
  }()), Ar;
}
process.env.NODE_ENV === "production" ? Vs.exports = Df() : Vs.exports = Cf();
var St = Vs.exports;
function fo(e) {
  const t = [], a = String(e || "");
  let r = a.indexOf(","), n = 0, s = !1;
  for (; !s; ) {
    r === -1 && (r = a.length, s = !0);
    const i = a.slice(n, r).trim();
    (i || !s) && t.push(i), n = r + 1, r = a.indexOf(",", n);
  }
  return t;
}
function _l(e, t) {
  const a = {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join(
    (a.padRight ? " " : "") + "," + (a.padLeft === !1 ? "" : " ")
  ).trim();
}
const Sf = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, zf = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, Nf = {};
function ho(e, t) {
  return (Nf.jsx ? zf : Sf).test(e);
}
const If = /[ \t\n\f\r]/g;
function Rf(e) {
  return typeof e == "object" ? e.type === "text" ? mo(e.value) : !1 : mo(e);
}
function mo(e) {
  return e.replace(If, "") === "";
}
class Qr {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(t, a, r) {
    this.property = t, this.normal = a, r && (this.space = r);
  }
}
Qr.prototype.property = {};
Qr.prototype.normal = {};
Qr.prototype.space = null;
function bl(e, t) {
  const a = {}, r = {};
  let n = -1;
  for (; ++n < e.length; )
    Object.assign(a, e[n].property), Object.assign(r, e[n].normal);
  return new Qr(a, r, t);
}
function Vr(e) {
  return e.toLowerCase();
}
class jt {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(t, a) {
    this.property = t, this.attribute = a;
  }
}
jt.prototype.space = null;
jt.prototype.boolean = !1;
jt.prototype.booleanish = !1;
jt.prototype.overloadedBoolean = !1;
jt.prototype.number = !1;
jt.prototype.commaSeparated = !1;
jt.prototype.spaceSeparated = !1;
jt.prototype.commaOrSpaceSeparated = !1;
jt.prototype.mustUseProperty = !1;
jt.prototype.defined = !1;
let Ff = 0;
const ke = Ga(), Je = Ga(), kl = Ga(), J = Ga(), Be = Ga(), ar = Ga(), Ct = Ga();
function Ga() {
  return 2 ** ++Ff;
}
const Gs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: ke,
  booleanish: Je,
  commaOrSpaceSeparated: Ct,
  commaSeparated: ar,
  number: J,
  overloadedBoolean: kl,
  spaceSeparated: Be
}, Symbol.toStringTag, { value: "Module" })), ds = Object.keys(Gs);
class ki extends jt {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(t, a, r, n) {
    let s = -1;
    if (super(t, a), po(this, "space", n), typeof r == "number")
      for (; ++s < ds.length; ) {
        const i = ds[s];
        po(this, ds[s], (r & Gs[i]) === Gs[i]);
      }
  }
}
ki.prototype.defined = !0;
function po(e, t, a) {
  a && (e[t] = a);
}
const Of = {}.hasOwnProperty;
function ir(e) {
  const t = {}, a = {};
  let r;
  for (r in e.properties)
    if (Of.call(e.properties, r)) {
      const n = e.properties[r], s = new ki(
        r,
        e.transform(e.attributes || {}, r),
        n,
        e.space
      );
      e.mustUseProperty && e.mustUseProperty.includes(r) && (s.mustUseProperty = !0), t[r] = s, a[Vr(r)] = r, a[Vr(s.attribute)] = r;
    }
  return new Qr(t, a, e.space);
}
const wl = ir({
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
}), El = ir({
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function Tl(e, t) {
  return t in e ? e[t] : t;
}
function vl(e, t) {
  return Tl(e, t.toLowerCase());
}
const xl = ir({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: vl,
  properties: { xmlns: null, xmlnsXLink: null }
}), Al = ir({
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: Je,
    ariaAutoComplete: null,
    ariaBusy: Je,
    ariaChecked: Je,
    ariaColCount: J,
    ariaColIndex: J,
    ariaColSpan: J,
    ariaControls: Be,
    ariaCurrent: null,
    ariaDescribedBy: Be,
    ariaDetails: null,
    ariaDisabled: Je,
    ariaDropEffect: Be,
    ariaErrorMessage: null,
    ariaExpanded: Je,
    ariaFlowTo: Be,
    ariaGrabbed: Je,
    ariaHasPopup: null,
    ariaHidden: Je,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: Be,
    ariaLevel: J,
    ariaLive: null,
    ariaModal: Je,
    ariaMultiLine: Je,
    ariaMultiSelectable: Je,
    ariaOrientation: null,
    ariaOwns: Be,
    ariaPlaceholder: null,
    ariaPosInSet: J,
    ariaPressed: Je,
    ariaReadOnly: Je,
    ariaRelevant: null,
    ariaRequired: Je,
    ariaRoleDescription: Be,
    ariaRowCount: J,
    ariaRowIndex: J,
    ariaRowSpan: J,
    ariaSelected: Je,
    ariaSetSize: J,
    ariaSort: null,
    ariaValueMax: J,
    ariaValueMin: J,
    ariaValueNow: J,
    ariaValueText: null,
    role: null
  }
}), Lf = ir({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: vl,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: ar,
    acceptCharset: Be,
    accessKey: Be,
    action: null,
    allow: null,
    allowFullScreen: ke,
    allowPaymentRequest: ke,
    allowUserMedia: ke,
    alt: null,
    as: null,
    async: ke,
    autoCapitalize: null,
    autoComplete: Be,
    autoFocus: ke,
    autoPlay: ke,
    blocking: Be,
    capture: null,
    charSet: null,
    checked: ke,
    cite: null,
    className: Be,
    cols: J,
    colSpan: null,
    content: null,
    contentEditable: Je,
    controls: ke,
    controlsList: Be,
    coords: J | ar,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: ke,
    defer: ke,
    dir: null,
    dirName: null,
    disabled: ke,
    download: kl,
    draggable: Je,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: ke,
    formTarget: null,
    headers: Be,
    height: J,
    hidden: ke,
    high: J,
    href: null,
    hrefLang: null,
    htmlFor: Be,
    httpEquiv: Be,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: ke,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: ke,
    itemId: null,
    itemProp: Be,
    itemRef: Be,
    itemScope: ke,
    itemType: Be,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: ke,
    low: J,
    manifest: null,
    max: null,
    maxLength: J,
    media: null,
    method: null,
    min: null,
    minLength: J,
    multiple: ke,
    muted: ke,
    name: null,
    nonce: null,
    noModule: ke,
    noValidate: ke,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: ke,
    optimum: J,
    pattern: null,
    ping: Be,
    placeholder: null,
    playsInline: ke,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: ke,
    referrerPolicy: null,
    rel: Be,
    required: ke,
    reversed: ke,
    rows: J,
    rowSpan: J,
    sandbox: Be,
    scope: null,
    scoped: ke,
    seamless: ke,
    selected: ke,
    shadowRootClonable: ke,
    shadowRootDelegatesFocus: ke,
    shadowRootMode: null,
    shape: null,
    size: J,
    sizes: null,
    slot: null,
    span: J,
    spellCheck: Je,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: J,
    step: null,
    style: null,
    tabIndex: J,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: ke,
    useMap: null,
    value: Je,
    width: J,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: Be,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: J,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: J,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: ke,
    // Lists. Use CSS to reduce space between items instead
    declare: ke,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: J,
    // `<img>` and `<object>`
    leftMargin: J,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: J,
    // `<body>`
    marginWidth: J,
    // `<body>`
    noResize: ke,
    // `<frame>`
    noHref: ke,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: ke,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: ke,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: J,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: Je,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: J,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: J,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: ke,
    disableRemotePlayback: ke,
    prefix: null,
    property: null,
    results: J,
    security: null,
    unselectable: null
  }
}), Mf = ir({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: Tl,
  properties: {
    about: Ct,
    accentHeight: J,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: J,
    amplitude: J,
    arabicForm: null,
    ascent: J,
    attributeName: null,
    attributeType: null,
    azimuth: J,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: J,
    by: null,
    calcMode: null,
    capHeight: J,
    className: Be,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: J,
    diffuseConstant: J,
    direction: null,
    display: null,
    dur: null,
    divisor: J,
    dominantBaseline: null,
    download: ke,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: J,
    enableBackground: null,
    end: null,
    event: null,
    exponent: J,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: J,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: ar,
    g2: ar,
    glyphName: ar,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: J,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: J,
    horizOriginX: J,
    horizOriginY: J,
    id: null,
    ideographic: J,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: J,
    k: J,
    k1: J,
    k2: J,
    k3: J,
    k4: J,
    kernelMatrix: Ct,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: J,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: J,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: J,
    overlineThickness: J,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: J,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: Be,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: J,
    pointsAtY: J,
    pointsAtZ: J,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: Ct,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: Ct,
    rev: Ct,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: Ct,
    requiredFeatures: Ct,
    requiredFonts: Ct,
    requiredFormats: Ct,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: J,
    specularExponent: J,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: J,
    strikethroughThickness: J,
    string: null,
    stroke: null,
    strokeDashArray: Ct,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: J,
    strokeOpacity: J,
    strokeWidth: null,
    style: null,
    surfaceScale: J,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: Ct,
    tabIndex: J,
    tableValues: null,
    target: null,
    targetX: J,
    targetY: J,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: Ct,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: J,
    underlineThickness: J,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: J,
    values: null,
    vAlphabetic: J,
    vMathematical: J,
    vectorEffect: null,
    vHanging: J,
    vIdeographic: J,
    version: null,
    vertAdvY: J,
    vertOriginX: J,
    vertOriginY: J,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: J,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
}), Bf = /^data[-\w.:]+$/i, go = /-[a-z]/g, Pf = /[A-Z]/g;
function Hn(e, t) {
  const a = Vr(t);
  let r = t, n = jt;
  if (a in e.normal)
    return e.property[e.normal[a]];
  if (a.length > 4 && a.slice(0, 4) === "data" && Bf.test(t)) {
    if (t.charAt(4) === "-") {
      const s = t.slice(5).replace(go, Uf);
      r = "data" + s.charAt(0).toUpperCase() + s.slice(1);
    } else {
      const s = t.slice(4);
      if (!go.test(s)) {
        let i = s.replace(Pf, Hf);
        i.charAt(0) !== "-" && (i = "-" + i), t = "data" + i;
      }
    }
    n = ki;
  }
  return new n(r, t);
}
function Hf(e) {
  return "-" + e.toLowerCase();
}
function Uf(e) {
  return e.charAt(1).toUpperCase();
}
const jf = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, Kr = bl([El, wl, xl, Al, Lf], "html"), Na = bl([El, wl, xl, Al, Mf], "svg");
function yo(e) {
  const t = String(e || "").trim();
  return t ? t.split(/[ \t\n\r\f]+/g) : [];
}
function Dl(e) {
  return e.join(" ").trim();
}
var Cl = {}, _o = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, qf = /\n/g, Yf = /^\s*/, Vf = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, Gf = /^:\s*/, Wf = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, $f = /^[;\s]*/, Xf = /^\s+|\s+$/g, Qf = `
`, bo = "/", ko = "*", qa = "", Kf = "comment", Jf = "declaration", Zf = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var a = 1, r = 1;
  function n(w) {
    var v = w.match(qf);
    v && (a += v.length);
    var F = w.lastIndexOf(Qf);
    r = ~F ? w.length - F : r + w.length;
  }
  function s() {
    var w = { line: a, column: r };
    return function(v) {
      return v.position = new i(w), u(), v;
    };
  }
  function i(w) {
    this.start = w, this.end = { line: a, column: r }, this.source = t.source;
  }
  i.prototype.content = e;
  function o(w) {
    var v = new Error(
      t.source + ":" + a + ":" + r + ": " + w
    );
    if (v.reason = w, v.filename = t.source, v.line = a, v.column = r, v.source = e, !t.silent) throw v;
  }
  function c(w) {
    var v = w.exec(e);
    if (v) {
      var F = v[0];
      return n(F), e = e.slice(F.length), v;
    }
  }
  function u() {
    c(Yf);
  }
  function d(w) {
    var v;
    for (w = w || []; v = m(); )
      v !== !1 && w.push(v);
    return w;
  }
  function m() {
    var w = s();
    if (!(bo != e.charAt(0) || ko != e.charAt(1))) {
      for (var v = 2; qa != e.charAt(v) && (ko != e.charAt(v) || bo != e.charAt(v + 1)); )
        ++v;
      if (v += 2, qa === e.charAt(v - 1))
        return o("End of comment missing");
      var F = e.slice(2, v - 2);
      return r += 2, n(F), e = e.slice(v), r += 2, w({
        type: Kf,
        comment: F
      });
    }
  }
  function h() {
    var w = s(), v = c(Vf);
    if (v) {
      if (m(), !c(Gf)) return o("property missing ':'");
      var F = c(Wf), z = w({
        type: Jf,
        property: wo(v[0].replace(_o, qa)),
        value: F ? wo(F[0].replace(_o, qa)) : qa
      });
      return c($f), z;
    }
  }
  function y() {
    var w = [];
    d(w);
    for (var v; v = h(); )
      v !== !1 && (w.push(v), d(w));
    return w;
  }
  return u(), y();
};
function wo(e) {
  return e ? e.replace(Xf, qa) : qa;
}
var eh = co && co.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Cl, "__esModule", { value: !0 });
var Eo = Cl.default = ah, th = eh(Zf);
function ah(e, t) {
  var a = null;
  if (!e || typeof e != "string")
    return a;
  var r = (0, th.default)(e), n = typeof t == "function";
  return r.forEach(function(s) {
    if (s.type === "declaration") {
      var i = s.property, o = s.value;
      n ? t(i, o, s) : o && (a = a || {}, a[i] = o);
    }
  }), a;
}
const rh = Eo.default || Eo, Un = Sl("end"), ta = Sl("start");
function Sl(e) {
  return t;
  function t(a) {
    const r = a && a.position && a.position[e] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function nh(e) {
  const t = ta(e), a = Un(e);
  if (t && a)
    return { start: t, end: a };
}
function Or(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? To(e.position) : "start" in e || "end" in e ? To(e) : "line" in e || "column" in e ? Ws(e) : "";
}
function Ws(e) {
  return vo(e && e.line) + ":" + vo(e && e.column);
}
function To(e) {
  return Ws(e && e.start) + "-" + Ws(e && e.end);
}
function vo(e) {
  return e && typeof e == "number" ? e : 1;
}
class ht extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(t, a, r) {
    super(), typeof a == "string" && (r = a, a = void 0);
    let n = "", s = {}, i = !1;
    if (a && ("line" in a && "column" in a ? s = { place: a } : "start" in a && "end" in a ? s = { place: a } : "type" in a ? s = {
      ancestors: [a],
      place: a.position
    } : s = { ...a }), typeof t == "string" ? n = t : !s.cause && t && (i = !0, n = t.message, s.cause = t), !s.ruleId && !s.source && typeof r == "string") {
      const c = r.indexOf(":");
      c === -1 ? s.ruleId = r : (s.source = r.slice(0, c), s.ruleId = r.slice(c + 1));
    }
    if (!s.place && s.ancestors && s.ancestors) {
      const c = s.ancestors[s.ancestors.length - 1];
      c && (s.place = c.position);
    }
    const o = s.place && "start" in s.place ? s.place.start : s.place;
    this.ancestors = s.ancestors || void 0, this.cause = s.cause || void 0, this.column = o ? o.column : void 0, this.fatal = void 0, this.file, this.message = n, this.line = o ? o.line : void 0, this.name = Or(s.place) || "1:1", this.place = s.place || void 0, this.reason = this.message, this.ruleId = s.ruleId || void 0, this.source = s.source || void 0, this.stack = i && s.cause && typeof s.cause.stack == "string" ? s.cause.stack : "", this.actual, this.expected, this.note, this.url;
  }
}
ht.prototype.file = "";
ht.prototype.name = "";
ht.prototype.reason = "";
ht.prototype.message = "";
ht.prototype.stack = "";
ht.prototype.column = void 0;
ht.prototype.line = void 0;
ht.prototype.ancestors = void 0;
ht.prototype.cause = void 0;
ht.prototype.fatal = void 0;
ht.prototype.place = void 0;
ht.prototype.ruleId = void 0;
ht.prototype.source = void 0;
const wi = {}.hasOwnProperty, sh = /* @__PURE__ */ new Map(), ih = /[A-Z]/g, oh = /-([a-z])/g, ch = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), lh = /* @__PURE__ */ new Set(["td", "th"]), zl = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function uh(e, t) {
  if (!t || t.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const a = t.filePath || void 0;
  let r;
  if (t.development) {
    if (typeof t.jsxDEV != "function")
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    r = _h(a, t.jsxDEV);
  } else {
    if (typeof t.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof t.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    r = yh(a, t.jsx, t.jsxs);
  }
  const n = {
    Fragment: t.Fragment,
    ancestors: [],
    components: t.components || {},
    create: r,
    elementAttributeNameCase: t.elementAttributeNameCase || "react",
    evaluater: t.createEvaluater ? t.createEvaluater() : void 0,
    filePath: a,
    ignoreInvalidStyle: t.ignoreInvalidStyle || !1,
    passKeys: t.passKeys !== !1,
    passNode: t.passNode || !1,
    schema: t.space === "svg" ? Na : Kr,
    stylePropertyNameCase: t.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: t.tableCellAlignToStyle !== !1
  }, s = Nl(n, e, void 0);
  return s && typeof s != "string" ? s : n.create(
    e,
    n.Fragment,
    { children: s || void 0 },
    void 0
  );
}
function Nl(e, t, a) {
  if (t.type === "element")
    return fh(e, t, a);
  if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression")
    return hh(e, t);
  if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement")
    return mh(e, t, a);
  if (t.type === "mdxjsEsm")
    return dh(e, t);
  if (t.type === "root")
    return ph(e, t, a);
  if (t.type === "text")
    return gh(e, t);
}
function fh(e, t, a) {
  const r = e.schema;
  let n = r;
  t.tagName.toLowerCase() === "svg" && r.space === "html" && (n = Na, e.schema = n), e.ancestors.push(t);
  const s = Rl(e, t.tagName, !1), i = bh(e, t);
  let o = Ti(e, t);
  return ch.has(t.tagName) && (o = o.filter(function(c) {
    return typeof c == "string" ? !Rf(c) : !0;
  })), Il(e, i, s, t), Ei(i, o), e.ancestors.pop(), e.schema = r, e.create(t, s, i, a);
}
function hh(e, t) {
  if (t.data && t.data.estree && e.evaluater) {
    const r = t.data.estree.body[0];
    return r.type, /** @type {Child | undefined} */
    e.evaluater.evaluateExpression(r.expression);
  }
  Gr(e, t.position);
}
function dh(e, t) {
  if (t.data && t.data.estree && e.evaluater)
    return (
      /** @type {Child | undefined} */
      e.evaluater.evaluateProgram(t.data.estree)
    );
  Gr(e, t.position);
}
function mh(e, t, a) {
  const r = e.schema;
  let n = r;
  t.name === "svg" && r.space === "html" && (n = Na, e.schema = n), e.ancestors.push(t);
  const s = t.name === null ? e.Fragment : Rl(e, t.name, !0), i = kh(e, t), o = Ti(e, t);
  return Il(e, i, s, t), Ei(i, o), e.ancestors.pop(), e.schema = r, e.create(t, s, i, a);
}
function ph(e, t, a) {
  const r = {};
  return Ei(r, Ti(e, t)), e.create(t, e.Fragment, r, a);
}
function gh(e, t) {
  return t.value;
}
function Il(e, t, a, r) {
  typeof a != "string" && a !== e.Fragment && e.passNode && (t.node = r);
}
function Ei(e, t) {
  if (t.length > 0) {
    const a = t.length > 1 ? t : t[0];
    a && (e.children = a);
  }
}
function yh(e, t, a) {
  return r;
  function r(n, s, i, o) {
    const u = Array.isArray(i.children) ? a : t;
    return o ? u(s, i, o) : u(s, i);
  }
}
function _h(e, t) {
  return a;
  function a(r, n, s, i) {
    const o = Array.isArray(s.children), c = ta(r);
    return t(
      n,
      s,
      i,
      o,
      {
        columnNumber: c ? c.column - 1 : void 0,
        fileName: e,
        lineNumber: c ? c.line : void 0
      },
      void 0
    );
  }
}
function bh(e, t) {
  const a = {};
  let r, n;
  for (n in t.properties)
    if (n !== "children" && wi.call(t.properties, n)) {
      const s = wh(e, n, t.properties[n]);
      if (s) {
        const [i, o] = s;
        e.tableCellAlignToStyle && i === "align" && typeof o == "string" && lh.has(t.tagName) ? r = o : a[i] = o;
      }
    }
  if (r) {
    const s = (
      /** @type {Style} */
      a.style || (a.style = {})
    );
    s[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = r;
  }
  return a;
}
function kh(e, t) {
  const a = {};
  for (const r of t.attributes)
    if (r.type === "mdxJsxExpressionAttribute")
      if (r.data && r.data.estree && e.evaluater) {
        const s = r.data.estree.body[0];
        s.type;
        const i = s.expression;
        i.type;
        const o = i.properties[0];
        o.type, Object.assign(
          a,
          e.evaluater.evaluateExpression(o.argument)
        );
      } else
        Gr(e, t.position);
    else {
      const n = r.name;
      let s;
      if (r.value && typeof r.value == "object")
        if (r.value.data && r.value.data.estree && e.evaluater) {
          const o = r.value.data.estree.body[0];
          o.type, s = e.evaluater.evaluateExpression(o.expression);
        } else
          Gr(e, t.position);
      else
        s = r.value === null ? !0 : r.value;
      a[n] = /** @type {Props[keyof Props]} */
      s;
    }
  return a;
}
function Ti(e, t) {
  const a = [];
  let r = -1;
  const n = e.passKeys ? /* @__PURE__ */ new Map() : sh;
  for (; ++r < t.children.length; ) {
    const s = t.children[r];
    let i;
    if (e.passKeys) {
      const c = s.type === "element" ? s.tagName : s.type === "mdxJsxFlowElement" || s.type === "mdxJsxTextElement" ? s.name : void 0;
      if (c) {
        const u = n.get(c) || 0;
        i = c + "-" + u, n.set(c, u + 1);
      }
    }
    const o = Nl(e, s, i);
    o !== void 0 && a.push(o);
  }
  return a;
}
function wh(e, t, a) {
  const r = Hn(e.schema, t);
  if (!(a == null || typeof a == "number" && Number.isNaN(a))) {
    if (Array.isArray(a) && (a = r.commaSeparated ? _l(a) : Dl(a)), r.property === "style") {
      let n = typeof a == "object" ? a : Eh(e, String(a));
      return e.stylePropertyNameCase === "css" && (n = Th(n)), ["style", n];
    }
    return [
      e.elementAttributeNameCase === "react" && r.space ? jf[r.property] || r.property : r.attribute,
      a
    ];
  }
}
function Eh(e, t) {
  const a = {};
  try {
    rh(t, r);
  } catch (n) {
    if (!e.ignoreInvalidStyle) {
      const s = (
        /** @type {Error} */
        n
      ), i = new ht("Cannot parse `style` attribute", {
        ancestors: e.ancestors,
        cause: s,
        ruleId: "style",
        source: "hast-util-to-jsx-runtime"
      });
      throw i.file = e.filePath || void 0, i.url = zl + "#cannot-parse-style-attribute", i;
    }
  }
  return a;
  function r(n, s) {
    let i = n;
    i.slice(0, 2) !== "--" && (i.slice(0, 4) === "-ms-" && (i = "ms-" + i.slice(4)), i = i.replace(oh, xh)), a[i] = s;
  }
}
function Rl(e, t, a) {
  let r;
  if (!a)
    r = { type: "Literal", value: t };
  else if (t.includes(".")) {
    const n = t.split(".");
    let s = -1, i;
    for (; ++s < n.length; ) {
      const o = ho(n[s]) ? { type: "Identifier", name: n[s] } : { type: "Literal", value: n[s] };
      i = i ? {
        type: "MemberExpression",
        object: i,
        property: o,
        computed: !!(s && o.type === "Literal"),
        optional: !1
      } : o;
    }
    r = i;
  } else
    r = ho(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t };
  if (r.type === "Literal") {
    const n = (
      /** @type {keyof JSX.IntrinsicElements} */
      r.value
    );
    return wi.call(e.components, n) ? e.components[n] : n;
  }
  if (e.evaluater)
    return e.evaluater.evaluateExpression(r);
  Gr(e);
}
function Gr(e, t) {
  const a = new ht(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: e.ancestors,
      place: t,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  throw a.file = e.filePath || void 0, a.url = zl + "#cannot-handle-mdx-estrees-without-createevaluater", a;
}
function Th(e) {
  const t = {};
  let a;
  for (a in e)
    wi.call(e, a) && (t[vh(a)] = e[a]);
  return t;
}
function vh(e) {
  let t = e.replace(ih, Ah);
  return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
}
function xh(e, t) {
  return t.toUpperCase();
}
function Ah(e) {
  return "-" + e.toLowerCase();
}
const ms = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
}, Dh = {};
function jn(e, t) {
  const a = t || Dh, r = typeof a.includeImageAlt == "boolean" ? a.includeImageAlt : !0, n = typeof a.includeHtml == "boolean" ? a.includeHtml : !0;
  return Fl(e, r, n);
}
function Fl(e, t, a) {
  if (Ch(e)) {
    if ("value" in e)
      return e.type === "html" && !a ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return xo(e.children, t, a);
  }
  return Array.isArray(e) ? xo(e, t, a) : "";
}
function xo(e, t, a) {
  const r = [];
  let n = -1;
  for (; ++n < e.length; )
    r[n] = Fl(e[n], t, a);
  return r.join("");
}
function Ch(e) {
  return !!(e && typeof e == "object");
}
const Ao = document.createElement("i");
function vi(e) {
  const t = "&" + e + ";";
  Ao.innerHTML = t;
  const a = Ao.textContent;
  return a.charCodeAt(a.length - 1) === 59 && e !== "semi" || a === t ? !1 : a;
}
function Bt(e, t, a, r) {
  const n = e.length;
  let s = 0, i;
  if (t < 0 ? t = -t > n ? 0 : n + t : t = t > n ? n : t, a = a > 0 ? a : 0, r.length < 1e4)
    i = Array.from(r), i.unshift(t, a), e.splice(...i);
  else
    for (a && e.splice(t, a); s < r.length; )
      i = r.slice(s, s + 1e4), i.unshift(t, 0), e.splice(...i), s += 1e4, t += 1e4;
}
function Ot(e, t) {
  return e.length > 0 ? (Bt(e, e.length, 0, t), e) : t;
}
const Do = {}.hasOwnProperty;
function Ol(e) {
  const t = {};
  let a = -1;
  for (; ++a < e.length; )
    Sh(t, e[a]);
  return t;
}
function Sh(e, t) {
  let a;
  for (a in t) {
    const n = (Do.call(e, a) ? e[a] : void 0) || (e[a] = {}), s = t[a];
    let i;
    if (s)
      for (i in s) {
        Do.call(n, i) || (n[i] = []);
        const o = s[i];
        zh(
          // @ts-expect-error Looks like a list.
          n[i],
          Array.isArray(o) ? o : o ? [o] : []
        );
      }
  }
}
function zh(e, t) {
  let a = -1;
  const r = [];
  for (; ++a < t.length; )
    (t[a].add === "after" ? e : r).push(t[a]);
  Bt(e, 0, 0, r);
}
function Ll(e, t) {
  const a = Number.parseInt(e, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    a < 9 || a === 11 || a > 13 && a < 32 || // Control character (DEL) of C0, and C1 controls.
    a > 126 && a < 160 || // Lone high surrogates and low surrogates.
    a > 55295 && a < 57344 || // Noncharacters.
    a > 64975 && a < 65008 || /* eslint-disable no-bitwise */
    (a & 65535) === 65535 || (a & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    a > 1114111 ? "" : String.fromCodePoint(a)
  );
}
function Gt(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const yt = Ia(/[A-Za-z]/), ft = Ia(/[\dA-Za-z]/), Nh = Ia(/[#-'*+\--9=?A-Z^-~]/);
function Cn(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
const $s = Ia(/\d/), Ih = Ia(/[\dA-Fa-f]/), Rh = Ia(/[!-/:-@[-`{-~]/);
function le(e) {
  return e !== null && e < -2;
}
function Oe(e) {
  return e !== null && (e < 0 || e === 32);
}
function Ae(e) {
  return e === -2 || e === -1 || e === 32;
}
const qn = Ia(new RegExp("\\p{P}|\\p{S}", "u")), Va = Ia(/\s/);
function Ia(e) {
  return t;
  function t(a) {
    return a !== null && a > -1 && e.test(String.fromCharCode(a));
  }
}
function or(e) {
  const t = [];
  let a = -1, r = 0, n = 0;
  for (; ++a < e.length; ) {
    const s = e.charCodeAt(a);
    let i = "";
    if (s === 37 && ft(e.charCodeAt(a + 1)) && ft(e.charCodeAt(a + 2)))
      n = 2;
    else if (s < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(s)) || (i = String.fromCharCode(s));
    else if (s > 55295 && s < 57344) {
      const o = e.charCodeAt(a + 1);
      s < 56320 && o > 56319 && o < 57344 ? (i = String.fromCharCode(s, o), n = 1) : i = "";
    } else
      i = String.fromCharCode(s);
    i && (t.push(e.slice(r, a), encodeURIComponent(i)), r = a + n + 1, i = ""), n && (a += n, n = 0);
  }
  return t.join("") + e.slice(r);
}
function xe(e, t, a, r) {
  const n = r ? r - 1 : Number.POSITIVE_INFINITY;
  let s = 0;
  return i;
  function i(c) {
    return Ae(c) ? (e.enter(a), o(c)) : t(c);
  }
  function o(c) {
    return Ae(c) && s++ < n ? (e.consume(c), o) : (e.exit(a), t(c));
  }
}
const Fh = {
  tokenize: Oh
};
function Oh(e) {
  const t = e.attempt(
    this.parser.constructs.contentInitial,
    r,
    n
  );
  let a;
  return t;
  function r(o) {
    if (o === null) {
      e.consume(o);
      return;
    }
    return e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), xe(e, t, "linePrefix");
  }
  function n(o) {
    return e.enter("paragraph"), s(o);
  }
  function s(o) {
    const c = e.enter("chunkText", {
      contentType: "text",
      previous: a
    });
    return a && (a.next = c), a = c, i(o);
  }
  function i(o) {
    if (o === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(o);
      return;
    }
    return le(o) ? (e.consume(o), e.exit("chunkText"), s) : (e.consume(o), i);
  }
}
const Lh = {
  tokenize: Mh
}, Co = {
  tokenize: Bh
};
function Mh(e) {
  const t = this, a = [];
  let r = 0, n, s, i;
  return o;
  function o(U) {
    if (r < a.length) {
      const $ = a[r];
      return t.containerState = $[1], e.attempt(
        $[0].continuation,
        c,
        u
      )(U);
    }
    return u(U);
  }
  function c(U) {
    if (r++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, n && C();
      const $ = t.events.length;
      let O = $, p;
      for (; O--; )
        if (t.events[O][0] === "exit" && t.events[O][1].type === "chunkFlow") {
          p = t.events[O][1].end;
          break;
        }
      z(r);
      let M = $;
      for (; M < t.events.length; )
        t.events[M][1].end = Object.assign({}, p), M++;
      return Bt(
        t.events,
        O + 1,
        0,
        t.events.slice($)
      ), t.events.length = M, u(U);
    }
    return o(U);
  }
  function u(U) {
    if (r === a.length) {
      if (!n)
        return h(U);
      if (n.currentConstruct && n.currentConstruct.concrete)
        return w(U);
      t.interrupt = !!(n.currentConstruct && !n._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(
      Co,
      d,
      m
    )(U);
  }
  function d(U) {
    return n && C(), z(r), h(U);
  }
  function m(U) {
    return t.parser.lazy[t.now().line] = r !== a.length, i = t.now().offset, w(U);
  }
  function h(U) {
    return t.containerState = {}, e.attempt(
      Co,
      y,
      w
    )(U);
  }
  function y(U) {
    return r++, a.push([t.currentConstruct, t.containerState]), h(U);
  }
  function w(U) {
    if (U === null) {
      n && C(), z(0), e.consume(U);
      return;
    }
    return n = n || t.parser.flow(t.now()), e.enter("chunkFlow", {
      contentType: "flow",
      previous: s,
      _tokenizer: n
    }), v(U);
  }
  function v(U) {
    if (U === null) {
      F(e.exit("chunkFlow"), !0), z(0), e.consume(U);
      return;
    }
    return le(U) ? (e.consume(U), F(e.exit("chunkFlow")), r = 0, t.interrupt = void 0, o) : (e.consume(U), v);
  }
  function F(U, $) {
    const O = t.sliceStream(U);
    if ($ && O.push(null), U.previous = s, s && (s.next = U), s = U, n.defineSkip(U.start), n.write(O), t.parser.lazy[U.start.line]) {
      let p = n.events.length;
      for (; p--; )
        if (
          // The token starts before the line ending
          n.events[p][1].start.offset < i && // and either is not ended yet
          (!n.events[p][1].end || // or ends after it.
          n.events[p][1].end.offset > i)
        )
          return;
      const M = t.events.length;
      let te = M, Z, P;
      for (; te--; )
        if (t.events[te][0] === "exit" && t.events[te][1].type === "chunkFlow") {
          if (Z) {
            P = t.events[te][1].end;
            break;
          }
          Z = !0;
        }
      for (z(r), p = M; p < t.events.length; )
        t.events[p][1].end = Object.assign({}, P), p++;
      Bt(
        t.events,
        te + 1,
        0,
        t.events.slice(M)
      ), t.events.length = p;
    }
  }
  function z(U) {
    let $ = a.length;
    for (; $-- > U; ) {
      const O = a[$];
      t.containerState = O[1], O[0].exit.call(t, e);
    }
    a.length = U;
  }
  function C() {
    n.write([null]), s = void 0, n = void 0, t.containerState._closeFlow = void 0;
  }
}
function Bh(e, t, a) {
  return xe(
    e,
    e.attempt(this.parser.constructs.document, t, a),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
function Sn(e) {
  if (e === null || Oe(e) || Va(e))
    return 1;
  if (qn(e))
    return 2;
}
function Yn(e, t, a) {
  const r = [];
  let n = -1;
  for (; ++n < e.length; ) {
    const s = e[n].resolveAll;
    s && !r.includes(s) && (t = s(t, a), r.push(s));
  }
  return t;
}
const Xs = {
  name: "attention",
  tokenize: Hh,
  resolveAll: Ph
};
function Ph(e, t) {
  let a = -1, r, n, s, i, o, c, u, d;
  for (; ++a < e.length; )
    if (e[a][0] === "enter" && e[a][1].type === "attentionSequence" && e[a][1]._close) {
      for (r = a; r--; )
        if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && // If the markers are the same:
        t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[a][1]).charCodeAt(0)) {
          if ((e[r][1]._close || e[a][1]._open) && (e[a][1].end.offset - e[a][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[a][1].end.offset - e[a][1].start.offset) % 3))
            continue;
          c = e[r][1].end.offset - e[r][1].start.offset > 1 && e[a][1].end.offset - e[a][1].start.offset > 1 ? 2 : 1;
          const m = Object.assign({}, e[r][1].end), h = Object.assign({}, e[a][1].start);
          So(m, -c), So(h, c), i = {
            type: c > 1 ? "strongSequence" : "emphasisSequence",
            start: m,
            end: Object.assign({}, e[r][1].end)
          }, o = {
            type: c > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, e[a][1].start),
            end: h
          }, s = {
            type: c > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, e[r][1].end),
            end: Object.assign({}, e[a][1].start)
          }, n = {
            type: c > 1 ? "strong" : "emphasis",
            start: Object.assign({}, i.start),
            end: Object.assign({}, o.end)
          }, e[r][1].end = Object.assign({}, i.start), e[a][1].start = Object.assign({}, o.end), u = [], e[r][1].end.offset - e[r][1].start.offset && (u = Ot(u, [["enter", e[r][1], t], ["exit", e[r][1], t]])), u = Ot(u, [["enter", n, t], ["enter", i, t], ["exit", i, t], ["enter", s, t]]), u = Ot(u, Yn(t.parser.constructs.insideSpan.null, e.slice(r + 1, a), t)), u = Ot(u, [["exit", s, t], ["enter", o, t], ["exit", o, t], ["exit", n, t]]), e[a][1].end.offset - e[a][1].start.offset ? (d = 2, u = Ot(u, [["enter", e[a][1], t], ["exit", e[a][1], t]])) : d = 0, Bt(e, r - 1, a - r + 3, u), a = r + u.length - d - 2;
          break;
        }
    }
  for (a = -1; ++a < e.length; )
    e[a][1].type === "attentionSequence" && (e[a][1].type = "data");
  return e;
}
function Hh(e, t) {
  const a = this.parser.constructs.attentionMarkers.null, r = this.previous, n = Sn(r);
  let s;
  return i;
  function i(c) {
    return s = c, e.enter("attentionSequence"), o(c);
  }
  function o(c) {
    if (c === s)
      return e.consume(c), o;
    const u = e.exit("attentionSequence"), d = Sn(c), m = !d || d === 2 && n || a.includes(c), h = !n || n === 2 && d || a.includes(r);
    return u._open = !!(s === 42 ? m : m && (n || !h)), u._close = !!(s === 42 ? h : h && (d || !m)), t(c);
  }
}
function So(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
const Uh = {
  name: "autolink",
  tokenize: jh
};
function jh(e, t, a) {
  let r = 0;
  return n;
  function n(y) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(y), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), s;
  }
  function s(y) {
    return yt(y) ? (e.consume(y), i) : y === 64 ? a(y) : u(y);
  }
  function i(y) {
    return y === 43 || y === 45 || y === 46 || ft(y) ? (r = 1, o(y)) : u(y);
  }
  function o(y) {
    return y === 58 ? (e.consume(y), r = 0, c) : (y === 43 || y === 45 || y === 46 || ft(y)) && r++ < 32 ? (e.consume(y), o) : (r = 0, u(y));
  }
  function c(y) {
    return y === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(y), e.exit("autolinkMarker"), e.exit("autolink"), t) : y === null || y === 32 || y === 60 || Cn(y) ? a(y) : (e.consume(y), c);
  }
  function u(y) {
    return y === 64 ? (e.consume(y), d) : Nh(y) ? (e.consume(y), u) : a(y);
  }
  function d(y) {
    return ft(y) ? m(y) : a(y);
  }
  function m(y) {
    return y === 46 ? (e.consume(y), r = 0, d) : y === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(y), e.exit("autolinkMarker"), e.exit("autolink"), t) : h(y);
  }
  function h(y) {
    if ((y === 45 || ft(y)) && r++ < 63) {
      const w = y === 45 ? h : m;
      return e.consume(y), w;
    }
    return a(y);
  }
}
const Jr = {
  tokenize: qh,
  partial: !0
};
function qh(e, t, a) {
  return r;
  function r(s) {
    return Ae(s) ? xe(e, n, "linePrefix")(s) : n(s);
  }
  function n(s) {
    return s === null || le(s) ? t(s) : a(s);
  }
}
const Ml = {
  name: "blockQuote",
  tokenize: Yh,
  continuation: {
    tokenize: Vh
  },
  exit: Gh
};
function Yh(e, t, a) {
  const r = this;
  return n;
  function n(i) {
    if (i === 62) {
      const o = r.containerState;
      return o.open || (e.enter("blockQuote", {
        _container: !0
      }), o.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(i), e.exit("blockQuoteMarker"), s;
    }
    return a(i);
  }
  function s(i) {
    return Ae(i) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(i), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(i));
  }
}
function Vh(e, t, a) {
  const r = this;
  return n;
  function n(i) {
    return Ae(i) ? xe(e, s, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(i) : s(i);
  }
  function s(i) {
    return e.attempt(Ml, t, a)(i);
  }
}
function Gh(e) {
  e.exit("blockQuote");
}
const Bl = {
  name: "characterEscape",
  tokenize: Wh
};
function Wh(e, t, a) {
  return r;
  function r(s) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(s), e.exit("escapeMarker"), n;
  }
  function n(s) {
    return Rh(s) ? (e.enter("characterEscapeValue"), e.consume(s), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : a(s);
  }
}
const Pl = {
  name: "characterReference",
  tokenize: $h
};
function $h(e, t, a) {
  const r = this;
  let n = 0, s, i;
  return o;
  function o(m) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(m), e.exit("characterReferenceMarker"), c;
  }
  function c(m) {
    return m === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(m), e.exit("characterReferenceMarkerNumeric"), u) : (e.enter("characterReferenceValue"), s = 31, i = ft, d(m));
  }
  function u(m) {
    return m === 88 || m === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(m), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), s = 6, i = Ih, d) : (e.enter("characterReferenceValue"), s = 7, i = $s, d(m));
  }
  function d(m) {
    if (m === 59 && n) {
      const h = e.exit("characterReferenceValue");
      return i === ft && !vi(r.sliceSerialize(h)) ? a(m) : (e.enter("characterReferenceMarker"), e.consume(m), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
    }
    return i(m) && n++ < s ? (e.consume(m), d) : a(m);
  }
}
const zo = {
  tokenize: Qh,
  partial: !0
}, No = {
  name: "codeFenced",
  tokenize: Xh,
  concrete: !0
};
function Xh(e, t, a) {
  const r = this, n = {
    tokenize: O,
    partial: !0
  };
  let s = 0, i = 0, o;
  return c;
  function c(p) {
    return u(p);
  }
  function u(p) {
    const M = r.events[r.events.length - 1];
    return s = M && M[1].type === "linePrefix" ? M[2].sliceSerialize(M[1], !0).length : 0, o = p, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), d(p);
  }
  function d(p) {
    return p === o ? (i++, e.consume(p), d) : i < 3 ? a(p) : (e.exit("codeFencedFenceSequence"), Ae(p) ? xe(e, m, "whitespace")(p) : m(p));
  }
  function m(p) {
    return p === null || le(p) ? (e.exit("codeFencedFence"), r.interrupt ? t(p) : e.check(zo, v, $)(p)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), h(p));
  }
  function h(p) {
    return p === null || le(p) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), m(p)) : Ae(p) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), xe(e, y, "whitespace")(p)) : p === 96 && p === o ? a(p) : (e.consume(p), h);
  }
  function y(p) {
    return p === null || le(p) ? m(p) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), w(p));
  }
  function w(p) {
    return p === null || le(p) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), m(p)) : p === 96 && p === o ? a(p) : (e.consume(p), w);
  }
  function v(p) {
    return e.attempt(n, $, F)(p);
  }
  function F(p) {
    return e.enter("lineEnding"), e.consume(p), e.exit("lineEnding"), z;
  }
  function z(p) {
    return s > 0 && Ae(p) ? xe(e, C, "linePrefix", s + 1)(p) : C(p);
  }
  function C(p) {
    return p === null || le(p) ? e.check(zo, v, $)(p) : (e.enter("codeFlowValue"), U(p));
  }
  function U(p) {
    return p === null || le(p) ? (e.exit("codeFlowValue"), C(p)) : (e.consume(p), U);
  }
  function $(p) {
    return e.exit("codeFenced"), t(p);
  }
  function O(p, M, te) {
    let Z = 0;
    return P;
    function P(fe) {
      return p.enter("lineEnding"), p.consume(fe), p.exit("lineEnding"), re;
    }
    function re(fe) {
      return p.enter("codeFencedFence"), Ae(fe) ? xe(p, ae, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(fe) : ae(fe);
    }
    function ae(fe) {
      return fe === o ? (p.enter("codeFencedFenceSequence"), ue(fe)) : te(fe);
    }
    function ue(fe) {
      return fe === o ? (Z++, p.consume(fe), ue) : Z >= i ? (p.exit("codeFencedFenceSequence"), Ae(fe) ? xe(p, de, "whitespace")(fe) : de(fe)) : te(fe);
    }
    function de(fe) {
      return fe === null || le(fe) ? (p.exit("codeFencedFence"), M(fe)) : te(fe);
    }
  }
}
function Qh(e, t, a) {
  const r = this;
  return n;
  function n(i) {
    return i === null ? a(i) : (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), s);
  }
  function s(i) {
    return r.parser.lazy[r.now().line] ? a(i) : t(i);
  }
}
const ps = {
  name: "codeIndented",
  tokenize: Jh
}, Kh = {
  tokenize: Zh,
  partial: !0
};
function Jh(e, t, a) {
  const r = this;
  return n;
  function n(u) {
    return e.enter("codeIndented"), xe(e, s, "linePrefix", 5)(u);
  }
  function s(u) {
    const d = r.events[r.events.length - 1];
    return d && d[1].type === "linePrefix" && d[2].sliceSerialize(d[1], !0).length >= 4 ? i(u) : a(u);
  }
  function i(u) {
    return u === null ? c(u) : le(u) ? e.attempt(Kh, i, c)(u) : (e.enter("codeFlowValue"), o(u));
  }
  function o(u) {
    return u === null || le(u) ? (e.exit("codeFlowValue"), i(u)) : (e.consume(u), o);
  }
  function c(u) {
    return e.exit("codeIndented"), t(u);
  }
}
function Zh(e, t, a) {
  const r = this;
  return n;
  function n(i) {
    return r.parser.lazy[r.now().line] ? a(i) : le(i) ? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), n) : xe(e, s, "linePrefix", 5)(i);
  }
  function s(i) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "linePrefix" && o[2].sliceSerialize(o[1], !0).length >= 4 ? t(i) : le(i) ? n(i) : a(i);
  }
}
const ed = {
  name: "codeText",
  tokenize: rd,
  resolve: td,
  previous: ad
};
function td(e) {
  let t = e.length - 4, a = 3, r, n;
  if ((e[a][1].type === "lineEnding" || e[a][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (r = a; ++r < t; )
      if (e[r][1].type === "codeTextData") {
        e[a][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", a += 2, t -= 2;
        break;
      }
  }
  for (r = a - 1, t++; ++r <= t; )
    n === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (n = r) : (r === t || e[r][1].type === "lineEnding") && (e[n][1].type = "codeTextData", r !== n + 2 && (e[n][1].end = e[r - 1][1].end, e.splice(n + 2, r - n - 2), t -= r - n - 2, r = n + 2), n = void 0);
  return e;
}
function ad(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function rd(e, t, a) {
  let r = 0, n, s;
  return i;
  function i(m) {
    return e.enter("codeText"), e.enter("codeTextSequence"), o(m);
  }
  function o(m) {
    return m === 96 ? (e.consume(m), r++, o) : (e.exit("codeTextSequence"), c(m));
  }
  function c(m) {
    return m === null ? a(m) : m === 32 ? (e.enter("space"), e.consume(m), e.exit("space"), c) : m === 96 ? (s = e.enter("codeTextSequence"), n = 0, d(m)) : le(m) ? (e.enter("lineEnding"), e.consume(m), e.exit("lineEnding"), c) : (e.enter("codeTextData"), u(m));
  }
  function u(m) {
    return m === null || m === 32 || m === 96 || le(m) ? (e.exit("codeTextData"), c(m)) : (e.consume(m), u);
  }
  function d(m) {
    return m === 96 ? (e.consume(m), n++, d) : n === r ? (e.exit("codeTextSequence"), e.exit("codeText"), t(m)) : (s.type = "codeTextData", u(m));
  }
}
class nd {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(t) {
    this.left = t ? [...t] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(t) {
    if (t < 0 || t >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + t + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(t, a) {
    const r = a ?? Number.POSITIVE_INFINITY;
    return r < this.left.length ? this.left.slice(t, r) : t > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - t + this.left.length).reverse() : this.left.slice(t).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(t, a, r) {
    const n = a || 0;
    this.setCursor(Math.trunc(t));
    const s = this.right.splice(this.right.length - n, Number.POSITIVE_INFINITY);
    return r && Dr(this.left, r), s.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(t) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(t) {
    this.setCursor(Number.POSITIVE_INFINITY), Dr(this.left, t);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(t) {
    this.setCursor(0), this.right.push(t);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(t) {
    this.setCursor(0), Dr(this.right, t.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(t) {
    if (!(t === this.left.length || t > this.left.length && this.right.length === 0 || t < 0 && this.left.length === 0))
      if (t < this.left.length) {
        const a = this.left.splice(t, Number.POSITIVE_INFINITY);
        Dr(this.right, a.reverse());
      } else {
        const a = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY);
        Dr(this.left, a.reverse());
      }
  }
}
function Dr(e, t) {
  let a = 0;
  if (t.length < 1e4)
    e.push(...t);
  else
    for (; a < t.length; )
      e.push(...t.slice(a, a + 1e4)), a += 1e4;
}
function Hl(e) {
  const t = {};
  let a = -1, r, n, s, i, o, c, u;
  const d = new nd(e);
  for (; ++a < d.length; ) {
    for (; a in t; )
      a = t[a];
    if (r = d.get(a), a && r[1].type === "chunkFlow" && d.get(a - 1)[1].type === "listItemPrefix" && (c = r[1]._tokenizer.events, s = 0, s < c.length && c[s][1].type === "lineEndingBlank" && (s += 2), s < c.length && c[s][1].type === "content"))
      for (; ++s < c.length && c[s][1].type !== "content"; )
        c[s][1].type === "chunkText" && (c[s][1]._isInFirstContentOfListItem = !0, s++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(t, sd(d, a)), a = t[a], u = !0);
    else if (r[1]._container) {
      for (s = a, n = void 0; s-- && (i = d.get(s), i[1].type === "lineEnding" || i[1].type === "lineEndingBlank"); )
        i[0] === "enter" && (n && (d.get(n)[1].type = "lineEndingBlank"), i[1].type = "lineEnding", n = s);
      n && (r[1].end = Object.assign({}, d.get(n)[1].start), o = d.slice(n, a), o.unshift(r), d.splice(n, a - n + 1, o));
    }
  }
  return Bt(e, 0, Number.POSITIVE_INFINITY, d.slice(0)), !u;
}
function sd(e, t) {
  const a = e.get(t)[1], r = e.get(t)[2];
  let n = t - 1;
  const s = [], i = a._tokenizer || r.parser[a.contentType](a.start), o = i.events, c = [], u = {};
  let d, m, h = -1, y = a, w = 0, v = 0;
  const F = [v];
  for (; y; ) {
    for (; e.get(++n)[1] !== y; )
      ;
    s.push(n), y._tokenizer || (d = r.sliceStream(y), y.next || d.push(null), m && i.defineSkip(y.start), y._isInFirstContentOfListItem && (i._gfmTasklistFirstContentOfListItem = !0), i.write(d), y._isInFirstContentOfListItem && (i._gfmTasklistFirstContentOfListItem = void 0)), m = y, y = y.next;
  }
  for (y = a; ++h < o.length; )
    // Find a void token that includes a break.
    o[h][0] === "exit" && o[h - 1][0] === "enter" && o[h][1].type === o[h - 1][1].type && o[h][1].start.line !== o[h][1].end.line && (v = h + 1, F.push(v), y._tokenizer = void 0, y.previous = void 0, y = y.next);
  for (i.events = [], y ? (y._tokenizer = void 0, y.previous = void 0) : F.pop(), h = F.length; h--; ) {
    const z = o.slice(F[h], F[h + 1]), C = s.pop();
    c.push([C, C + z.length - 1]), e.splice(C, 2, z);
  }
  for (c.reverse(), h = -1; ++h < c.length; )
    u[w + c[h][0]] = w + c[h][1], w += c[h][1] - c[h][0] - 1;
  return u;
}
const id = {
  tokenize: ld,
  resolve: cd
}, od = {
  tokenize: ud,
  partial: !0
};
function cd(e) {
  return Hl(e), e;
}
function ld(e, t) {
  let a;
  return r;
  function r(o) {
    return e.enter("content"), a = e.enter("chunkContent", {
      contentType: "content"
    }), n(o);
  }
  function n(o) {
    return o === null ? s(o) : le(o) ? e.check(od, i, s)(o) : (e.consume(o), n);
  }
  function s(o) {
    return e.exit("chunkContent"), e.exit("content"), t(o);
  }
  function i(o) {
    return e.consume(o), e.exit("chunkContent"), a.next = e.enter("chunkContent", {
      contentType: "content",
      previous: a
    }), a = a.next, n;
  }
}
function ud(e, t, a) {
  const r = this;
  return n;
  function n(i) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), xe(e, s, "linePrefix");
  }
  function s(i) {
    if (i === null || le(i))
      return a(i);
    const o = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && o && o[1].type === "linePrefix" && o[2].sliceSerialize(o[1], !0).length >= 4 ? t(i) : e.interrupt(r.parser.constructs.flow, a, t)(i);
  }
}
function Ul(e, t, a, r, n, s, i, o, c) {
  const u = c || Number.POSITIVE_INFINITY;
  let d = 0;
  return m;
  function m(z) {
    return z === 60 ? (e.enter(r), e.enter(n), e.enter(s), e.consume(z), e.exit(s), h) : z === null || z === 32 || z === 41 || Cn(z) ? a(z) : (e.enter(r), e.enter(i), e.enter(o), e.enter("chunkString", {
      contentType: "string"
    }), v(z));
  }
  function h(z) {
    return z === 62 ? (e.enter(s), e.consume(z), e.exit(s), e.exit(n), e.exit(r), t) : (e.enter(o), e.enter("chunkString", {
      contentType: "string"
    }), y(z));
  }
  function y(z) {
    return z === 62 ? (e.exit("chunkString"), e.exit(o), h(z)) : z === null || z === 60 || le(z) ? a(z) : (e.consume(z), z === 92 ? w : y);
  }
  function w(z) {
    return z === 60 || z === 62 || z === 92 ? (e.consume(z), y) : y(z);
  }
  function v(z) {
    return !d && (z === null || z === 41 || Oe(z)) ? (e.exit("chunkString"), e.exit(o), e.exit(i), e.exit(r), t(z)) : d < u && z === 40 ? (e.consume(z), d++, v) : z === 41 ? (e.consume(z), d--, v) : z === null || z === 32 || z === 40 || Cn(z) ? a(z) : (e.consume(z), z === 92 ? F : v);
  }
  function F(z) {
    return z === 40 || z === 41 || z === 92 ? (e.consume(z), v) : v(z);
  }
}
function jl(e, t, a, r, n, s) {
  const i = this;
  let o = 0, c;
  return u;
  function u(y) {
    return e.enter(r), e.enter(n), e.consume(y), e.exit(n), e.enter(s), d;
  }
  function d(y) {
    return o > 999 || y === null || y === 91 || y === 93 && !c || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    y === 94 && !o && "_hiddenFootnoteSupport" in i.parser.constructs ? a(y) : y === 93 ? (e.exit(s), e.enter(n), e.consume(y), e.exit(n), e.exit(r), t) : le(y) ? (e.enter("lineEnding"), e.consume(y), e.exit("lineEnding"), d) : (e.enter("chunkString", {
      contentType: "string"
    }), m(y));
  }
  function m(y) {
    return y === null || y === 91 || y === 93 || le(y) || o++ > 999 ? (e.exit("chunkString"), d(y)) : (e.consume(y), c || (c = !Ae(y)), y === 92 ? h : m);
  }
  function h(y) {
    return y === 91 || y === 92 || y === 93 ? (e.consume(y), o++, m) : m(y);
  }
}
function ql(e, t, a, r, n, s) {
  let i;
  return o;
  function o(h) {
    return h === 34 || h === 39 || h === 40 ? (e.enter(r), e.enter(n), e.consume(h), e.exit(n), i = h === 40 ? 41 : h, c) : a(h);
  }
  function c(h) {
    return h === i ? (e.enter(n), e.consume(h), e.exit(n), e.exit(r), t) : (e.enter(s), u(h));
  }
  function u(h) {
    return h === i ? (e.exit(s), c(i)) : h === null ? a(h) : le(h) ? (e.enter("lineEnding"), e.consume(h), e.exit("lineEnding"), xe(e, u, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), d(h));
  }
  function d(h) {
    return h === i || h === null || le(h) ? (e.exit("chunkString"), u(h)) : (e.consume(h), h === 92 ? m : d);
  }
  function m(h) {
    return h === i || h === 92 ? (e.consume(h), d) : d(h);
  }
}
function Lr(e, t) {
  let a;
  return r;
  function r(n) {
    return le(n) ? (e.enter("lineEnding"), e.consume(n), e.exit("lineEnding"), a = !0, r) : Ae(n) ? xe(
      e,
      r,
      a ? "linePrefix" : "lineSuffix"
    )(n) : t(n);
  }
}
const fd = {
  name: "definition",
  tokenize: dd
}, hd = {
  tokenize: md,
  partial: !0
};
function dd(e, t, a) {
  const r = this;
  let n;
  return s;
  function s(y) {
    return e.enter("definition"), i(y);
  }
  function i(y) {
    return jl.call(
      r,
      e,
      o,
      // Note: we dont need to reset the way `markdown-rs` does.
      a,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(y);
  }
  function o(y) {
    return n = Gt(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), y === 58 ? (e.enter("definitionMarker"), e.consume(y), e.exit("definitionMarker"), c) : a(y);
  }
  function c(y) {
    return Oe(y) ? Lr(e, u)(y) : u(y);
  }
  function u(y) {
    return Ul(
      e,
      d,
      // Note: we dont need to reset the way `markdown-rs` does.
      a,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(y);
  }
  function d(y) {
    return e.attempt(hd, m, m)(y);
  }
  function m(y) {
    return Ae(y) ? xe(e, h, "whitespace")(y) : h(y);
  }
  function h(y) {
    return y === null || le(y) ? (e.exit("definition"), r.parser.defined.push(n), t(y)) : a(y);
  }
}
function md(e, t, a) {
  return r;
  function r(o) {
    return Oe(o) ? Lr(e, n)(o) : a(o);
  }
  function n(o) {
    return ql(e, s, a, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(o);
  }
  function s(o) {
    return Ae(o) ? xe(e, i, "whitespace")(o) : i(o);
  }
  function i(o) {
    return o === null || le(o) ? t(o) : a(o);
  }
}
const pd = {
  name: "hardBreakEscape",
  tokenize: gd
};
function gd(e, t, a) {
  return r;
  function r(s) {
    return e.enter("hardBreakEscape"), e.consume(s), n;
  }
  function n(s) {
    return le(s) ? (e.exit("hardBreakEscape"), t(s)) : a(s);
  }
}
const yd = {
  name: "headingAtx",
  tokenize: bd,
  resolve: _d
};
function _d(e, t) {
  let a = e.length - 2, r = 3, n, s;
  return e[r][1].type === "whitespace" && (r += 2), a - 2 > r && e[a][1].type === "whitespace" && (a -= 2), e[a][1].type === "atxHeadingSequence" && (r === a - 1 || a - 4 > r && e[a - 2][1].type === "whitespace") && (a -= r + 1 === a ? 2 : 4), a > r && (n = {
    type: "atxHeadingText",
    start: e[r][1].start,
    end: e[a][1].end
  }, s = {
    type: "chunkText",
    start: e[r][1].start,
    end: e[a][1].end,
    contentType: "text"
  }, Bt(e, r, a - r + 1, [["enter", n, t], ["enter", s, t], ["exit", s, t], ["exit", n, t]])), e;
}
function bd(e, t, a) {
  let r = 0;
  return n;
  function n(d) {
    return e.enter("atxHeading"), s(d);
  }
  function s(d) {
    return e.enter("atxHeadingSequence"), i(d);
  }
  function i(d) {
    return d === 35 && r++ < 6 ? (e.consume(d), i) : d === null || Oe(d) ? (e.exit("atxHeadingSequence"), o(d)) : a(d);
  }
  function o(d) {
    return d === 35 ? (e.enter("atxHeadingSequence"), c(d)) : d === null || le(d) ? (e.exit("atxHeading"), t(d)) : Ae(d) ? xe(e, o, "whitespace")(d) : (e.enter("atxHeadingText"), u(d));
  }
  function c(d) {
    return d === 35 ? (e.consume(d), c) : (e.exit("atxHeadingSequence"), o(d));
  }
  function u(d) {
    return d === null || d === 35 || Oe(d) ? (e.exit("atxHeadingText"), o(d)) : (e.consume(d), u);
  }
}
const kd = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], Io = ["pre", "script", "style", "textarea"], wd = {
  name: "htmlFlow",
  tokenize: xd,
  resolveTo: vd,
  concrete: !0
}, Ed = {
  tokenize: Dd,
  partial: !0
}, Td = {
  tokenize: Ad,
  partial: !0
};
function vd(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
}
function xd(e, t, a) {
  const r = this;
  let n, s, i, o, c;
  return u;
  function u(N) {
    return d(N);
  }
  function d(N) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(N), m;
  }
  function m(N) {
    return N === 33 ? (e.consume(N), h) : N === 47 ? (e.consume(N), s = !0, v) : N === 63 ? (e.consume(N), n = 3, r.interrupt ? t : S) : yt(N) ? (e.consume(N), i = String.fromCharCode(N), F) : a(N);
  }
  function h(N) {
    return N === 45 ? (e.consume(N), n = 2, y) : N === 91 ? (e.consume(N), n = 5, o = 0, w) : yt(N) ? (e.consume(N), n = 4, r.interrupt ? t : S) : a(N);
  }
  function y(N) {
    return N === 45 ? (e.consume(N), r.interrupt ? t : S) : a(N);
  }
  function w(N) {
    const tt = "CDATA[";
    return N === tt.charCodeAt(o++) ? (e.consume(N), o === tt.length ? r.interrupt ? t : ae : w) : a(N);
  }
  function v(N) {
    return yt(N) ? (e.consume(N), i = String.fromCharCode(N), F) : a(N);
  }
  function F(N) {
    if (N === null || N === 47 || N === 62 || Oe(N)) {
      const tt = N === 47, st = i.toLowerCase();
      return !tt && !s && Io.includes(st) ? (n = 1, r.interrupt ? t(N) : ae(N)) : kd.includes(i.toLowerCase()) ? (n = 6, tt ? (e.consume(N), z) : r.interrupt ? t(N) : ae(N)) : (n = 7, r.interrupt && !r.parser.lazy[r.now().line] ? a(N) : s ? C(N) : U(N));
    }
    return N === 45 || ft(N) ? (e.consume(N), i += String.fromCharCode(N), F) : a(N);
  }
  function z(N) {
    return N === 62 ? (e.consume(N), r.interrupt ? t : ae) : a(N);
  }
  function C(N) {
    return Ae(N) ? (e.consume(N), C) : P(N);
  }
  function U(N) {
    return N === 47 ? (e.consume(N), P) : N === 58 || N === 95 || yt(N) ? (e.consume(N), $) : Ae(N) ? (e.consume(N), U) : P(N);
  }
  function $(N) {
    return N === 45 || N === 46 || N === 58 || N === 95 || ft(N) ? (e.consume(N), $) : O(N);
  }
  function O(N) {
    return N === 61 ? (e.consume(N), p) : Ae(N) ? (e.consume(N), O) : U(N);
  }
  function p(N) {
    return N === null || N === 60 || N === 61 || N === 62 || N === 96 ? a(N) : N === 34 || N === 39 ? (e.consume(N), c = N, M) : Ae(N) ? (e.consume(N), p) : te(N);
  }
  function M(N) {
    return N === c ? (e.consume(N), c = null, Z) : N === null || le(N) ? a(N) : (e.consume(N), M);
  }
  function te(N) {
    return N === null || N === 34 || N === 39 || N === 47 || N === 60 || N === 61 || N === 62 || N === 96 || Oe(N) ? O(N) : (e.consume(N), te);
  }
  function Z(N) {
    return N === 47 || N === 62 || Ae(N) ? U(N) : a(N);
  }
  function P(N) {
    return N === 62 ? (e.consume(N), re) : a(N);
  }
  function re(N) {
    return N === null || le(N) ? ae(N) : Ae(N) ? (e.consume(N), re) : a(N);
  }
  function ae(N) {
    return N === 45 && n === 2 ? (e.consume(N), Se) : N === 60 && n === 1 ? (e.consume(N), Ne) : N === 62 && n === 4 ? (e.consume(N), Me) : N === 63 && n === 3 ? (e.consume(N), S) : N === 93 && n === 5 ? (e.consume(N), et) : le(N) && (n === 6 || n === 7) ? (e.exit("htmlFlowData"), e.check(Ed, Re, ue)(N)) : N === null || le(N) ? (e.exit("htmlFlowData"), ue(N)) : (e.consume(N), ae);
  }
  function ue(N) {
    return e.check(Td, de, Re)(N);
  }
  function de(N) {
    return e.enter("lineEnding"), e.consume(N), e.exit("lineEnding"), fe;
  }
  function fe(N) {
    return N === null || le(N) ? ue(N) : (e.enter("htmlFlowData"), ae(N));
  }
  function Se(N) {
    return N === 45 ? (e.consume(N), S) : ae(N);
  }
  function Ne(N) {
    return N === 47 ? (e.consume(N), i = "", je) : ae(N);
  }
  function je(N) {
    if (N === 62) {
      const tt = i.toLowerCase();
      return Io.includes(tt) ? (e.consume(N), Me) : ae(N);
    }
    return yt(N) && i.length < 8 ? (e.consume(N), i += String.fromCharCode(N), je) : ae(N);
  }
  function et(N) {
    return N === 93 ? (e.consume(N), S) : ae(N);
  }
  function S(N) {
    return N === 62 ? (e.consume(N), Me) : N === 45 && n === 2 ? (e.consume(N), S) : ae(N);
  }
  function Me(N) {
    return N === null || le(N) ? (e.exit("htmlFlowData"), Re(N)) : (e.consume(N), Me);
  }
  function Re(N) {
    return e.exit("htmlFlow"), t(N);
  }
}
function Ad(e, t, a) {
  const r = this;
  return n;
  function n(i) {
    return le(i) ? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), s) : a(i);
  }
  function s(i) {
    return r.parser.lazy[r.now().line] ? a(i) : t(i);
  }
}
function Dd(e, t, a) {
  return r;
  function r(n) {
    return e.enter("lineEnding"), e.consume(n), e.exit("lineEnding"), e.attempt(Jr, t, a);
  }
}
const Cd = {
  name: "htmlText",
  tokenize: Sd
};
function Sd(e, t, a) {
  const r = this;
  let n, s, i;
  return o;
  function o(S) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(S), c;
  }
  function c(S) {
    return S === 33 ? (e.consume(S), u) : S === 47 ? (e.consume(S), O) : S === 63 ? (e.consume(S), U) : yt(S) ? (e.consume(S), te) : a(S);
  }
  function u(S) {
    return S === 45 ? (e.consume(S), d) : S === 91 ? (e.consume(S), s = 0, w) : yt(S) ? (e.consume(S), C) : a(S);
  }
  function d(S) {
    return S === 45 ? (e.consume(S), y) : a(S);
  }
  function m(S) {
    return S === null ? a(S) : S === 45 ? (e.consume(S), h) : le(S) ? (i = m, Ne(S)) : (e.consume(S), m);
  }
  function h(S) {
    return S === 45 ? (e.consume(S), y) : m(S);
  }
  function y(S) {
    return S === 62 ? Se(S) : S === 45 ? h(S) : m(S);
  }
  function w(S) {
    const Me = "CDATA[";
    return S === Me.charCodeAt(s++) ? (e.consume(S), s === Me.length ? v : w) : a(S);
  }
  function v(S) {
    return S === null ? a(S) : S === 93 ? (e.consume(S), F) : le(S) ? (i = v, Ne(S)) : (e.consume(S), v);
  }
  function F(S) {
    return S === 93 ? (e.consume(S), z) : v(S);
  }
  function z(S) {
    return S === 62 ? Se(S) : S === 93 ? (e.consume(S), z) : v(S);
  }
  function C(S) {
    return S === null || S === 62 ? Se(S) : le(S) ? (i = C, Ne(S)) : (e.consume(S), C);
  }
  function U(S) {
    return S === null ? a(S) : S === 63 ? (e.consume(S), $) : le(S) ? (i = U, Ne(S)) : (e.consume(S), U);
  }
  function $(S) {
    return S === 62 ? Se(S) : U(S);
  }
  function O(S) {
    return yt(S) ? (e.consume(S), p) : a(S);
  }
  function p(S) {
    return S === 45 || ft(S) ? (e.consume(S), p) : M(S);
  }
  function M(S) {
    return le(S) ? (i = M, Ne(S)) : Ae(S) ? (e.consume(S), M) : Se(S);
  }
  function te(S) {
    return S === 45 || ft(S) ? (e.consume(S), te) : S === 47 || S === 62 || Oe(S) ? Z(S) : a(S);
  }
  function Z(S) {
    return S === 47 ? (e.consume(S), Se) : S === 58 || S === 95 || yt(S) ? (e.consume(S), P) : le(S) ? (i = Z, Ne(S)) : Ae(S) ? (e.consume(S), Z) : Se(S);
  }
  function P(S) {
    return S === 45 || S === 46 || S === 58 || S === 95 || ft(S) ? (e.consume(S), P) : re(S);
  }
  function re(S) {
    return S === 61 ? (e.consume(S), ae) : le(S) ? (i = re, Ne(S)) : Ae(S) ? (e.consume(S), re) : Z(S);
  }
  function ae(S) {
    return S === null || S === 60 || S === 61 || S === 62 || S === 96 ? a(S) : S === 34 || S === 39 ? (e.consume(S), n = S, ue) : le(S) ? (i = ae, Ne(S)) : Ae(S) ? (e.consume(S), ae) : (e.consume(S), de);
  }
  function ue(S) {
    return S === n ? (e.consume(S), n = void 0, fe) : S === null ? a(S) : le(S) ? (i = ue, Ne(S)) : (e.consume(S), ue);
  }
  function de(S) {
    return S === null || S === 34 || S === 39 || S === 60 || S === 61 || S === 96 ? a(S) : S === 47 || S === 62 || Oe(S) ? Z(S) : (e.consume(S), de);
  }
  function fe(S) {
    return S === 47 || S === 62 || Oe(S) ? Z(S) : a(S);
  }
  function Se(S) {
    return S === 62 ? (e.consume(S), e.exit("htmlTextData"), e.exit("htmlText"), t) : a(S);
  }
  function Ne(S) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(S), e.exit("lineEnding"), je;
  }
  function je(S) {
    return Ae(S) ? xe(e, et, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(S) : et(S);
  }
  function et(S) {
    return e.enter("htmlTextData"), i(S);
  }
}
const xi = {
  name: "labelEnd",
  tokenize: Od,
  resolveTo: Fd,
  resolveAll: Rd
}, zd = {
  tokenize: Ld
}, Nd = {
  tokenize: Md
}, Id = {
  tokenize: Bd
};
function Rd(e) {
  let t = -1;
  for (; ++t < e.length; ) {
    const a = e[t][1];
    (a.type === "labelImage" || a.type === "labelLink" || a.type === "labelEnd") && (e.splice(t + 1, a.type === "labelImage" ? 4 : 2), a.type = "data", t++);
  }
  return e;
}
function Fd(e, t) {
  let a = e.length, r = 0, n, s, i, o;
  for (; a--; )
    if (n = e[a][1], s) {
      if (n.type === "link" || n.type === "labelLink" && n._inactive)
        break;
      e[a][0] === "enter" && n.type === "labelLink" && (n._inactive = !0);
    } else if (i) {
      if (e[a][0] === "enter" && (n.type === "labelImage" || n.type === "labelLink") && !n._balanced && (s = a, n.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else n.type === "labelEnd" && (i = a);
  const c = {
    type: e[s][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, e[s][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, u = {
    type: "label",
    start: Object.assign({}, e[s][1].start),
    end: Object.assign({}, e[i][1].end)
  }, d = {
    type: "labelText",
    start: Object.assign({}, e[s + r + 2][1].end),
    end: Object.assign({}, e[i - 2][1].start)
  };
  return o = [["enter", c, t], ["enter", u, t]], o = Ot(o, e.slice(s + 1, s + r + 3)), o = Ot(o, [["enter", d, t]]), o = Ot(o, Yn(t.parser.constructs.insideSpan.null, e.slice(s + r + 4, i - 3), t)), o = Ot(o, [["exit", d, t], e[i - 2], e[i - 1], ["exit", u, t]]), o = Ot(o, e.slice(i + 1)), o = Ot(o, [["exit", c, t]]), Bt(e, s, e.length, o), e;
}
function Od(e, t, a) {
  const r = this;
  let n = r.events.length, s, i;
  for (; n--; )
    if ((r.events[n][1].type === "labelImage" || r.events[n][1].type === "labelLink") && !r.events[n][1]._balanced) {
      s = r.events[n][1];
      break;
    }
  return o;
  function o(h) {
    return s ? s._inactive ? m(h) : (i = r.parser.defined.includes(Gt(r.sliceSerialize({
      start: s.end,
      end: r.now()
    }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(h), e.exit("labelMarker"), e.exit("labelEnd"), c) : a(h);
  }
  function c(h) {
    return h === 40 ? e.attempt(zd, d, i ? d : m)(h) : h === 91 ? e.attempt(Nd, d, i ? u : m)(h) : i ? d(h) : m(h);
  }
  function u(h) {
    return e.attempt(Id, d, m)(h);
  }
  function d(h) {
    return t(h);
  }
  function m(h) {
    return s._balanced = !0, a(h);
  }
}
function Ld(e, t, a) {
  return r;
  function r(m) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(m), e.exit("resourceMarker"), n;
  }
  function n(m) {
    return Oe(m) ? Lr(e, s)(m) : s(m);
  }
  function s(m) {
    return m === 41 ? d(m) : Ul(e, i, o, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(m);
  }
  function i(m) {
    return Oe(m) ? Lr(e, c)(m) : d(m);
  }
  function o(m) {
    return a(m);
  }
  function c(m) {
    return m === 34 || m === 39 || m === 40 ? ql(e, u, a, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(m) : d(m);
  }
  function u(m) {
    return Oe(m) ? Lr(e, d)(m) : d(m);
  }
  function d(m) {
    return m === 41 ? (e.enter("resourceMarker"), e.consume(m), e.exit("resourceMarker"), e.exit("resource"), t) : a(m);
  }
}
function Md(e, t, a) {
  const r = this;
  return n;
  function n(o) {
    return jl.call(r, e, s, i, "reference", "referenceMarker", "referenceString")(o);
  }
  function s(o) {
    return r.parser.defined.includes(Gt(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? t(o) : a(o);
  }
  function i(o) {
    return a(o);
  }
}
function Bd(e, t, a) {
  return r;
  function r(s) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(s), e.exit("referenceMarker"), n;
  }
  function n(s) {
    return s === 93 ? (e.enter("referenceMarker"), e.consume(s), e.exit("referenceMarker"), e.exit("reference"), t) : a(s);
  }
}
const Pd = {
  name: "labelStartImage",
  tokenize: Hd,
  resolveAll: xi.resolveAll
};
function Hd(e, t, a) {
  const r = this;
  return n;
  function n(o) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(o), e.exit("labelImageMarker"), s;
  }
  function s(o) {
    return o === 91 ? (e.enter("labelMarker"), e.consume(o), e.exit("labelMarker"), e.exit("labelImage"), i) : a(o);
  }
  function i(o) {
    return o === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? a(o) : t(o);
  }
}
const Ud = {
  name: "labelStartLink",
  tokenize: jd,
  resolveAll: xi.resolveAll
};
function jd(e, t, a) {
  const r = this;
  return n;
  function n(i) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(i), e.exit("labelMarker"), e.exit("labelLink"), s;
  }
  function s(i) {
    return i === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? a(i) : t(i);
  }
}
const gs = {
  name: "lineEnding",
  tokenize: qd
};
function qd(e, t) {
  return a;
  function a(r) {
    return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), xe(e, t, "linePrefix");
  }
}
const En = {
  name: "thematicBreak",
  tokenize: Yd
};
function Yd(e, t, a) {
  let r = 0, n;
  return s;
  function s(u) {
    return e.enter("thematicBreak"), i(u);
  }
  function i(u) {
    return n = u, o(u);
  }
  function o(u) {
    return u === n ? (e.enter("thematicBreakSequence"), c(u)) : r >= 3 && (u === null || le(u)) ? (e.exit("thematicBreak"), t(u)) : a(u);
  }
  function c(u) {
    return u === n ? (e.consume(u), r++, c) : (e.exit("thematicBreakSequence"), Ae(u) ? xe(e, o, "whitespace")(u) : o(u));
  }
}
const wt = {
  name: "list",
  tokenize: Wd,
  continuation: {
    tokenize: $d
  },
  exit: Qd
}, Vd = {
  tokenize: Kd,
  partial: !0
}, Gd = {
  tokenize: Xd,
  partial: !0
};
function Wd(e, t, a) {
  const r = this, n = r.events[r.events.length - 1];
  let s = n && n[1].type === "linePrefix" ? n[2].sliceSerialize(n[1], !0).length : 0, i = 0;
  return o;
  function o(y) {
    const w = r.containerState.type || (y === 42 || y === 43 || y === 45 ? "listUnordered" : "listOrdered");
    if (w === "listUnordered" ? !r.containerState.marker || y === r.containerState.marker : $s(y)) {
      if (r.containerState.type || (r.containerState.type = w, e.enter(w, {
        _container: !0
      })), w === "listUnordered")
        return e.enter("listItemPrefix"), y === 42 || y === 45 ? e.check(En, a, u)(y) : u(y);
      if (!r.interrupt || y === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), c(y);
    }
    return a(y);
  }
  function c(y) {
    return $s(y) && ++i < 10 ? (e.consume(y), c) : (!r.interrupt || i < 2) && (r.containerState.marker ? y === r.containerState.marker : y === 41 || y === 46) ? (e.exit("listItemValue"), u(y)) : a(y);
  }
  function u(y) {
    return e.enter("listItemMarker"), e.consume(y), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || y, e.check(
      Jr,
      // Cant be empty when interrupting.
      r.interrupt ? a : d,
      e.attempt(Vd, h, m)
    );
  }
  function d(y) {
    return r.containerState.initialBlankLine = !0, s++, h(y);
  }
  function m(y) {
    return Ae(y) ? (e.enter("listItemPrefixWhitespace"), e.consume(y), e.exit("listItemPrefixWhitespace"), h) : a(y);
  }
  function h(y) {
    return r.containerState.size = s + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(y);
  }
}
function $d(e, t, a) {
  const r = this;
  return r.containerState._closeFlow = void 0, e.check(Jr, n, s);
  function n(o) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, xe(e, t, "listItemIndent", r.containerState.size + 1)(o);
  }
  function s(o) {
    return r.containerState.furtherBlankLines || !Ae(o) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, i(o)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(Gd, t, i)(o));
  }
  function i(o) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, xe(e, e.attempt(wt, t, a), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(o);
  }
}
function Xd(e, t, a) {
  const r = this;
  return xe(e, n, "listItemIndent", r.containerState.size + 1);
  function n(s) {
    const i = r.events[r.events.length - 1];
    return i && i[1].type === "listItemIndent" && i[2].sliceSerialize(i[1], !0).length === r.containerState.size ? t(s) : a(s);
  }
}
function Qd(e) {
  e.exit(this.containerState.type);
}
function Kd(e, t, a) {
  const r = this;
  return xe(e, n, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function n(s) {
    const i = r.events[r.events.length - 1];
    return !Ae(s) && i && i[1].type === "listItemPrefixWhitespace" ? t(s) : a(s);
  }
}
const Ro = {
  name: "setextUnderline",
  tokenize: Zd,
  resolveTo: Jd
};
function Jd(e, t) {
  let a = e.length, r, n, s;
  for (; a--; )
    if (e[a][0] === "enter") {
      if (e[a][1].type === "content") {
        r = a;
        break;
      }
      e[a][1].type === "paragraph" && (n = a);
    } else
      e[a][1].type === "content" && e.splice(a, 1), !s && e[a][1].type === "definition" && (s = a);
  const i = {
    type: "setextHeading",
    start: Object.assign({}, e[n][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  };
  return e[n][1].type = "setextHeadingText", s ? (e.splice(n, 0, ["enter", i, t]), e.splice(s + 1, 0, ["exit", e[r][1], t]), e[r][1].end = Object.assign({}, e[s][1].end)) : e[r][1] = i, e.push(["exit", i, t]), e;
}
function Zd(e, t, a) {
  const r = this;
  let n;
  return s;
  function s(u) {
    let d = r.events.length, m;
    for (; d--; )
      if (r.events[d][1].type !== "lineEnding" && r.events[d][1].type !== "linePrefix" && r.events[d][1].type !== "content") {
        m = r.events[d][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || m) ? (e.enter("setextHeadingLine"), n = u, i(u)) : a(u);
  }
  function i(u) {
    return e.enter("setextHeadingLineSequence"), o(u);
  }
  function o(u) {
    return u === n ? (e.consume(u), o) : (e.exit("setextHeadingLineSequence"), Ae(u) ? xe(e, c, "lineSuffix")(u) : c(u));
  }
  function c(u) {
    return u === null || le(u) ? (e.exit("setextHeadingLine"), t(u)) : a(u);
  }
}
const em = {
  tokenize: tm
};
function tm(e) {
  const t = this, a = e.attempt(
    // Try to parse a blank line.
    Jr,
    r,
    // Try to parse initial flow (essentially, only code).
    e.attempt(
      this.parser.constructs.flowInitial,
      n,
      xe(
        e,
        e.attempt(
          this.parser.constructs.flow,
          n,
          e.attempt(id, n)
        ),
        "linePrefix"
      )
    )
  );
  return a;
  function r(s) {
    if (s === null) {
      e.consume(s);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(s), e.exit("lineEndingBlank"), t.currentConstruct = void 0, a;
  }
  function n(s) {
    if (s === null) {
      e.consume(s);
      return;
    }
    return e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), t.currentConstruct = void 0, a;
  }
}
const am = {
  resolveAll: Vl()
}, rm = Yl("string"), nm = Yl("text");
function Yl(e) {
  return {
    tokenize: t,
    resolveAll: Vl(
      e === "text" ? sm : void 0
    )
  };
  function t(a) {
    const r = this, n = this.parser.constructs[e], s = a.attempt(n, i, o);
    return i;
    function i(d) {
      return u(d) ? s(d) : o(d);
    }
    function o(d) {
      if (d === null) {
        a.consume(d);
        return;
      }
      return a.enter("data"), a.consume(d), c;
    }
    function c(d) {
      return u(d) ? (a.exit("data"), s(d)) : (a.consume(d), c);
    }
    function u(d) {
      if (d === null)
        return !0;
      const m = n[d];
      let h = -1;
      if (m)
        for (; ++h < m.length; ) {
          const y = m[h];
          if (!y.previous || y.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function Vl(e) {
  return t;
  function t(a, r) {
    let n = -1, s;
    for (; ++n <= a.length; )
      s === void 0 ? a[n] && a[n][1].type === "data" && (s = n, n++) : (!a[n] || a[n][1].type !== "data") && (n !== s + 2 && (a[s][1].end = a[n - 1][1].end, a.splice(s + 2, n - s - 2), n = s + 2), s = void 0);
    return e ? e(a, r) : a;
  }
}
function sm(e, t) {
  let a = 0;
  for (; ++a <= e.length; )
    if ((a === e.length || e[a][1].type === "lineEnding") && e[a - 1][1].type === "data") {
      const r = e[a - 1][1], n = t.sliceStream(r);
      let s = n.length, i = -1, o = 0, c;
      for (; s--; ) {
        const u = n[s];
        if (typeof u == "string") {
          for (i = u.length; u.charCodeAt(i - 1) === 32; )
            o++, i--;
          if (i) break;
          i = -1;
        } else if (u === -2)
          c = !0, o++;
        else if (u !== -1) {
          s++;
          break;
        }
      }
      if (o) {
        const u = {
          type: a === e.length || c || o < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: r.end.line,
            column: r.end.column - o,
            offset: r.end.offset - o,
            _index: r.start._index + s,
            _bufferIndex: s ? i : r.start._bufferIndex + i
          },
          end: Object.assign({}, r.end)
        };
        r.end = Object.assign({}, u.start), r.start.offset === r.end.offset ? Object.assign(r, u) : (e.splice(
          a,
          0,
          ["enter", u, t],
          ["exit", u, t]
        ), a += 2);
      }
      a++;
    }
  return e;
}
function im(e, t, a) {
  let r = Object.assign(
    a ? Object.assign({}, a) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const n = {}, s = [];
  let i = [], o = [];
  const c = {
    consume: C,
    enter: U,
    exit: $,
    attempt: M(O),
    check: M(p),
    interrupt: M(p, {
      interrupt: !0
    })
  }, u = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser: e,
    sliceStream: y,
    sliceSerialize: h,
    now: w,
    defineSkip: v,
    write: m
  };
  let d = t.tokenize.call(u, c);
  return t.resolveAll && s.push(t), u;
  function m(re) {
    return i = Ot(i, re), F(), i[i.length - 1] !== null ? [] : (te(t, 0), u.events = Yn(s, u.events, u), u.events);
  }
  function h(re, ae) {
    return cm(y(re), ae);
  }
  function y(re) {
    return om(i, re);
  }
  function w() {
    const { line: re, column: ae, offset: ue, _index: de, _bufferIndex: fe } = r;
    return {
      line: re,
      column: ae,
      offset: ue,
      _index: de,
      _bufferIndex: fe
    };
  }
  function v(re) {
    n[re.line] = re.column, P();
  }
  function F() {
    let re;
    for (; r._index < i.length; ) {
      const ae = i[r._index];
      if (typeof ae == "string")
        for (re = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === re && r._bufferIndex < ae.length; )
          z(ae.charCodeAt(r._bufferIndex));
      else
        z(ae);
    }
  }
  function z(re) {
    d = d(re);
  }
  function C(re) {
    le(re) ? (r.line++, r.column = 1, r.offset += re === -3 ? 2 : 1, P()) : re !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === i[r._index].length && (r._bufferIndex = -1, r._index++)), u.previous = re;
  }
  function U(re, ae) {
    const ue = ae || {};
    return ue.type = re, ue.start = w(), u.events.push(["enter", ue, u]), o.push(ue), ue;
  }
  function $(re) {
    const ae = o.pop();
    return ae.end = w(), u.events.push(["exit", ae, u]), ae;
  }
  function O(re, ae) {
    te(re, ae.from);
  }
  function p(re, ae) {
    ae.restore();
  }
  function M(re, ae) {
    return ue;
    function ue(de, fe, Se) {
      let Ne, je, et, S;
      return Array.isArray(de) ? Re(de) : "tokenize" in de ? (
        // @ts-expect-error Looks like a construct.
        Re([de])
      ) : Me(de);
      function Me(Fe) {
        return Ke;
        function Ke(He) {
          const at = He !== null && Fe[He], $e = He !== null && Fe.null, $t = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(at) ? at : at ? [at] : [],
            ...Array.isArray($e) ? $e : $e ? [$e] : []
          ];
          return Re($t)(He);
        }
      }
      function Re(Fe) {
        return Ne = Fe, je = 0, Fe.length === 0 ? Se : N(Fe[je]);
      }
      function N(Fe) {
        return Ke;
        function Ke(He) {
          return S = Z(), et = Fe, Fe.partial || (u.currentConstruct = Fe), Fe.name && u.parser.constructs.disable.null.includes(Fe.name) ? st() : Fe.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            ae ? Object.assign(Object.create(u), ae) : u,
            c,
            tt,
            st
          )(He);
        }
      }
      function tt(Fe) {
        return re(et, S), fe;
      }
      function st(Fe) {
        return S.restore(), ++je < Ne.length ? N(Ne[je]) : Se;
      }
    }
  }
  function te(re, ae) {
    re.resolveAll && !s.includes(re) && s.push(re), re.resolve && Bt(
      u.events,
      ae,
      u.events.length - ae,
      re.resolve(u.events.slice(ae), u)
    ), re.resolveTo && (u.events = re.resolveTo(u.events, u));
  }
  function Z() {
    const re = w(), ae = u.previous, ue = u.currentConstruct, de = u.events.length, fe = Array.from(o);
    return {
      restore: Se,
      from: de
    };
    function Se() {
      r = re, u.previous = ae, u.currentConstruct = ue, u.events.length = de, o = fe, P();
    }
  }
  function P() {
    r.line in n && r.column < 2 && (r.column = n[r.line], r.offset += n[r.line] - 1);
  }
}
function om(e, t) {
  const a = t.start._index, r = t.start._bufferIndex, n = t.end._index, s = t.end._bufferIndex;
  let i;
  if (a === n)
    i = [e[a].slice(r, s)];
  else {
    if (i = e.slice(a, n), r > -1) {
      const o = i[0];
      typeof o == "string" ? i[0] = o.slice(r) : i.shift();
    }
    s > 0 && i.push(e[n].slice(0, s));
  }
  return i;
}
function cm(e, t) {
  let a = -1;
  const r = [];
  let n;
  for (; ++a < e.length; ) {
    const s = e[a];
    let i;
    if (typeof s == "string")
      i = s;
    else
      switch (s) {
        case -5: {
          i = "\r";
          break;
        }
        case -4: {
          i = `
`;
          break;
        }
        case -3: {
          i = `\r
`;
          break;
        }
        case -2: {
          i = t ? " " : "	";
          break;
        }
        case -1: {
          if (!t && n) continue;
          i = " ";
          break;
        }
        default:
          i = String.fromCharCode(s);
      }
    n = s === -2, r.push(i);
  }
  return r.join("");
}
const lm = {
  42: wt,
  43: wt,
  45: wt,
  48: wt,
  49: wt,
  50: wt,
  51: wt,
  52: wt,
  53: wt,
  54: wt,
  55: wt,
  56: wt,
  57: wt,
  62: Ml
}, um = {
  91: fd
}, fm = {
  [-2]: ps,
  [-1]: ps,
  32: ps
}, hm = {
  35: yd,
  42: En,
  45: [Ro, En],
  60: wd,
  61: Ro,
  95: En,
  96: No,
  126: No
}, dm = {
  38: Pl,
  92: Bl
}, mm = {
  [-5]: gs,
  [-4]: gs,
  [-3]: gs,
  33: Pd,
  38: Pl,
  42: Xs,
  60: [Uh, Cd],
  91: Ud,
  92: [pd, Bl],
  93: xi,
  95: Xs,
  96: ed
}, pm = {
  null: [Xs, am]
}, gm = {
  null: [42, 95]
}, ym = {
  null: []
}, _m = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: gm,
  contentInitial: um,
  disable: ym,
  document: lm,
  flow: hm,
  flowInitial: fm,
  insideSpan: pm,
  string: dm,
  text: mm
}, Symbol.toStringTag, { value: "Module" }));
function bm(e) {
  const a = (
    /** @type {FullNormalizedExtension} */
    Ol([_m, ...(e || {}).extensions || []])
  ), r = {
    defined: [],
    lazy: {},
    constructs: a,
    content: n(Fh),
    document: n(Lh),
    flow: n(em),
    string: n(rm),
    text: n(nm)
  };
  return r;
  function n(s) {
    return i;
    function i(o) {
      return im(r, s, o);
    }
  }
}
function km(e) {
  for (; !Hl(e); )
    ;
  return e;
}
const Fo = /[\0\t\n\r]/g;
function wm() {
  let e = 1, t = "", a = !0, r;
  return n;
  function n(s, i, o) {
    const c = [];
    let u, d, m, h, y;
    for (s = t + (typeof s == "string" ? s.toString() : new TextDecoder(i || void 0).decode(s)), m = 0, t = "", a && (s.charCodeAt(0) === 65279 && m++, a = void 0); m < s.length; ) {
      if (Fo.lastIndex = m, u = Fo.exec(s), h = u && u.index !== void 0 ? u.index : s.length, y = s.charCodeAt(h), !u) {
        t = s.slice(m);
        break;
      }
      if (y === 10 && m === h && r)
        c.push(-3), r = void 0;
      else
        switch (r && (c.push(-5), r = void 0), m < h && (c.push(s.slice(m, h)), e += h - m), y) {
          case 0: {
            c.push(65533), e++;
            break;
          }
          case 9: {
            for (d = Math.ceil(e / 4) * 4, c.push(-2); e++ < d; ) c.push(-1);
            break;
          }
          case 10: {
            c.push(-4), e = 1;
            break;
          }
          default:
            r = !0, e = 1;
        }
      m = h + 1;
    }
    return o && (r && c.push(-5), t && c.push(t), c.push(null)), c;
  }
}
const Em = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function Tm(e) {
  return e.replace(Em, vm);
}
function vm(e, t, a) {
  if (t)
    return t;
  if (a.charCodeAt(0) === 35) {
    const n = a.charCodeAt(1), s = n === 120 || n === 88;
    return Ll(a.slice(s ? 2 : 1), s ? 16 : 10);
  }
  return vi(a) || e;
}
const Gl = {}.hasOwnProperty;
function xm(e, t, a) {
  return typeof t != "string" && (a = t, t = void 0), Am(a)(km(bm(a).document().write(wm()(e, t, !0))));
}
function Am(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: s(lt),
      autolinkProtocol: Z,
      autolinkEmail: Z,
      atxHeading: s(mt),
      blockQuote: s($e),
      characterEscape: Z,
      characterReference: Z,
      codeFenced: s($t),
      codeFencedFenceInfo: i,
      codeFencedFenceMeta: i,
      codeIndented: s($t, i),
      codeText: s(ia, i),
      codeTextData: Z,
      data: Z,
      codeFlowValue: Z,
      definition: s(Fa),
      definitionDestinationString: i,
      definitionLabelString: i,
      definitionTitleString: i,
      emphasis: s(oa),
      hardBreakEscape: s(ct),
      hardBreakTrailing: s(ct),
      htmlFlow: s(Rt, i),
      htmlFlowData: Z,
      htmlText: s(Rt, i),
      htmlTextData: Z,
      image: s(Ft),
      label: i,
      link: s(lt),
      listItem: s(pr),
      listItemValue: h,
      listOrdered: s(Qa, m),
      listUnordered: s(Qa),
      paragraph: s(ca),
      reference: N,
      referenceString: i,
      resourceDestinationString: i,
      resourceTitleString: i,
      setextHeading: s(mt),
      strong: s(gr),
      thematicBreak: s(Oa)
    },
    exit: {
      atxHeading: c(),
      atxHeadingSequence: O,
      autolink: c(),
      autolinkEmail: at,
      autolinkProtocol: He,
      blockQuote: c(),
      characterEscapeValue: P,
      characterReferenceMarkerHexadecimal: st,
      characterReferenceMarkerNumeric: st,
      characterReferenceValue: Fe,
      characterReference: Ke,
      codeFenced: c(F),
      codeFencedFence: v,
      codeFencedFenceInfo: y,
      codeFencedFenceMeta: w,
      codeFlowValue: P,
      codeIndented: c(z),
      codeText: c(fe),
      codeTextData: P,
      data: P,
      definition: c(),
      definitionDestinationString: $,
      definitionLabelString: C,
      definitionTitleString: U,
      emphasis: c(),
      hardBreakEscape: c(ae),
      hardBreakTrailing: c(ae),
      htmlFlow: c(ue),
      htmlFlowData: P,
      htmlText: c(de),
      htmlTextData: P,
      image: c(Ne),
      label: et,
      labelText: je,
      lineEnding: re,
      link: c(Se),
      listItem: c(),
      listOrdered: c(),
      listUnordered: c(),
      paragraph: c(),
      referenceString: tt,
      resourceDestinationString: S,
      resourceTitleString: Me,
      resource: Re,
      setextHeading: c(te),
      setextHeadingLineSequence: M,
      setextHeadingText: p,
      strong: c(),
      thematicBreak: c()
    }
  };
  Wl(t, (e || {}).mdastExtensions || []);
  const a = {};
  return r;
  function r(q) {
    let K = {
      type: "root",
      children: []
    };
    const _e = {
      stack: [K],
      tokenStack: [],
      config: t,
      enter: o,
      exit: u,
      buffer: i,
      resume: d,
      data: a
    }, we = [];
    let De = -1;
    for (; ++De < q.length; )
      if (q[De][1].type === "listOrdered" || q[De][1].type === "listUnordered")
        if (q[De][0] === "enter")
          we.push(De);
        else {
          const rt = we.pop();
          De = n(q, rt, De);
        }
    for (De = -1; ++De < q.length; ) {
      const rt = t[q[De][0]];
      Gl.call(rt, q[De][1].type) && rt[q[De][1].type].call(Object.assign({
        sliceSerialize: q[De][2].sliceSerialize
      }, _e), q[De][1]);
    }
    if (_e.tokenStack.length > 0) {
      const rt = _e.tokenStack[_e.tokenStack.length - 1];
      (rt[1] || Oo).call(_e, void 0, rt[0]);
    }
    for (K.position = {
      start: ka(q.length > 0 ? q[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: ka(q.length > 0 ? q[q.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, De = -1; ++De < t.transforms.length; )
      K = t.transforms[De](K) || K;
    return K;
  }
  function n(q, K, _e) {
    let we = K - 1, De = -1, rt = !1, qt, vt, la, ua;
    for (; ++we <= _e; ) {
      const ut = q[we];
      switch (ut[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          ut[0] === "enter" ? De++ : De--, ua = void 0;
          break;
        }
        case "lineEndingBlank": {
          ut[0] === "enter" && (qt && !ua && !De && !la && (la = we), ua = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          ua = void 0;
      }
      if (!De && ut[0] === "enter" && ut[1].type === "listItemPrefix" || De === -1 && ut[0] === "exit" && (ut[1].type === "listUnordered" || ut[1].type === "listOrdered")) {
        if (qt) {
          let Xt = we;
          for (vt = void 0; Xt--; ) {
            const xt = q[Xt];
            if (xt[1].type === "lineEnding" || xt[1].type === "lineEndingBlank") {
              if (xt[0] === "exit") continue;
              vt && (q[vt][1].type = "lineEndingBlank", rt = !0), xt[1].type = "lineEnding", vt = Xt;
            } else if (!(xt[1].type === "linePrefix" || xt[1].type === "blockQuotePrefix" || xt[1].type === "blockQuotePrefixWhitespace" || xt[1].type === "blockQuoteMarker" || xt[1].type === "listItemIndent")) break;
          }
          la && (!vt || la < vt) && (qt._spread = !0), qt.end = Object.assign({}, vt ? q[vt][1].start : ut[1].end), q.splice(vt || we, 0, ["exit", qt, ut[2]]), we++, _e++;
        }
        if (ut[1].type === "listItemPrefix") {
          const Xt = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, ut[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          qt = Xt, q.splice(we, 0, ["enter", Xt, ut[2]]), we++, _e++, la = void 0, ua = !0;
        }
      }
    }
    return q[K][1]._spread = rt, _e;
  }
  function s(q, K) {
    return _e;
    function _e(we) {
      o.call(this, q(we), we), K && K.call(this, we);
    }
  }
  function i() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function o(q, K, _e) {
    this.stack[this.stack.length - 1].children.push(q), this.stack.push(q), this.tokenStack.push([K, _e]), q.position = {
      start: ka(K.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function c(q) {
    return K;
    function K(_e) {
      q && q.call(this, _e), u.call(this, _e);
    }
  }
  function u(q, K) {
    const _e = this.stack.pop(), we = this.tokenStack.pop();
    if (we)
      we[0].type !== q.type && (K ? K.call(this, q, we[0]) : (we[1] || Oo).call(this, q, we[0]));
    else throw new Error("Cannot close `" + q.type + "` (" + Or({
      start: q.start,
      end: q.end
    }) + "): its not open");
    _e.position.end = ka(q.end);
  }
  function d() {
    return jn(this.stack.pop());
  }
  function m() {
    this.data.expectingFirstListItemValue = !0;
  }
  function h(q) {
    if (this.data.expectingFirstListItemValue) {
      const K = this.stack[this.stack.length - 2];
      K.start = Number.parseInt(this.sliceSerialize(q), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function y() {
    const q = this.resume(), K = this.stack[this.stack.length - 1];
    K.lang = q;
  }
  function w() {
    const q = this.resume(), K = this.stack[this.stack.length - 1];
    K.meta = q;
  }
  function v() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function F() {
    const q = this.resume(), K = this.stack[this.stack.length - 1];
    K.value = q.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function z() {
    const q = this.resume(), K = this.stack[this.stack.length - 1];
    K.value = q.replace(/(\r?\n|\r)$/g, "");
  }
  function C(q) {
    const K = this.resume(), _e = this.stack[this.stack.length - 1];
    _e.label = K, _e.identifier = Gt(this.sliceSerialize(q)).toLowerCase();
  }
  function U() {
    const q = this.resume(), K = this.stack[this.stack.length - 1];
    K.title = q;
  }
  function $() {
    const q = this.resume(), K = this.stack[this.stack.length - 1];
    K.url = q;
  }
  function O(q) {
    const K = this.stack[this.stack.length - 1];
    if (!K.depth) {
      const _e = this.sliceSerialize(q).length;
      K.depth = _e;
    }
  }
  function p() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function M(q) {
    const K = this.stack[this.stack.length - 1];
    K.depth = this.sliceSerialize(q).codePointAt(0) === 61 ? 1 : 2;
  }
  function te() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function Z(q) {
    const _e = this.stack[this.stack.length - 1].children;
    let we = _e[_e.length - 1];
    (!we || we.type !== "text") && (we = yr(), we.position = {
      start: ka(q.start),
      // @ts-expect-error: well add `end` later.
      end: void 0
    }, _e.push(we)), this.stack.push(we);
  }
  function P(q) {
    const K = this.stack.pop();
    K.value += this.sliceSerialize(q), K.position.end = ka(q.end);
  }
  function re(q) {
    const K = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const _e = K.children[K.children.length - 1];
      _e.position.end = ka(q.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(K.type) && (Z.call(this, q), P.call(this, q));
  }
  function ae() {
    this.data.atHardBreak = !0;
  }
  function ue() {
    const q = this.resume(), K = this.stack[this.stack.length - 1];
    K.value = q;
  }
  function de() {
    const q = this.resume(), K = this.stack[this.stack.length - 1];
    K.value = q;
  }
  function fe() {
    const q = this.resume(), K = this.stack[this.stack.length - 1];
    K.value = q;
  }
  function Se() {
    const q = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const K = this.data.referenceType || "shortcut";
      q.type += "Reference", q.referenceType = K, delete q.url, delete q.title;
    } else
      delete q.identifier, delete q.label;
    this.data.referenceType = void 0;
  }
  function Ne() {
    const q = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const K = this.data.referenceType || "shortcut";
      q.type += "Reference", q.referenceType = K, delete q.url, delete q.title;
    } else
      delete q.identifier, delete q.label;
    this.data.referenceType = void 0;
  }
  function je(q) {
    const K = this.sliceSerialize(q), _e = this.stack[this.stack.length - 2];
    _e.label = Tm(K), _e.identifier = Gt(K).toLowerCase();
  }
  function et() {
    const q = this.stack[this.stack.length - 1], K = this.resume(), _e = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, _e.type === "link") {
      const we = q.children;
      _e.children = we;
    } else
      _e.alt = K;
  }
  function S() {
    const q = this.resume(), K = this.stack[this.stack.length - 1];
    K.url = q;
  }
  function Me() {
    const q = this.resume(), K = this.stack[this.stack.length - 1];
    K.title = q;
  }
  function Re() {
    this.data.inReference = void 0;
  }
  function N() {
    this.data.referenceType = "collapsed";
  }
  function tt(q) {
    const K = this.resume(), _e = this.stack[this.stack.length - 1];
    _e.label = K, _e.identifier = Gt(this.sliceSerialize(q)).toLowerCase(), this.data.referenceType = "full";
  }
  function st(q) {
    this.data.characterReferenceType = q.type;
  }
  function Fe(q) {
    const K = this.sliceSerialize(q), _e = this.data.characterReferenceType;
    let we;
    _e ? (we = Ll(K, _e === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : we = vi(K);
    const De = this.stack[this.stack.length - 1];
    De.value += we;
  }
  function Ke(q) {
    const K = this.stack.pop();
    K.position.end = ka(q.end);
  }
  function He(q) {
    P.call(this, q);
    const K = this.stack[this.stack.length - 1];
    K.url = this.sliceSerialize(q);
  }
  function at(q) {
    P.call(this, q);
    const K = this.stack[this.stack.length - 1];
    K.url = "mailto:" + this.sliceSerialize(q);
  }
  function $e() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function $t() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function ia() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function Fa() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function oa() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function mt() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function ct() {
    return {
      type: "break"
    };
  }
  function Rt() {
    return {
      type: "html",
      value: ""
    };
  }
  function Ft() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function lt() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function Qa(q) {
    return {
      type: "list",
      ordered: q.type === "listOrdered",
      start: null,
      spread: q._spread,
      children: []
    };
  }
  function pr(q) {
    return {
      type: "listItem",
      spread: q._spread,
      checked: null,
      children: []
    };
  }
  function ca() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function gr() {
    return {
      type: "strong",
      children: []
    };
  }
  function yr() {
    return {
      type: "text",
      value: ""
    };
  }
  function Oa() {
    return {
      type: "thematicBreak"
    };
  }
}
function ka(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function Wl(e, t) {
  let a = -1;
  for (; ++a < t.length; ) {
    const r = t[a];
    Array.isArray(r) ? Wl(e, r) : Dm(e, r);
  }
}
function Dm(e, t) {
  let a;
  for (a in t)
    if (Gl.call(t, a))
      switch (a) {
        case "canContainEols": {
          const r = t[a];
          r && e[a].push(...r);
          break;
        }
        case "transforms": {
          const r = t[a];
          r && e[a].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = t[a];
          r && Object.assign(e[a], r);
          break;
        }
      }
}
function Oo(e, t) {
  throw e ? new Error("Cannot close `" + e.type + "` (" + Or({
    start: e.start,
    end: e.end
  }) + "): a different token (`" + t.type + "`, " + Or({
    start: t.start,
    end: t.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + Or({
    start: t.start,
    end: t.end
  }) + ") is still open");
}
function Cm(e) {
  const t = this;
  t.parser = a;
  function a(r) {
    return xm(r, {
      ...t.data("settings"),
      ...e,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
}
function Sm(e, t) {
  const a = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function zm(e, t) {
  const a = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, a), [e.applyData(t, a), { type: "text", value: `
` }];
}
function Nm(e, t) {
  const a = t.value ? t.value + `
` : "", r = {};
  t.lang && (r.className = ["language-" + t.lang]);
  let n = {
    type: "element",
    tagName: "code",
    properties: r,
    children: [{ type: "text", value: a }]
  };
  return t.meta && (n.data = { meta: t.meta }), e.patch(t, n), n = e.applyData(t, n), n = { type: "element", tagName: "pre", properties: {}, children: [n] }, e.patch(t, n), n;
}
function Im(e, t) {
  const a = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function Rm(e, t) {
  const a = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function Fm(e, t) {
  const a = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), n = or(r.toLowerCase()), s = e.footnoteOrder.indexOf(r);
  let i, o = e.footnoteCounts.get(r);
  o === void 0 ? (o = 0, e.footnoteOrder.push(r), i = e.footnoteOrder.length) : i = s + 1, o += 1, e.footnoteCounts.set(r, o);
  const c = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + a + "fn-" + n,
      id: a + "fnref-" + n + (o > 1 ? "-" + o : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(i) }]
  };
  e.patch(t, c);
  const u = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [c]
  };
  return e.patch(t, u), e.applyData(t, u);
}
function Om(e, t) {
  const a = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function Lm(e, t) {
  if (e.options.allowDangerousHtml) {
    const a = { type: "raw", value: t.value };
    return e.patch(t, a), e.applyData(t, a);
  }
}
function $l(e, t) {
  const a = t.referenceType;
  let r = "]";
  if (a === "collapsed" ? r += "[]" : a === "full" && (r += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{ type: "text", value: "![" + t.alt + r }];
  const n = e.all(t), s = n[0];
  s && s.type === "text" ? s.value = "[" + s.value : n.unshift({ type: "text", value: "[" });
  const i = n[n.length - 1];
  return i && i.type === "text" ? i.value += r : n.push({ type: "text", value: r }), n;
}
function Mm(e, t) {
  const a = String(t.identifier).toUpperCase(), r = e.definitionById.get(a);
  if (!r)
    return $l(e, t);
  const n = { src: or(r.url || ""), alt: t.alt };
  r.title !== null && r.title !== void 0 && (n.title = r.title);
  const s = { type: "element", tagName: "img", properties: n, children: [] };
  return e.patch(t, s), e.applyData(t, s);
}
function Bm(e, t) {
  const a = { src: or(t.url) };
  t.alt !== null && t.alt !== void 0 && (a.alt = t.alt), t.title !== null && t.title !== void 0 && (a.title = t.title);
  const r = { type: "element", tagName: "img", properties: a, children: [] };
  return e.patch(t, r), e.applyData(t, r);
}
function Pm(e, t) {
  const a = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, a);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [a]
  };
  return e.patch(t, r), e.applyData(t, r);
}
function Hm(e, t) {
  const a = String(t.identifier).toUpperCase(), r = e.definitionById.get(a);
  if (!r)
    return $l(e, t);
  const n = { href: or(r.url || "") };
  r.title !== null && r.title !== void 0 && (n.title = r.title);
  const s = {
    type: "element",
    tagName: "a",
    properties: n,
    children: e.all(t)
  };
  return e.patch(t, s), e.applyData(t, s);
}
function Um(e, t) {
  const a = { href: or(t.url) };
  t.title !== null && t.title !== void 0 && (a.title = t.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: a,
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function jm(e, t, a) {
  const r = e.all(t), n = a ? qm(a) : Xl(t), s = {}, i = [];
  if (typeof t.checked == "boolean") {
    const d = r[0];
    let m;
    d && d.type === "element" && d.tagName === "p" ? m = d : (m = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(m)), m.children.length > 0 && m.children.unshift({ type: "text", value: " " }), m.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), s.className = ["task-list-item"];
  }
  let o = -1;
  for (; ++o < r.length; ) {
    const d = r[o];
    (n || o !== 0 || d.type !== "element" || d.tagName !== "p") && i.push({ type: "text", value: `
` }), d.type === "element" && d.tagName === "p" && !n ? i.push(...d.children) : i.push(d);
  }
  const c = r[r.length - 1];
  c && (n || c.type !== "element" || c.tagName !== "p") && i.push({ type: "text", value: `
` });
  const u = { type: "element", tagName: "li", properties: s, children: i };
  return e.patch(t, u), e.applyData(t, u);
}
function qm(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const a = e.children;
    let r = -1;
    for (; !t && ++r < a.length; )
      t = Xl(a[r]);
  }
  return t;
}
function Xl(e) {
  const t = e.spread;
  return t ?? e.children.length > 1;
}
function Ym(e, t) {
  const a = {}, r = e.all(t);
  let n = -1;
  for (typeof t.start == "number" && t.start !== 1 && (a.start = t.start); ++n < r.length; ) {
    const i = r[n];
    if (i.type === "element" && i.tagName === "li" && i.properties && Array.isArray(i.properties.className) && i.properties.className.includes("task-list-item")) {
      a.className = ["contains-task-list"];
      break;
    }
  }
  const s = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: a,
    children: e.wrap(r, !0)
  };
  return e.patch(t, s), e.applyData(t, s);
}
function Vm(e, t) {
  const a = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function Gm(e, t) {
  const a = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, a), e.applyData(t, a);
}
function Wm(e, t) {
  const a = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function $m(e, t) {
  const a = e.all(t), r = a.shift(), n = [];
  if (r) {
    const i = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([r], !0)
    };
    e.patch(t.children[0], i), n.push(i);
  }
  if (a.length > 0) {
    const i = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(a, !0)
    }, o = ta(t.children[1]), c = Un(t.children[t.children.length - 1]);
    o && c && (i.position = { start: o, end: c }), n.push(i);
  }
  const s = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(n, !0)
  };
  return e.patch(t, s), e.applyData(t, s);
}
function Xm(e, t, a) {
  const r = a ? a.children : void 0, s = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td", i = a && a.type === "table" ? a.align : void 0, o = i ? i.length : t.children.length;
  let c = -1;
  const u = [];
  for (; ++c < o; ) {
    const m = t.children[c], h = {}, y = i ? i[c] : void 0;
    y && (h.align = y);
    let w = { type: "element", tagName: s, properties: h, children: [] };
    m && (w.children = e.all(m), e.patch(m, w), w = e.applyData(m, w)), u.push(w);
  }
  const d = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(u, !0)
  };
  return e.patch(t, d), e.applyData(t, d);
}
function Qm(e, t) {
  const a = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, a), e.applyData(t, a);
}
const Lo = 9, Mo = 32;
function Km(e) {
  const t = String(e), a = /\r?\n|\r/g;
  let r = a.exec(t), n = 0;
  const s = [];
  for (; r; )
    s.push(
      Bo(t.slice(n, r.index), n > 0, !0),
      r[0]
    ), n = r.index + r[0].length, r = a.exec(t);
  return s.push(Bo(t.slice(n), n > 0, !1)), s.join("");
}
function Bo(e, t, a) {
  let r = 0, n = e.length;
  if (t) {
    let s = e.codePointAt(r);
    for (; s === Lo || s === Mo; )
      r++, s = e.codePointAt(r);
  }
  if (a) {
    let s = e.codePointAt(n - 1);
    for (; s === Lo || s === Mo; )
      n--, s = e.codePointAt(n - 1);
  }
  return n > r ? e.slice(r, n) : "";
}
function Jm(e, t) {
  const a = { type: "text", value: Km(String(t.value)) };
  return e.patch(t, a), e.applyData(t, a);
}
function Zm(e, t) {
  const a = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, a), e.applyData(t, a);
}
const ep = {
  blockquote: Sm,
  break: zm,
  code: Nm,
  delete: Im,
  emphasis: Rm,
  footnoteReference: Fm,
  heading: Om,
  html: Lm,
  imageReference: Mm,
  image: Bm,
  inlineCode: Pm,
  linkReference: Hm,
  link: Um,
  listItem: jm,
  list: Ym,
  paragraph: Vm,
  // @ts-expect-error: root is different, but hard to type.
  root: Gm,
  strong: Wm,
  table: $m,
  tableCell: Qm,
  tableRow: Xm,
  text: Jm,
  thematicBreak: Zm,
  toml: sn,
  yaml: sn,
  definition: sn,
  footnoteDefinition: sn
};
function sn() {
}
const Ql = -1, Vn = 0, zn = 1, Nn = 2, Ai = 3, Di = 4, Ci = 5, Si = 6, Kl = 7, Jl = 8, Po = typeof self == "object" ? self : globalThis, tp = (e, t) => {
  const a = (n, s) => (e.set(s, n), n), r = (n) => {
    if (e.has(n))
      return e.get(n);
    const [s, i] = t[n];
    switch (s) {
      case Vn:
      case Ql:
        return a(i, n);
      case zn: {
        const o = a([], n);
        for (const c of i)
          o.push(r(c));
        return o;
      }
      case Nn: {
        const o = a({}, n);
        for (const [c, u] of i)
          o[r(c)] = r(u);
        return o;
      }
      case Ai:
        return a(new Date(i), n);
      case Di: {
        const { source: o, flags: c } = i;
        return a(new RegExp(o, c), n);
      }
      case Ci: {
        const o = a(/* @__PURE__ */ new Map(), n);
        for (const [c, u] of i)
          o.set(r(c), r(u));
        return o;
      }
      case Si: {
        const o = a(/* @__PURE__ */ new Set(), n);
        for (const c of i)
          o.add(r(c));
        return o;
      }
      case Kl: {
        const { name: o, message: c } = i;
        return a(new Po[o](c), n);
      }
      case Jl:
        return a(BigInt(i), n);
      case "BigInt":
        return a(Object(BigInt(i)), n);
    }
    return a(new Po[s](i), n);
  };
  return r;
}, Ho = (e) => tp(/* @__PURE__ */ new Map(), e)(0), Ka = "", { toString: ap } = {}, { keys: rp } = Object, Cr = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [Vn, t];
  const a = ap.call(e).slice(8, -1);
  switch (a) {
    case "Array":
      return [zn, Ka];
    case "Object":
      return [Nn, Ka];
    case "Date":
      return [Ai, Ka];
    case "RegExp":
      return [Di, Ka];
    case "Map":
      return [Ci, Ka];
    case "Set":
      return [Si, Ka];
  }
  return a.includes("Array") ? [zn, a] : a.includes("Error") ? [Kl, a] : [Nn, a];
}, on = ([e, t]) => e === Vn && (t === "function" || t === "symbol"), np = (e, t, a, r) => {
  const n = (i, o) => {
    const c = r.push(i) - 1;
    return a.set(o, c), c;
  }, s = (i) => {
    if (a.has(i))
      return a.get(i);
    let [o, c] = Cr(i);
    switch (o) {
      case Vn: {
        let d = i;
        switch (c) {
          case "bigint":
            o = Jl, d = i.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + c);
            d = null;
            break;
          case "undefined":
            return n([Ql], i);
        }
        return n([o, d], i);
      }
      case zn: {
        if (c)
          return n([c, [...i]], i);
        const d = [], m = n([o, d], i);
        for (const h of i)
          d.push(s(h));
        return m;
      }
      case Nn: {
        if (c)
          switch (c) {
            case "BigInt":
              return n([c, i.toString()], i);
            case "Boolean":
            case "Number":
            case "String":
              return n([c, i.valueOf()], i);
          }
        if (t && "toJSON" in i)
          return s(i.toJSON());
        const d = [], m = n([o, d], i);
        for (const h of rp(i))
          (e || !on(Cr(i[h]))) && d.push([s(h), s(i[h])]);
        return m;
      }
      case Ai:
        return n([o, i.toISOString()], i);
      case Di: {
        const { source: d, flags: m } = i;
        return n([o, { source: d, flags: m }], i);
      }
      case Ci: {
        const d = [], m = n([o, d], i);
        for (const [h, y] of i)
          (e || !(on(Cr(h)) || on(Cr(y)))) && d.push([s(h), s(y)]);
        return m;
      }
      case Si: {
        const d = [], m = n([o, d], i);
        for (const h of i)
          (e || !on(Cr(h))) && d.push(s(h));
        return m;
      }
    }
    const { message: u } = i;
    return n([o, { name: c, message: u }], i);
  };
  return s;
}, Uo = (e, { json: t, lossy: a } = {}) => {
  const r = [];
  return np(!(t || a), !!t, /* @__PURE__ */ new Map(), r)(e), r;
}, Da = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e, t) => t && ("json" in t || "lossy" in t) ? Ho(Uo(e, t)) : structuredClone(e)
) : (e, t) => Ho(Uo(e, t));
function sp(e, t) {
  const a = [{ type: "text", value: "" }];
  return t > 1 && a.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t) }]
  }), a;
}
function ip(e, t) {
  return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
}
function op(e) {
  const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", a = e.options.footnoteBackContent || sp, r = e.options.footnoteBackLabel || ip, n = e.options.footnoteLabel || "Footnotes", s = e.options.footnoteLabelTagName || "h2", i = e.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, o = [];
  let c = -1;
  for (; ++c < e.footnoteOrder.length; ) {
    const u = e.footnoteById.get(
      e.footnoteOrder[c]
    );
    if (!u)
      continue;
    const d = e.all(u), m = String(u.identifier).toUpperCase(), h = or(m.toLowerCase());
    let y = 0;
    const w = [], v = e.footnoteCounts.get(m);
    for (; v !== void 0 && ++y <= v; ) {
      w.length > 0 && w.push({ type: "text", value: " " });
      let C = typeof a == "string" ? a : a(c, y);
      typeof C == "string" && (C = { type: "text", value: C }), w.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + h + (y > 1 ? "-" + y : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof r == "string" ? r : r(c, y),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(C) ? C : [C]
      });
    }
    const F = d[d.length - 1];
    if (F && F.type === "element" && F.tagName === "p") {
      const C = F.children[F.children.length - 1];
      C && C.type === "text" ? C.value += " " : F.children.push({ type: "text", value: " " }), F.children.push(...w);
    } else
      d.push(...w);
    const z = {
      type: "element",
      tagName: "li",
      properties: { id: t + "fn-" + h },
      children: e.wrap(d, !0)
    };
    e.patch(u, z), o.push(z);
  }
  if (o.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: s,
          properties: {
            ...Da(i),
            id: "footnote-label"
          },
          children: [{ type: "text", value: n }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(o, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const cr = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(e) {
    if (e == null)
      return fp;
    if (typeof e == "function")
      return Gn(e);
    if (typeof e == "object")
      return Array.isArray(e) ? cp(e) : lp(e);
    if (typeof e == "string")
      return up(e);
    throw new Error("Expected function, string, or object as test");
  }
);
function cp(e) {
  const t = [];
  let a = -1;
  for (; ++a < e.length; )
    t[a] = cr(e[a]);
  return Gn(r);
  function r(...n) {
    let s = -1;
    for (; ++s < t.length; )
      if (t[s].apply(this, n)) return !0;
    return !1;
  }
}
function lp(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return Gn(a);
  function a(r) {
    const n = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let s;
    for (s in e)
      if (n[s] !== t[s]) return !1;
    return !0;
  }
}
function up(e) {
  return Gn(t);
  function t(a) {
    return a && a.type === e;
  }
}
function Gn(e) {
  return t;
  function t(a, r, n) {
    return !!(hp(a) && e.call(
      this,
      a,
      typeof r == "number" ? r : void 0,
      n || void 0
    ));
  }
}
function fp() {
  return !0;
}
function hp(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const Zl = [], dp = !0, Qs = !1, eu = "skip";
function zi(e, t, a, r) {
  let n;
  typeof t == "function" && typeof a != "function" ? (r = a, a = t) : n = t;
  const s = cr(n), i = r ? -1 : 1;
  o(e, void 0, [])();
  function o(c, u, d) {
    const m = (
      /** @type {Record<string, unknown>} */
      c && typeof c == "object" ? c : {}
    );
    if (typeof m.type == "string") {
      const y = (
        // `hast`
        typeof m.tagName == "string" ? m.tagName : (
          // `xast`
          typeof m.name == "string" ? m.name : void 0
        )
      );
      Object.defineProperty(h, "name", {
        value: "node (" + (c.type + (y ? "<" + y + ">" : "")) + ")"
      });
    }
    return h;
    function h() {
      let y = Zl, w, v, F;
      if ((!t || s(c, u, d[d.length - 1] || void 0)) && (y = mp(a(c, d)), y[0] === Qs))
        return y;
      if ("children" in c && c.children) {
        const z = (
          /** @type {UnistParent} */
          c
        );
        if (z.children && y[0] !== eu)
          for (v = (r ? z.children.length : -1) + i, F = d.concat(z); v > -1 && v < z.children.length; ) {
            const C = z.children[v];
            if (w = o(C, v, F)(), w[0] === Qs)
              return w;
            v = typeof w[1] == "number" ? w[1] : v + i;
          }
      }
      return y;
    }
  }
}
function mp(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [dp, e] : e == null ? Zl : [e];
}
function lr(e, t, a, r) {
  let n, s, i;
  typeof t == "function" && typeof a != "function" ? (s = void 0, i = t, n = a) : (s = t, i = a, n = r), zi(e, s, o, n);
  function o(c, u) {
    const d = u[u.length - 1], m = d ? d.children.indexOf(c) : void 0;
    return i(c, m, d);
  }
}
const Ks = {}.hasOwnProperty, pp = {};
function gp(e, t) {
  const a = t || pp, r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), i = { ...ep, ...a.handlers }, o = {
    all: u,
    applyData: _p,
    definitionById: r,
    footnoteById: n,
    footnoteCounts: s,
    footnoteOrder: [],
    handlers: i,
    one: c,
    options: a,
    patch: yp,
    wrap: kp
  };
  return lr(e, function(d) {
    if (d.type === "definition" || d.type === "footnoteDefinition") {
      const m = d.type === "definition" ? r : n, h = String(d.identifier).toUpperCase();
      m.has(h) || m.set(h, d);
    }
  }), o;
  function c(d, m) {
    const h = d.type, y = o.handlers[h];
    if (Ks.call(o.handlers, h) && y)
      return y(o, d, m);
    if (o.options.passThrough && o.options.passThrough.includes(h)) {
      if ("children" in d) {
        const { children: v, ...F } = d, z = Da(F);
        return z.children = o.all(d), z;
      }
      return Da(d);
    }
    return (o.options.unknownHandler || bp)(o, d, m);
  }
  function u(d) {
    const m = [];
    if ("children" in d) {
      const h = d.children;
      let y = -1;
      for (; ++y < h.length; ) {
        const w = o.one(h[y], d);
        if (w) {
          if (y && h[y - 1].type === "break" && (!Array.isArray(w) && w.type === "text" && (w.value = jo(w.value)), !Array.isArray(w) && w.type === "element")) {
            const v = w.children[0];
            v && v.type === "text" && (v.value = jo(v.value));
          }
          Array.isArray(w) ? m.push(...w) : m.push(w);
        }
      }
    }
    return m;
  }
}
function yp(e, t) {
  e.position && (t.position = nh(e));
}
function _p(e, t) {
  let a = t;
  if (e && e.data) {
    const r = e.data.hName, n = e.data.hChildren, s = e.data.hProperties;
    if (typeof r == "string")
      if (a.type === "element")
        a.tagName = r;
      else {
        const i = "children" in a ? a.children : [a];
        a = { type: "element", tagName: r, properties: {}, children: i };
      }
    a.type === "element" && s && Object.assign(a.properties, Da(s)), "children" in a && a.children && n !== null && n !== void 0 && (a.children = n);
  }
  return a;
}
function bp(e, t) {
  const a = t.data || {}, r = "value" in t && !(Ks.call(a, "hProperties") || Ks.call(a, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function kp(e, t) {
  const a = [];
  let r = -1;
  for (t && a.push({ type: "text", value: `
` }); ++r < e.length; )
    r && a.push({ type: "text", value: `
` }), a.push(e[r]);
  return t && e.length > 0 && a.push({ type: "text", value: `
` }), a;
}
function jo(e) {
  let t = 0, a = e.charCodeAt(t);
  for (; a === 9 || a === 32; )
    t++, a = e.charCodeAt(t);
  return e.slice(t);
}
function qo(e, t) {
  const a = gp(e, t), r = a.one(e, void 0), n = op(a), s = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] };
  return n && s.children.push({ type: "text", value: `
` }, n), s;
}
function wp(e, t) {
  return e && "run" in e ? async function(a, r) {
    const n = (
      /** @type {HastRoot} */
      qo(a, { file: r, ...t })
    );
    await e.run(n, r);
  } : function(a, r) {
    return (
      /** @type {HastRoot} */
      qo(a, { file: r, ...e || t })
    );
  };
}
function Yo(e) {
  if (e)
    throw e;
}
var Tn = Object.prototype.hasOwnProperty, tu = Object.prototype.toString, Vo = Object.defineProperty, Go = Object.getOwnPropertyDescriptor, Wo = function(t) {
  return typeof Array.isArray == "function" ? Array.isArray(t) : tu.call(t) === "[object Array]";
}, $o = function(t) {
  if (!t || tu.call(t) !== "[object Object]")
    return !1;
  var a = Tn.call(t, "constructor"), r = t.constructor && t.constructor.prototype && Tn.call(t.constructor.prototype, "isPrototypeOf");
  if (t.constructor && !a && !r)
    return !1;
  var n;
  for (n in t)
    ;
  return typeof n > "u" || Tn.call(t, n);
}, Xo = function(t, a) {
  Vo && a.name === "__proto__" ? Vo(t, a.name, {
    enumerable: !0,
    configurable: !0,
    value: a.newValue,
    writable: !0
  }) : t[a.name] = a.newValue;
}, Qo = function(t, a) {
  if (a === "__proto__")
    if (Tn.call(t, a)) {
      if (Go)
        return Go(t, a).value;
    } else return;
  return t[a];
}, Ep = function e() {
  var t, a, r, n, s, i, o = arguments[0], c = 1, u = arguments.length, d = !1;
  for (typeof o == "boolean" && (d = o, o = arguments[1] || {}, c = 2), (o == null || typeof o != "object" && typeof o != "function") && (o = {}); c < u; ++c)
    if (t = arguments[c], t != null)
      for (a in t)
        r = Qo(o, a), n = Qo(t, a), o !== n && (d && n && ($o(n) || (s = Wo(n))) ? (s ? (s = !1, i = r && Wo(r) ? r : []) : i = r && $o(r) ? r : {}, Xo(o, { name: a, newValue: e(d, i, n) })) : typeof n < "u" && Xo(o, { name: a, newValue: n }));
  return o;
};
const ys = /* @__PURE__ */ bi(Ep);
function Js(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function Tp() {
  const e = [], t = { run: a, use: r };
  return t;
  function a(...n) {
    let s = -1;
    const i = n.pop();
    if (typeof i != "function")
      throw new TypeError("Expected function as last argument, not " + i);
    o(null, ...n);
    function o(c, ...u) {
      const d = e[++s];
      let m = -1;
      if (c) {
        i(c);
        return;
      }
      for (; ++m < n.length; )
        (u[m] === null || u[m] === void 0) && (u[m] = n[m]);
      n = u, d ? vp(d, o)(...u) : i(null, ...u);
    }
  }
  function r(n) {
    if (typeof n != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + n
      );
    return e.push(n), t;
  }
}
function vp(e, t) {
  let a;
  return r;
  function r(...i) {
    const o = e.length > i.length;
    let c;
    o && i.push(n);
    try {
      c = e.apply(this, i);
    } catch (u) {
      const d = (
        /** @type {Error} */
        u
      );
      if (o && a)
        throw d;
      return n(d);
    }
    o || (c && c.then && typeof c.then == "function" ? c.then(s, n) : c instanceof Error ? n(c) : s(c));
  }
  function n(i, ...o) {
    a || (a = !0, t(i, ...o));
  }
  function s(i) {
    n(null, i);
  }
}
const Qt = { basename: xp, dirname: Ap, extname: Dp, join: Cp, sep: "/" };
function xp(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  Zr(e);
  let a = 0, r = -1, n = e.length, s;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; n--; )
      if (e.codePointAt(n) === 47) {
        if (s) {
          a = n + 1;
          break;
        }
      } else r < 0 && (s = !0, r = n + 1);
    return r < 0 ? "" : e.slice(a, r);
  }
  if (t === e)
    return "";
  let i = -1, o = t.length - 1;
  for (; n--; )
    if (e.codePointAt(n) === 47) {
      if (s) {
        a = n + 1;
        break;
      }
    } else
      i < 0 && (s = !0, i = n + 1), o > -1 && (e.codePointAt(n) === t.codePointAt(o--) ? o < 0 && (r = n) : (o = -1, r = i));
  return a === r ? r = i : r < 0 && (r = e.length), e.slice(a, r);
}
function Ap(e) {
  if (Zr(e), e.length === 0)
    return ".";
  let t = -1, a = e.length, r;
  for (; --a; )
    if (e.codePointAt(a) === 47) {
      if (r) {
        t = a;
        break;
      }
    } else r || (r = !0);
  return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
}
function Dp(e) {
  Zr(e);
  let t = e.length, a = -1, r = 0, n = -1, s = 0, i;
  for (; t--; ) {
    const o = e.codePointAt(t);
    if (o === 47) {
      if (i) {
        r = t + 1;
        break;
      }
      continue;
    }
    a < 0 && (i = !0, a = t + 1), o === 46 ? n < 0 ? n = t : s !== 1 && (s = 1) : n > -1 && (s = -1);
  }
  return n < 0 || a < 0 || // We saw a non-dot character immediately before the dot.
  s === 0 || // The (right-most) trimmed path component is exactly `..`.
  s === 1 && n === a - 1 && n === r + 1 ? "" : e.slice(n, a);
}
function Cp(...e) {
  let t = -1, a;
  for (; ++t < e.length; )
    Zr(e[t]), e[t] && (a = a === void 0 ? e[t] : a + "/" + e[t]);
  return a === void 0 ? "." : Sp(a);
}
function Sp(e) {
  Zr(e);
  const t = e.codePointAt(0) === 47;
  let a = zp(e, !t);
  return a.length === 0 && !t && (a = "."), a.length > 0 && e.codePointAt(e.length - 1) === 47 && (a += "/"), t ? "/" + a : a;
}
function zp(e, t) {
  let a = "", r = 0, n = -1, s = 0, i = -1, o, c;
  for (; ++i <= e.length; ) {
    if (i < e.length)
      o = e.codePointAt(i);
    else {
      if (o === 47)
        break;
      o = 47;
    }
    if (o === 47) {
      if (!(n === i - 1 || s === 1)) if (n !== i - 1 && s === 2) {
        if (a.length < 2 || r !== 2 || a.codePointAt(a.length - 1) !== 46 || a.codePointAt(a.length - 2) !== 46) {
          if (a.length > 2) {
            if (c = a.lastIndexOf("/"), c !== a.length - 1) {
              c < 0 ? (a = "", r = 0) : (a = a.slice(0, c), r = a.length - 1 - a.lastIndexOf("/")), n = i, s = 0;
              continue;
            }
          } else if (a.length > 0) {
            a = "", r = 0, n = i, s = 0;
            continue;
          }
        }
        t && (a = a.length > 0 ? a + "/.." : "..", r = 2);
      } else
        a.length > 0 ? a += "/" + e.slice(n + 1, i) : a = e.slice(n + 1, i), r = i - n - 1;
      n = i, s = 0;
    } else o === 46 && s > -1 ? s++ : s = -1;
  }
  return a;
}
function Zr(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const Np = { cwd: Ip };
function Ip() {
  return "/";
}
function Zs(e) {
  return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
  e.auth === void 0);
}
function Rp(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!Zs(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return Fp(e);
}
function Fp(e) {
  if (e.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const t = e.pathname;
  let a = -1;
  for (; ++a < t.length; )
    if (t.codePointAt(a) === 37 && t.codePointAt(a + 1) === 50) {
      const r = t.codePointAt(a + 2);
      if (r === 70 || r === 102) {
        const n = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw n.code = "ERR_INVALID_FILE_URL_PATH", n;
      }
    }
  return decodeURIComponent(t);
}
const _s = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class au {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let a;
    t ? Zs(t) ? a = { path: t } : typeof t == "string" || Op(t) ? a = { value: t } : a = t : a = {}, this.cwd = "cwd" in a ? "" : Np.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < _s.length; ) {
      const s = _s[r];
      s in a && a[s] !== void 0 && a[s] !== null && (this[s] = s === "history" ? [...a[s]] : a[s]);
    }
    let n;
    for (n in a)
      _s.includes(n) || (this[n] = a[n]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? Qt.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t) {
    ks(t, "basename"), bs(t, "basename"), this.path = Qt.join(this.dirname || "", t);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? Qt.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t) {
    Ko(this.basename, "dirname"), this.path = Qt.join(t || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? Qt.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t) {
    if (bs(t, "extname"), Ko(this.dirname, "extname"), t) {
      if (t.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = Qt.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t) {
    Zs(t) && (t = Rp(t)), ks(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? Qt.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t) {
    ks(t, "stem"), bs(t, "stem"), this.path = Qt.join(this.dirname || "", t + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, a, r) {
    const n = this.message(t, a, r);
    throw n.fatal = !0, n;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, a, r) {
    const n = this.message(t, a, r);
    return n.fatal = void 0, n;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, a, r) {
    const n = new ht(
      // @ts-expect-error: the overloads are fine.
      t,
      a,
      r
    );
    return this.path && (n.name = this.path + ":" + n.name, n.file = this.path), n.fatal = !1, this.messages.push(n), n;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
  }
}
function bs(e, t) {
  if (e && e.includes(Qt.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + Qt.sep + "`"
    );
}
function ks(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function Ko(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function Op(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const Lp = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(e) {
    const r = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), n = r[e], s = function() {
      return n.apply(s, arguments);
    };
    return Object.setPrototypeOf(s, r), s;
  }
), Mp = {}.hasOwnProperty;
class Ni extends Lp {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = Tp();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new Ni()
    );
    let a = -1;
    for (; ++a < this.attachers.length; ) {
      const r = this.attachers[a];
      t.use(...r);
    }
    return t.data(ys(!0, {}, this.namespace)), t;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t, a) {
    return typeof t == "string" ? arguments.length === 2 ? (Ts("data", this.frozen), this.namespace[t] = a, this) : Mp.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (Ts("data", this.frozen), this.namespace = t, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [a, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const n = a.call(t, ...r);
      typeof n == "function" && this.transformers.use(n);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t) {
    this.freeze();
    const a = cn(t), r = this.parser || this.Parser;
    return ws("parse", r), r(String(a), a);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t, a) {
    const r = this;
    return this.freeze(), ws("process", this.parser || this.Parser), Es("process", this.compiler || this.Compiler), a ? n(void 0, a) : new Promise(n);
    function n(s, i) {
      const o = cn(t), c = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(o)
      );
      r.run(c, o, function(d, m, h) {
        if (d || !m || !h)
          return u(d);
        const y = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          m
        ), w = r.stringify(y, h);
        Hp(w) ? h.value = w : h.result = w, u(
          d,
          /** @type {VFileWithOutput<CompileResult>} */
          h
        );
      });
      function u(d, m) {
        d || !m ? i(d) : s ? s(m) : a(void 0, m);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t) {
    let a = !1, r;
    return this.freeze(), ws("processSync", this.parser || this.Parser), Es("processSync", this.compiler || this.Compiler), this.process(t, n), Zo("processSync", "process", a), r;
    function n(s, i) {
      a = !0, Yo(s), r = i;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t, a, r) {
    Jo(t), this.freeze();
    const n = this.transformers;
    return !r && typeof a == "function" && (r = a, a = void 0), r ? s(void 0, r) : new Promise(s);
    function s(i, o) {
      const c = cn(a);
      n.run(t, c, u);
      function u(d, m, h) {
        const y = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          m || t
        );
        d ? o(d) : i ? i(y) : r(void 0, y, h);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t, a) {
    let r = !1, n;
    return this.run(t, a, s), Zo("runSync", "run", r), n;
    function s(i, o) {
      Yo(i), n = o, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t, a) {
    this.freeze();
    const r = cn(a), n = this.compiler || this.Compiler;
    return Es("stringify", n), Jo(t), n(t, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t, ...a) {
    const r = this.attachers, n = this.namespace;
    if (Ts("use", this.frozen), t != null) if (typeof t == "function")
      c(t, a);
    else if (typeof t == "object")
      Array.isArray(t) ? o(t) : i(t);
    else
      throw new TypeError("Expected usable value, not `" + t + "`");
    return this;
    function s(u) {
      if (typeof u == "function")
        c(u, []);
      else if (typeof u == "object")
        if (Array.isArray(u)) {
          const [d, ...m] = (
            /** @type {PluginTuple<Array<unknown>>} */
            u
          );
          c(d, m);
        } else
          i(u);
      else
        throw new TypeError("Expected usable value, not `" + u + "`");
    }
    function i(u) {
      if (!("plugins" in u) && !("settings" in u))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      o(u.plugins), u.settings && (n.settings = ys(!0, n.settings, u.settings));
    }
    function o(u) {
      let d = -1;
      if (u != null) if (Array.isArray(u))
        for (; ++d < u.length; ) {
          const m = u[d];
          s(m);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + u + "`");
    }
    function c(u, d) {
      let m = -1, h = -1;
      for (; ++m < r.length; )
        if (r[m][0] === u) {
          h = m;
          break;
        }
      if (h === -1)
        r.push([u, ...d]);
      else if (d.length > 0) {
        let [y, ...w] = d;
        const v = r[h][1];
        Js(v) && Js(y) && (y = ys(!0, v, y)), r[h] = [u, y, ...w];
      }
    }
  }
}
const Bp = new Ni().freeze();
function ws(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `parser`");
}
function Es(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `compiler`");
}
function Ts(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function Jo(e) {
  if (!Js(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function Zo(e, t, a) {
  if (!a)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function cn(e) {
  return Pp(e) ? e : new au(e);
}
function Pp(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function Hp(e) {
  return typeof e == "string" || Up(e);
}
function Up(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const jp = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", ec = [], tc = { allowDangerousHtml: !0 }, qp = /^(https?|ircs?|mailto|xmpp)$/i, Yp = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function Vp(e) {
  const t = e.allowedElements, a = e.allowElement, r = e.children || "", n = e.className, s = e.components, i = e.disallowedElements, o = e.rehypePlugins || ec, c = e.remarkPlugins || ec, u = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...tc } : tc, d = e.skipHtml, m = e.unwrapDisallowed, h = e.urlTransform || Gp, y = Bp().use(Cm).use(c).use(wp, u).use(o), w = new au();
  typeof r == "string" && (w.value = r);
  for (const C of Yp)
    Object.hasOwn(e, C.from) && ("" + C.from + (C.to ? "use `" + C.to + "` instead" : "remove it") + jp + C.id, void 0);
  const v = y.parse(w);
  let F = y.runSync(v, w);
  return n && (F = {
    type: "element",
    tagName: "div",
    properties: { className: n },
    // Assume no doctypes.
    children: (
      /** @type {Array<ElementContent>} */
      F.type === "root" ? F.children : [F]
    )
  }), lr(F, z), uh(F, {
    Fragment: St.Fragment,
    components: s,
    ignoreInvalidStyle: !0,
    jsx: St.jsx,
    jsxs: St.jsxs,
    passKeys: !0,
    passNode: !0
  });
  function z(C, U, $) {
    if (C.type === "raw" && $ && typeof U == "number")
      return d ? $.children.splice(U, 1) : $.children[U] = { type: "text", value: C.value }, U;
    if (C.type === "element") {
      let O;
      for (O in ms)
        if (Object.hasOwn(ms, O) && Object.hasOwn(C.properties, O)) {
          const p = C.properties[O], M = ms[O];
          (M === null || M.includes(C.tagName)) && (C.properties[O] = h(String(p || ""), O, C));
        }
    }
    if (C.type === "element") {
      let O = t ? !t.includes(C.tagName) : i ? i.includes(C.tagName) : !1;
      if (!O && a && typeof U == "number" && (O = !a(C, U, $)), O && $ && typeof U == "number")
        return m && C.children ? $.children.splice(U, 1, ...C.children) : $.children.splice(U, 1), U;
    }
  }
}
function Gp(e) {
  const t = e.indexOf(":"), a = e.indexOf("?"), r = e.indexOf("#"), n = e.indexOf("/");
  return (
    // If there is no protocol, its relative.
    t < 0 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
    n > -1 && t > n || a > -1 && t > a || r > -1 && t > r || // It is a protocol, it should be allowed.
    qp.test(e.slice(0, t)) ? e : ""
  );
}
function ac(e, t) {
  const a = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let r = 0, n = a.indexOf(t);
  for (; n !== -1; )
    r++, n = a.indexOf(t, n + t.length);
  return r;
}
function Wp(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function ru(e, t, a) {
  const n = cr((a || {}).ignore || []), s = $p(t);
  let i = -1;
  for (; ++i < s.length; )
    zi(e, "text", o);
  function o(u, d) {
    let m = -1, h;
    for (; ++m < d.length; ) {
      const y = d[m], w = h ? h.children : void 0;
      if (n(
        y,
        w ? w.indexOf(y) : void 0,
        h
      ))
        return;
      h = y;
    }
    if (h)
      return c(u, d);
  }
  function c(u, d) {
    const m = d[d.length - 1], h = s[i][0], y = s[i][1];
    let w = 0;
    const F = m.children.indexOf(u);
    let z = !1, C = [];
    h.lastIndex = 0;
    let U = h.exec(u.value);
    for (; U; ) {
      const $ = U.index, O = {
        index: U.index,
        input: U.input,
        stack: [...d, u]
      };
      let p = y(...U, O);
      if (typeof p == "string" && (p = p.length > 0 ? { type: "text", value: p } : void 0), p === !1 ? h.lastIndex = $ + 1 : (w !== $ && C.push({
        type: "text",
        value: u.value.slice(w, $)
      }), Array.isArray(p) ? C.push(...p) : p && C.push(p), w = $ + U[0].length, z = !0), !h.global)
        break;
      U = h.exec(u.value);
    }
    return z ? (w < u.value.length && C.push({ type: "text", value: u.value.slice(w) }), m.children.splice(F, 1, ...C)) : C = [u], F + C.length;
  }
}
function $p(e) {
  const t = [];
  if (!Array.isArray(e))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const a = !e[0] || Array.isArray(e[0]) ? e : [e];
  let r = -1;
  for (; ++r < a.length; ) {
    const n = a[r];
    t.push([Xp(n[0]), Qp(n[1])]);
  }
  return t;
}
function Xp(e) {
  return typeof e == "string" ? new RegExp(Wp(e), "g") : e;
}
function Qp(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
const vs = "phrasing", xs = ["autolink", "link", "image", "label"];
function Kp() {
  return {
    transforms: [n1],
    enter: {
      literalAutolink: Zp,
      literalAutolinkEmail: As,
      literalAutolinkHttp: As,
      literalAutolinkWww: As
    },
    exit: {
      literalAutolink: r1,
      literalAutolinkEmail: a1,
      literalAutolinkHttp: e1,
      literalAutolinkWww: t1
    }
  };
}
function Jp() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: vs,
        notInConstruct: xs
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: vs,
        notInConstruct: xs
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: vs,
        notInConstruct: xs
      }
    ]
  };
}
function Zp(e) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e);
}
function As(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function e1(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function t1(e) {
  this.config.exit.data.call(this, e);
  const t = this.stack[this.stack.length - 1];
  t.type, t.url = "http://" + this.sliceSerialize(e);
}
function a1(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function r1(e) {
  this.exit(e);
}
function n1(e) {
  ru(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, s1],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), i1]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function s1(e, t, a, r, n) {
  let s = "";
  if (!nu(n) || (/^w/i.test(t) && (a = t + a, t = "", s = "http://"), !o1(a)))
    return !1;
  const i = c1(a + r);
  if (!i[0]) return !1;
  const o = {
    type: "link",
    title: null,
    url: s + t + i[0],
    children: [{ type: "text", value: t + i[0] }]
  };
  return i[1] ? [o, { type: "text", value: i[1] }] : o;
}
function i1(e, t, a, r) {
  return (
    // Not an expected previous character.
    !nu(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(a) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + a,
      children: [{ type: "text", value: t + "@" + a }]
    }
  );
}
function o1(e) {
  const t = e.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function c1(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!t)
    return [e, void 0];
  e = e.slice(0, t.index);
  let a = t[0], r = a.indexOf(")");
  const n = ac(e, "(");
  let s = ac(e, ")");
  for (; r !== -1 && n > s; )
    e += a.slice(0, r + 1), a = a.slice(r + 1), r = a.indexOf(")"), s++;
  return [e, a];
}
function nu(e, t) {
  const a = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || Va(a) || qn(a)) && // If its an email, the previous character should not be a slash.
  (!t || a !== 47);
}
su.peek = b1;
function l1() {
  return {
    enter: {
      gfmFootnoteDefinition: f1,
      gfmFootnoteDefinitionLabelString: h1,
      gfmFootnoteCall: p1,
      gfmFootnoteCallString: g1
    },
    exit: {
      gfmFootnoteDefinition: m1,
      gfmFootnoteDefinitionLabelString: d1,
      gfmFootnoteCall: _1,
      gfmFootnoteCallString: y1
    }
  };
}
function u1() {
  return {
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["phrasing", "label", "reference"] }],
    handlers: { footnoteDefinition: k1, footnoteReference: su }
  };
}
function f1(e) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e
  );
}
function h1() {
  this.buffer();
}
function d1(e) {
  const t = this.resume(), a = this.stack[this.stack.length - 1];
  a.type, a.label = t, a.identifier = Gt(
    this.sliceSerialize(e)
  ).toLowerCase();
}
function m1(e) {
  this.exit(e);
}
function p1(e) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
}
function g1() {
  this.buffer();
}
function y1(e) {
  const t = this.resume(), a = this.stack[this.stack.length - 1];
  a.type, a.label = t, a.identifier = Gt(
    this.sliceSerialize(e)
  ).toLowerCase();
}
function _1(e) {
  this.exit(e);
}
function su(e, t, a, r) {
  const n = a.createTracker(r);
  let s = n.move("[^");
  const i = a.enter("footnoteReference"), o = a.enter("reference");
  return s += n.move(
    a.safe(a.associationId(e), {
      ...n.current(),
      before: s,
      after: "]"
    })
  ), o(), i(), s += n.move("]"), s;
}
function b1() {
  return "[";
}
function k1(e, t, a, r) {
  const n = a.createTracker(r);
  let s = n.move("[^");
  const i = a.enter("footnoteDefinition"), o = a.enter("label");
  return s += n.move(
    a.safe(a.associationId(e), {
      ...n.current(),
      before: s,
      after: "]"
    })
  ), o(), s += n.move(
    "]:" + (e.children && e.children.length > 0 ? " " : "")
  ), n.shift(4), s += n.move(
    a.indentLines(a.containerFlow(e, n.current()), w1)
  ), i(), s;
}
function w1(e, t, a) {
  return t === 0 ? e : (a ? "" : "    ") + e;
}
const E1 = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
iu.peek = D1;
function T1() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: x1 },
    exit: { strikethrough: A1 }
  };
}
function v1() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: E1
      }
    ],
    handlers: { delete: iu }
  };
}
function x1(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function A1(e) {
  this.exit(e);
}
function iu(e, t, a, r) {
  const n = a.createTracker(r), s = a.enter("strikethrough");
  let i = n.move("~~");
  return i += a.containerPhrasing(e, {
    ...n.current(),
    before: i,
    after: "~"
  }), i += n.move("~~"), s(), i;
}
function D1() {
  return "~";
}
function C1(e, t = {}) {
  const a = (t.align || []).concat(), r = t.stringLength || z1, n = [], s = [], i = [], o = [];
  let c = 0, u = -1;
  for (; ++u < e.length; ) {
    const w = [], v = [];
    let F = -1;
    for (e[u].length > c && (c = e[u].length); ++F < e[u].length; ) {
      const z = S1(e[u][F]);
      if (t.alignDelimiters !== !1) {
        const C = r(z);
        v[F] = C, (o[F] === void 0 || C > o[F]) && (o[F] = C);
      }
      w.push(z);
    }
    s[u] = w, i[u] = v;
  }
  let d = -1;
  if (typeof a == "object" && "length" in a)
    for (; ++d < c; )
      n[d] = rc(a[d]);
  else {
    const w = rc(a);
    for (; ++d < c; )
      n[d] = w;
  }
  d = -1;
  const m = [], h = [];
  for (; ++d < c; ) {
    const w = n[d];
    let v = "", F = "";
    w === 99 ? (v = ":", F = ":") : w === 108 ? v = ":" : w === 114 && (F = ":");
    let z = t.alignDelimiters === !1 ? 1 : Math.max(
      1,
      o[d] - v.length - F.length
    );
    const C = v + "-".repeat(z) + F;
    t.alignDelimiters !== !1 && (z = v.length + z + F.length, z > o[d] && (o[d] = z), h[d] = z), m[d] = C;
  }
  s.splice(1, 0, m), i.splice(1, 0, h), u = -1;
  const y = [];
  for (; ++u < s.length; ) {
    const w = s[u], v = i[u];
    d = -1;
    const F = [];
    for (; ++d < c; ) {
      const z = w[d] || "";
      let C = "", U = "";
      if (t.alignDelimiters !== !1) {
        const $ = o[d] - (v[d] || 0), O = n[d];
        O === 114 ? C = " ".repeat($) : O === 99 ? $ % 2 ? (C = " ".repeat($ / 2 + 0.5), U = " ".repeat($ / 2 - 0.5)) : (C = " ".repeat($ / 2), U = C) : U = " ".repeat($);
      }
      t.delimiterStart !== !1 && !d && F.push("|"), t.padding !== !1 && // Dont add the opening space if were not aligning and the cell is
      // empty: there will be a closing space.
      !(t.alignDelimiters === !1 && z === "") && (t.delimiterStart !== !1 || d) && F.push(" "), t.alignDelimiters !== !1 && F.push(C), F.push(z), t.alignDelimiters !== !1 && F.push(U), t.padding !== !1 && F.push(" "), (t.delimiterEnd !== !1 || d !== c - 1) && F.push("|");
    }
    y.push(
      t.delimiterEnd === !1 ? F.join("").replace(/ +$/, "") : F.join("")
    );
  }
  return y.join(`
`);
}
function S1(e) {
  return e == null ? "" : String(e);
}
function z1(e) {
  return e.length;
}
function rc(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
const nc = {}.hasOwnProperty;
function ou(e, t) {
  const a = t || {};
  function r(n, ...s) {
    let i = r.invalid;
    const o = r.handlers;
    if (n && nc.call(n, e)) {
      const c = String(n[e]);
      i = nc.call(o, c) ? o[c] : r.unknown;
    }
    if (i)
      return i.call(this, n, ...s);
  }
  return r.handlers = a.handlers || {}, r.invalid = a.invalid, r.unknown = a.unknown, r;
}
function N1(e, t, a, r) {
  const n = a.enter("blockquote"), s = a.createTracker(r);
  s.move("> "), s.shift(2);
  const i = a.indentLines(
    a.containerFlow(e, s.current()),
    I1
  );
  return n(), i;
}
function I1(e, t, a) {
  return ">" + (a ? "" : " ") + e;
}
function R1(e, t) {
  return sc(e, t.inConstruct, !0) && !sc(e, t.notInConstruct, !1);
}
function sc(e, t, a) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return a;
  let r = -1;
  for (; ++r < t.length; )
    if (e.includes(t[r]))
      return !0;
  return !1;
}
function ic(e, t, a, r) {
  let n = -1;
  for (; ++n < a.unsafe.length; )
    if (a.unsafe[n].character === `
` && R1(a.stack, a.unsafe[n]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function cu(e, t) {
  const a = String(e);
  let r = a.indexOf(t), n = r, s = 0, i = 0;
  if (typeof t != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === n ? ++s > i && (i = s) : s = 1, n = r + t.length, r = a.indexOf(t, n);
  return i;
}
function F1(e, t) {
  return !!(t.options.fences === !1 && e.value && // If theres no info
  !e.lang && // And theres a non-whitespace character
  /[^ \r\n]/.test(e.value) && // And the value doesnt start or end in a blank
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function O1(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function L1(e, t, a, r) {
  const n = O1(a), s = e.value || "", i = n === "`" ? "GraveAccent" : "Tilde";
  if (F1(e, a)) {
    const m = a.enter("codeIndented"), h = a.indentLines(s, M1);
    return m(), h;
  }
  const o = a.createTracker(r), c = n.repeat(Math.max(cu(s, n) + 1, 3)), u = a.enter("codeFenced");
  let d = o.move(c);
  if (e.lang) {
    const m = a.enter(`codeFencedLang${i}`);
    d += o.move(
      a.safe(e.lang, {
        before: d,
        after: " ",
        encode: ["`"],
        ...o.current()
      })
    ), m();
  }
  if (e.lang && e.meta) {
    const m = a.enter(`codeFencedMeta${i}`);
    d += o.move(" "), d += o.move(
      a.safe(e.meta, {
        before: d,
        after: `
`,
        encode: ["`"],
        ...o.current()
      })
    ), m();
  }
  return d += o.move(`
`), s && (d += o.move(s + `
`)), d += o.move(c), u(), d;
}
function M1(e, t, a) {
  return (a ? "" : "    ") + e;
}
function Ii(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function B1(e, t, a, r) {
  const n = Ii(a), s = n === '"' ? "Quote" : "Apostrophe", i = a.enter("definition");
  let o = a.enter("label");
  const c = a.createTracker(r);
  let u = c.move("[");
  return u += c.move(
    a.safe(a.associationId(e), {
      before: u,
      after: "]",
      ...c.current()
    })
  ), u += c.move("]: "), o(), // If theres no url, or
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (o = a.enter("destinationLiteral"), u += c.move("<"), u += c.move(
    a.safe(e.url, { before: u, after: ">", ...c.current() })
  ), u += c.move(">")) : (o = a.enter("destinationRaw"), u += c.move(
    a.safe(e.url, {
      before: u,
      after: e.title ? " " : `
`,
      ...c.current()
    })
  )), o(), e.title && (o = a.enter(`title${s}`), u += c.move(" " + n), u += c.move(
    a.safe(e.title, {
      before: u,
      after: n,
      ...c.current()
    })
  ), u += c.move(n), o()), i(), u;
}
function P1(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
lu.peek = H1;
function lu(e, t, a, r) {
  const n = P1(a), s = a.enter("emphasis"), i = a.createTracker(r);
  let o = i.move(n);
  return o += i.move(
    a.containerPhrasing(e, {
      before: o,
      after: n,
      ...i.current()
    })
  ), o += i.move(n), s(), o;
}
function H1(e, t, a) {
  return a.options.emphasis || "*";
}
function U1(e, t) {
  let a = !1;
  return lr(e, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return a = !0, Qs;
  }), !!((!e.depth || e.depth < 3) && jn(e) && (t.options.setext || a));
}
function j1(e, t, a, r) {
  const n = Math.max(Math.min(6, e.depth || 1), 1), s = a.createTracker(r);
  if (U1(e, a)) {
    const d = a.enter("headingSetext"), m = a.enter("phrasing"), h = a.containerPhrasing(e, {
      ...s.current(),
      before: `
`,
      after: `
`
    });
    return m(), d(), h + `
` + (n === 1 ? "=" : "-").repeat(
      // The whole size
      h.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)
      (Math.max(h.lastIndexOf("\r"), h.lastIndexOf(`
`)) + 1)
    );
  }
  const i = "#".repeat(n), o = a.enter("headingAtx"), c = a.enter("phrasing");
  s.move(i + " ");
  let u = a.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...s.current()
  });
  return /^[\t ]/.test(u) && (u = "&#x" + u.charCodeAt(0).toString(16).toUpperCase() + ";" + u.slice(1)), u = u ? i + " " + u : i, a.options.closeAtx && (u += " " + i), c(), o(), u;
}
uu.peek = q1;
function uu(e) {
  return e.value || "";
}
function q1() {
  return "<";
}
fu.peek = Y1;
function fu(e, t, a, r) {
  const n = Ii(a), s = n === '"' ? "Quote" : "Apostrophe", i = a.enter("image");
  let o = a.enter("label");
  const c = a.createTracker(r);
  let u = c.move("![");
  return u += c.move(
    a.safe(e.alt, { before: u, after: "]", ...c.current() })
  ), u += c.move("]("), o(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (o = a.enter("destinationLiteral"), u += c.move("<"), u += c.move(
    a.safe(e.url, { before: u, after: ">", ...c.current() })
  ), u += c.move(">")) : (o = a.enter("destinationRaw"), u += c.move(
    a.safe(e.url, {
      before: u,
      after: e.title ? " " : ")",
      ...c.current()
    })
  )), o(), e.title && (o = a.enter(`title${s}`), u += c.move(" " + n), u += c.move(
    a.safe(e.title, {
      before: u,
      after: n,
      ...c.current()
    })
  ), u += c.move(n), o()), u += c.move(")"), i(), u;
}
function Y1() {
  return "!";
}
hu.peek = V1;
function hu(e, t, a, r) {
  const n = e.referenceType, s = a.enter("imageReference");
  let i = a.enter("label");
  const o = a.createTracker(r);
  let c = o.move("![");
  const u = a.safe(e.alt, {
    before: c,
    after: "]",
    ...o.current()
  });
  c += o.move(u + "]["), i();
  const d = a.stack;
  a.stack = [], i = a.enter("reference");
  const m = a.safe(a.associationId(e), {
    before: c,
    after: "]",
    ...o.current()
  });
  return i(), a.stack = d, s(), n === "full" || !u || u !== m ? c += o.move(m + "]") : n === "shortcut" ? c = c.slice(0, -1) : c += o.move("]"), c;
}
function V1() {
  return "!";
}
du.peek = G1;
function du(e, t, a) {
  let r = e.value || "", n = "`", s = -1;
  for (; new RegExp("(^|[^`])" + n + "([^`]|$)").test(r); )
    n += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++s < a.unsafe.length; ) {
    const i = a.unsafe[s], o = a.compilePattern(i);
    let c;
    if (i.atBreak)
      for (; c = o.exec(r); ) {
        let u = c.index;
        r.charCodeAt(u) === 10 && r.charCodeAt(u - 1) === 13 && u--, r = r.slice(0, u) + " " + r.slice(c.index + 1);
      }
  }
  return n + r + n;
}
function G1() {
  return "`";
}
function mu(e, t) {
  const a = jn(e);
  return !!(!t.options.resourceLink && // If theres a url
  e.url && // And theres a no title
  !e.title && // And the content of `node` is a single text node
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content
  (a === e.url || "mailto:" + a === e.url) && // And that starts w/ a protocol
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesnt contain ASCII control codes (character escapes and
  // references dont work), space, or angle brackets
  !/[\0- <>\u007F]/.test(e.url));
}
pu.peek = W1;
function pu(e, t, a, r) {
  const n = Ii(a), s = n === '"' ? "Quote" : "Apostrophe", i = a.createTracker(r);
  let o, c;
  if (mu(e, a)) {
    const d = a.stack;
    a.stack = [], o = a.enter("autolink");
    let m = i.move("<");
    return m += i.move(
      a.containerPhrasing(e, {
        before: m,
        after: ">",
        ...i.current()
      })
    ), m += i.move(">"), o(), a.stack = d, m;
  }
  o = a.enter("link"), c = a.enter("label");
  let u = i.move("[");
  return u += i.move(
    a.containerPhrasing(e, {
      before: u,
      after: "](",
      ...i.current()
    })
  ), u += i.move("]("), c(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (c = a.enter("destinationLiteral"), u += i.move("<"), u += i.move(
    a.safe(e.url, { before: u, after: ">", ...i.current() })
  ), u += i.move(">")) : (c = a.enter("destinationRaw"), u += i.move(
    a.safe(e.url, {
      before: u,
      after: e.title ? " " : ")",
      ...i.current()
    })
  )), c(), e.title && (c = a.enter(`title${s}`), u += i.move(" " + n), u += i.move(
    a.safe(e.title, {
      before: u,
      after: n,
      ...i.current()
    })
  ), u += i.move(n), c()), u += i.move(")"), o(), u;
}
function W1(e, t, a) {
  return mu(e, a) ? "<" : "[";
}
gu.peek = $1;
function gu(e, t, a, r) {
  const n = e.referenceType, s = a.enter("linkReference");
  let i = a.enter("label");
  const o = a.createTracker(r);
  let c = o.move("[");
  const u = a.containerPhrasing(e, {
    before: c,
    after: "]",
    ...o.current()
  });
  c += o.move(u + "]["), i();
  const d = a.stack;
  a.stack = [], i = a.enter("reference");
  const m = a.safe(a.associationId(e), {
    before: c,
    after: "]",
    ...o.current()
  });
  return i(), a.stack = d, s(), n === "full" || !u || u !== m ? c += o.move(m + "]") : n === "shortcut" ? c = c.slice(0, -1) : c += o.move("]"), c;
}
function $1() {
  return "[";
}
function Ri(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function X1(e) {
  const t = Ri(e), a = e.options.bulletOther;
  if (!a)
    return t === "*" ? "-" : "*";
  if (a !== "*" && a !== "+" && a !== "-")
    throw new Error(
      "Cannot serialize items with `" + a + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (a === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + a + "`) to be different"
    );
  return a;
}
function Q1(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function yu(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function K1(e, t, a, r) {
  const n = a.enter("list"), s = a.bulletCurrent;
  let i = e.ordered ? Q1(a) : Ri(a);
  const o = e.ordered ? i === "." ? ")" : "." : X1(a);
  let c = t && a.bulletLastUsed ? i === a.bulletLastUsed : !1;
  if (!e.ordered) {
    const d = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (i === "*" || i === "-") && // Empty first list item:
      d && (!d.children || !d.children[0]) && // Directly in two other list items:
      a.stack[a.stack.length - 1] === "list" && a.stack[a.stack.length - 2] === "listItem" && a.stack[a.stack.length - 3] === "list" && a.stack[a.stack.length - 4] === "listItem" && // That are each the first child.
      a.indexStack[a.indexStack.length - 1] === 0 && a.indexStack[a.indexStack.length - 2] === 0 && a.indexStack[a.indexStack.length - 3] === 0 && (c = !0), yu(a) === i && d
    ) {
      let m = -1;
      for (; ++m < e.children.length; ) {
        const h = e.children[m];
        if (h && h.type === "listItem" && h.children && h.children[0] && h.children[0].type === "thematicBreak") {
          c = !0;
          break;
        }
      }
    }
  }
  c && (i = o), a.bulletCurrent = i;
  const u = a.containerFlow(e, r);
  return a.bulletLastUsed = i, a.bulletCurrent = s, n(), u;
}
function J1(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function Z1(e, t, a, r) {
  const n = J1(a);
  let s = a.bulletCurrent || Ri(a);
  t && t.type === "list" && t.ordered && (s = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (a.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + s);
  let i = s.length + 1;
  (n === "tab" || n === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (i = Math.ceil(i / 4) * 4);
  const o = a.createTracker(r);
  o.move(s + " ".repeat(i - s.length)), o.shift(i);
  const c = a.enter("listItem"), u = a.indentLines(
    a.containerFlow(e, o.current()),
    d
  );
  return c(), u;
  function d(m, h, y) {
    return h ? (y ? "" : " ".repeat(i)) + m : (y ? s : s + " ".repeat(i - s.length)) + m;
  }
}
function eg(e, t, a, r) {
  const n = a.enter("paragraph"), s = a.enter("phrasing"), i = a.containerPhrasing(e, r);
  return s(), n(), i;
}
const tg = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  cr([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function ag(e, t, a, r) {
  return (e.children.some(function(i) {
    return tg(i);
  }) ? a.containerPhrasing : a.containerFlow).call(a, e, r);
}
function rg(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
_u.peek = ng;
function _u(e, t, a, r) {
  const n = rg(a), s = a.enter("strong"), i = a.createTracker(r);
  let o = i.move(n + n);
  return o += i.move(
    a.containerPhrasing(e, {
      before: o,
      after: n,
      ...i.current()
    })
  ), o += i.move(n + n), s(), o;
}
function ng(e, t, a) {
  return a.options.strong || "*";
}
function sg(e, t, a, r) {
  return a.safe(e.value, r);
}
function ig(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function og(e, t, a) {
  const r = (yu(a) + (a.options.ruleSpaces ? " " : "")).repeat(ig(a));
  return a.options.ruleSpaces ? r.slice(0, -1) : r;
}
const bu = {
  blockquote: N1,
  break: ic,
  code: L1,
  definition: B1,
  emphasis: lu,
  hardBreak: ic,
  heading: j1,
  html: uu,
  image: fu,
  imageReference: hu,
  inlineCode: du,
  link: pu,
  linkReference: gu,
  list: K1,
  listItem: Z1,
  paragraph: eg,
  root: ag,
  strong: _u,
  text: sg,
  thematicBreak: og
};
function cg() {
  return {
    enter: {
      table: lg,
      tableData: oc,
      tableHeader: oc,
      tableRow: fg
    },
    exit: {
      codeText: hg,
      table: ug,
      tableData: Ds,
      tableHeader: Ds,
      tableRow: Ds
    }
  };
}
function lg(e) {
  const t = e._align;
  this.enter(
    {
      type: "table",
      align: t.map(function(a) {
        return a === "none" ? null : a;
      }),
      children: []
    },
    e
  ), this.data.inTable = !0;
}
function ug(e) {
  this.exit(e), this.data.inTable = void 0;
}
function fg(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function Ds(e) {
  this.exit(e);
}
function oc(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function hg(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, dg));
  const a = this.stack[this.stack.length - 1];
  a.type, a.value = t, this.exit(e);
}
function dg(e, t) {
  return t === "|" ? t : e;
}
function mg(e) {
  const t = e || {}, a = t.tableCellPadding, r = t.tablePipeAlign, n = t.stringLength, s = a ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: h,
      table: i,
      tableCell: c,
      tableRow: o
    }
  };
  function i(y, w, v, F) {
    return u(d(y, v, F), y.align);
  }
  function o(y, w, v, F) {
    const z = m(y, v, F), C = u([z]);
    return C.slice(0, C.indexOf(`
`));
  }
  function c(y, w, v, F) {
    const z = v.enter("tableCell"), C = v.enter("phrasing"), U = v.containerPhrasing(y, {
      ...F,
      before: s,
      after: s
    });
    return C(), z(), U;
  }
  function u(y, w) {
    return C1(y, {
      align: w,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: a,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: n
    });
  }
  function d(y, w, v) {
    const F = y.children;
    let z = -1;
    const C = [], U = w.enter("table");
    for (; ++z < F.length; )
      C[z] = m(F[z], w, v);
    return U(), C;
  }
  function m(y, w, v) {
    const F = y.children;
    let z = -1;
    const C = [], U = w.enter("tableRow");
    for (; ++z < F.length; )
      C[z] = c(F[z], y, w, v);
    return U(), C;
  }
  function h(y, w, v) {
    let F = bu.inlineCode(y, w, v);
    return v.stack.includes("tableCell") && (F = F.replace(/\|/g, "\\$&")), F;
  }
}
function pg() {
  return {
    exit: {
      taskListCheckValueChecked: cc,
      taskListCheckValueUnchecked: cc,
      paragraph: yg
    }
  };
}
function gg() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: _g }
  };
}
function cc(e) {
  const t = this.stack[this.stack.length - 2];
  t.type, t.checked = e.type === "taskListCheckValueChecked";
}
function yg(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const a = this.stack[this.stack.length - 1];
    a.type;
    const r = a.children[0];
    if (r && r.type === "text") {
      const n = t.children;
      let s = -1, i;
      for (; ++s < n.length; ) {
        const o = n[s];
        if (o.type === "paragraph") {
          i = o;
          break;
        }
      }
      i === a && (r.value = r.value.slice(1), r.value.length === 0 ? a.children.shift() : a.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, a.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(e);
}
function _g(e, t, a, r) {
  const n = e.children[0], s = typeof e.checked == "boolean" && n && n.type === "paragraph", i = "[" + (e.checked ? "x" : " ") + "] ", o = a.createTracker(r);
  s && o.move(i);
  let c = bu.listItem(e, t, a, {
    ...r,
    ...o.current()
  });
  return s && (c = c.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, u)), c;
  function u(d) {
    return d + i;
  }
}
function bg() {
  return [
    Kp(),
    l1(),
    T1(),
    cg(),
    pg()
  ];
}
function kg(e) {
  return {
    extensions: [
      Jp(),
      u1(),
      v1(),
      mg(e),
      gg()
    ]
  };
}
const wg = {
  tokenize: Dg,
  partial: !0
}, ku = {
  tokenize: Cg,
  partial: !0
}, wu = {
  tokenize: Sg,
  partial: !0
}, Eu = {
  tokenize: zg,
  partial: !0
}, Eg = {
  tokenize: Ng,
  partial: !0
}, Tu = {
  name: "wwwAutolink",
  tokenize: xg,
  previous: xu
}, vu = {
  name: "protocolAutolink",
  tokenize: Ag,
  previous: Au
}, _a = {
  name: "emailAutolink",
  tokenize: vg,
  previous: Du
}, aa = {};
function Tg() {
  return {
    text: aa
  };
}
let Ha = 48;
for (; Ha < 123; )
  aa[Ha] = _a, Ha++, Ha === 58 ? Ha = 65 : Ha === 91 && (Ha = 97);
aa[43] = _a;
aa[45] = _a;
aa[46] = _a;
aa[95] = _a;
aa[72] = [_a, vu];
aa[104] = [_a, vu];
aa[87] = [_a, Tu];
aa[119] = [_a, Tu];
function vg(e, t, a) {
  const r = this;
  let n, s;
  return i;
  function i(m) {
    return !ei(m) || !Du.call(r, r.previous) || Fi(r.events) ? a(m) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), o(m));
  }
  function o(m) {
    return ei(m) ? (e.consume(m), o) : m === 64 ? (e.consume(m), c) : a(m);
  }
  function c(m) {
    return m === 46 ? e.check(Eg, d, u)(m) : m === 45 || m === 95 || ft(m) ? (s = !0, e.consume(m), c) : d(m);
  }
  function u(m) {
    return e.consume(m), n = !0, c;
  }
  function d(m) {
    return s && n && yt(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(m)) : a(m);
  }
}
function xg(e, t, a) {
  const r = this;
  return n;
  function n(i) {
    return i !== 87 && i !== 119 || !xu.call(r, r.previous) || Fi(r.events) ? a(i) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(wg, e.attempt(ku, e.attempt(wu, s), a), a)(i));
  }
  function s(i) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(i);
  }
}
function Ag(e, t, a) {
  const r = this;
  let n = "", s = !1;
  return i;
  function i(m) {
    return (m === 72 || m === 104) && Au.call(r, r.previous) && !Fi(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), n += String.fromCodePoint(m), e.consume(m), o) : a(m);
  }
  function o(m) {
    if (yt(m) && n.length < 5)
      return n += String.fromCodePoint(m), e.consume(m), o;
    if (m === 58) {
      const h = n.toLowerCase();
      if (h === "http" || h === "https")
        return e.consume(m), c;
    }
    return a(m);
  }
  function c(m) {
    return m === 47 ? (e.consume(m), s ? u : (s = !0, c)) : a(m);
  }
  function u(m) {
    return m === null || Cn(m) || Oe(m) || Va(m) || qn(m) ? a(m) : e.attempt(ku, e.attempt(wu, d), a)(m);
  }
  function d(m) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(m);
  }
}
function Dg(e, t, a) {
  let r = 0;
  return n;
  function n(i) {
    return (i === 87 || i === 119) && r < 3 ? (r++, e.consume(i), n) : i === 46 && r === 3 ? (e.consume(i), s) : a(i);
  }
  function s(i) {
    return i === null ? a(i) : t(i);
  }
}
function Cg(e, t, a) {
  let r, n, s;
  return i;
  function i(u) {
    return u === 46 || u === 95 ? e.check(Eu, c, o)(u) : u === null || Oe(u) || Va(u) || u !== 45 && qn(u) ? c(u) : (s = !0, e.consume(u), i);
  }
  function o(u) {
    return u === 95 ? r = !0 : (n = r, r = void 0), e.consume(u), i;
  }
  function c(u) {
    return n || r || !s ? a(u) : t(u);
  }
}
function Sg(e, t) {
  let a = 0, r = 0;
  return n;
  function n(i) {
    return i === 40 ? (a++, e.consume(i), n) : i === 41 && r < a ? s(i) : i === 33 || i === 34 || i === 38 || i === 39 || i === 41 || i === 42 || i === 44 || i === 46 || i === 58 || i === 59 || i === 60 || i === 63 || i === 93 || i === 95 || i === 126 ? e.check(Eu, t, s)(i) : i === null || Oe(i) || Va(i) ? t(i) : (e.consume(i), n);
  }
  function s(i) {
    return i === 41 && r++, e.consume(i), n;
  }
}
function zg(e, t, a) {
  return r;
  function r(o) {
    return o === 33 || o === 34 || o === 39 || o === 41 || o === 42 || o === 44 || o === 46 || o === 58 || o === 59 || o === 63 || o === 95 || o === 126 ? (e.consume(o), r) : o === 38 ? (e.consume(o), s) : o === 93 ? (e.consume(o), n) : (
      // `<` is an end.
      o === 60 || // So is whitespace.
      o === null || Oe(o) || Va(o) ? t(o) : a(o)
    );
  }
  function n(o) {
    return o === null || o === 40 || o === 91 || Oe(o) || Va(o) ? t(o) : r(o);
  }
  function s(o) {
    return yt(o) ? i(o) : a(o);
  }
  function i(o) {
    return o === 59 ? (e.consume(o), r) : yt(o) ? (e.consume(o), i) : a(o);
  }
}
function Ng(e, t, a) {
  return r;
  function r(s) {
    return e.consume(s), n;
  }
  function n(s) {
    return ft(s) ? a(s) : t(s);
  }
}
function xu(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || Oe(e);
}
function Au(e) {
  return !yt(e);
}
function Du(e) {
  return !(e === 47 || ei(e));
}
function ei(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || ft(e);
}
function Fi(e) {
  let t = e.length, a = !1;
  for (; t--; ) {
    const r = e[t][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      a = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      a = !1;
      break;
    }
  }
  return e.length > 0 && !a && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), a;
}
const Ig = {
  tokenize: Hg,
  partial: !0
};
function Rg() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: Mg,
        continuation: {
          tokenize: Bg
        },
        exit: Pg
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: Lg
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: Fg,
        resolveTo: Og
      }
    }
  };
}
function Fg(e, t, a) {
  const r = this;
  let n = r.events.length;
  const s = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let i;
  for (; n--; ) {
    const c = r.events[n][1];
    if (c.type === "labelImage") {
      i = c;
      break;
    }
    if (c.type === "gfmFootnoteCall" || c.type === "labelLink" || c.type === "label" || c.type === "image" || c.type === "link")
      break;
  }
  return o;
  function o(c) {
    if (!i || !i._balanced)
      return a(c);
    const u = Gt(r.sliceSerialize({
      start: i.end,
      end: r.now()
    }));
    return u.codePointAt(0) !== 94 || !s.includes(u.slice(1)) ? a(c) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(c), e.exit("gfmFootnoteCallLabelMarker"), t(c));
  }
}
function Og(e, t) {
  let a = e.length;
  for (; a--; )
    if (e[a][1].type === "labelImage" && e[a][0] === "enter") {
      e[a][1];
      break;
    }
  e[a + 1][1].type = "data", e[a + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[a + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, n = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[a + 3][1].end),
    end: Object.assign({}, e[a + 3][1].end)
  };
  n.end.column++, n.end.offset++, n.end._bufferIndex++;
  const s = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, n.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, i = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, s.start),
    end: Object.assign({}, s.end)
  }, o = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[a + 1],
    e[a + 2],
    ["enter", r, t],
    // The `[`
    e[a + 3],
    e[a + 4],
    // The `^`.
    ["enter", n, t],
    ["exit", n, t],
    // Everything in between.
    ["enter", s, t],
    ["enter", i, t],
    ["exit", i, t],
    ["exit", s, t],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", r, t]
  ];
  return e.splice(a, e.length - a + 1, ...o), e;
}
function Lg(e, t, a) {
  const r = this, n = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let s = 0, i;
  return o;
  function o(m) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(m), e.exit("gfmFootnoteCallLabelMarker"), c;
  }
  function c(m) {
    return m !== 94 ? a(m) : (e.enter("gfmFootnoteCallMarker"), e.consume(m), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", u);
  }
  function u(m) {
    if (
      // Too long.
      s > 999 || // Closing brace with nothing.
      m === 93 && !i || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      m === null || m === 91 || Oe(m)
    )
      return a(m);
    if (m === 93) {
      e.exit("chunkString");
      const h = e.exit("gfmFootnoteCallString");
      return n.includes(Gt(r.sliceSerialize(h))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(m), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : a(m);
    }
    return Oe(m) || (i = !0), s++, e.consume(m), m === 92 ? d : u;
  }
  function d(m) {
    return m === 91 || m === 92 || m === 93 ? (e.consume(m), s++, u) : u(m);
  }
}
function Mg(e, t, a) {
  const r = this, n = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let s, i = 0, o;
  return c;
  function c(w) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(w), e.exit("gfmFootnoteDefinitionLabelMarker"), u;
  }
  function u(w) {
    return w === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(w), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", d) : a(w);
  }
  function d(w) {
    if (
      // Too long.
      i > 999 || // Closing brace with nothing.
      w === 93 && !o || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      w === null || w === 91 || Oe(w)
    )
      return a(w);
    if (w === 93) {
      e.exit("chunkString");
      const v = e.exit("gfmFootnoteDefinitionLabelString");
      return s = Gt(r.sliceSerialize(v)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(w), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), h;
    }
    return Oe(w) || (o = !0), i++, e.consume(w), w === 92 ? m : d;
  }
  function m(w) {
    return w === 91 || w === 92 || w === 93 ? (e.consume(w), i++, d) : d(w);
  }
  function h(w) {
    return w === 58 ? (e.enter("definitionMarker"), e.consume(w), e.exit("definitionMarker"), n.includes(s) || n.push(s), xe(e, y, "gfmFootnoteDefinitionWhitespace")) : a(w);
  }
  function y(w) {
    return t(w);
  }
}
function Bg(e, t, a) {
  return e.check(Jr, t, e.attempt(Ig, t, a));
}
function Pg(e) {
  e.exit("gfmFootnoteDefinition");
}
function Hg(e, t, a) {
  const r = this;
  return xe(e, n, "gfmFootnoteDefinitionIndent", 5);
  function n(s) {
    const i = r.events[r.events.length - 1];
    return i && i[1].type === "gfmFootnoteDefinitionIndent" && i[2].sliceSerialize(i[1], !0).length === 4 ? t(s) : a(s);
  }
}
function Ug(e) {
  let a = (e || {}).singleTilde;
  const r = {
    name: "strikethrough",
    tokenize: s,
    resolveAll: n
  };
  return a == null && (a = !0), {
    text: {
      126: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function n(i, o) {
    let c = -1;
    for (; ++c < i.length; )
      if (i[c][0] === "enter" && i[c][1].type === "strikethroughSequenceTemporary" && i[c][1]._close) {
        let u = c;
        for (; u--; )
          if (i[u][0] === "exit" && i[u][1].type === "strikethroughSequenceTemporary" && i[u][1]._open && // If the sizes are the same:
          i[c][1].end.offset - i[c][1].start.offset === i[u][1].end.offset - i[u][1].start.offset) {
            i[c][1].type = "strikethroughSequence", i[u][1].type = "strikethroughSequence";
            const d = {
              type: "strikethrough",
              start: Object.assign({}, i[u][1].start),
              end: Object.assign({}, i[c][1].end)
            }, m = {
              type: "strikethroughText",
              start: Object.assign({}, i[u][1].end),
              end: Object.assign({}, i[c][1].start)
            }, h = [["enter", d, o], ["enter", i[u][1], o], ["exit", i[u][1], o], ["enter", m, o]], y = o.parser.constructs.insideSpan.null;
            y && Bt(h, h.length, 0, Yn(y, i.slice(u + 1, c), o)), Bt(h, h.length, 0, [["exit", m, o], ["enter", i[c][1], o], ["exit", i[c][1], o], ["exit", d, o]]), Bt(i, u - 1, c - u + 3, h), c = u + h.length - 2;
            break;
          }
      }
    for (c = -1; ++c < i.length; )
      i[c][1].type === "strikethroughSequenceTemporary" && (i[c][1].type = "data");
    return i;
  }
  function s(i, o, c) {
    const u = this.previous, d = this.events;
    let m = 0;
    return h;
    function h(w) {
      return u === 126 && d[d.length - 1][1].type !== "characterEscape" ? c(w) : (i.enter("strikethroughSequenceTemporary"), y(w));
    }
    function y(w) {
      const v = Sn(u);
      if (w === 126)
        return m > 1 ? c(w) : (i.consume(w), m++, y);
      if (m < 2 && !a) return c(w);
      const F = i.exit("strikethroughSequenceTemporary"), z = Sn(w);
      return F._open = !z || z === 2 && !!v, F._close = !v || v === 2 && !!z, o(w);
    }
  }
}
class jg {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, a, r) {
    qg(this, t, a, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(s, i) {
      return s[0] - i[0];
    }), this.map.length === 0)
      return;
    let a = this.map.length;
    const r = [];
    for (; a > 0; )
      a -= 1, r.push(t.slice(this.map[a][0] + this.map[a][1]), this.map[a][2]), t.length = this.map[a][0];
    r.push([...t]), t.length = 0;
    let n = r.pop();
    for (; n; )
      t.push(...n), n = r.pop();
    this.map.length = 0;
  }
}
function qg(e, t, a, r) {
  let n = 0;
  if (!(a === 0 && r.length === 0)) {
    for (; n < e.map.length; ) {
      if (e.map[n][0] === t) {
        e.map[n][1] += a, e.map[n][2].push(...r);
        return;
      }
      n += 1;
    }
    e.map.push([t, a, r]);
  }
}
function Yg(e, t) {
  let a = !1;
  const r = [];
  for (; t < e.length; ) {
    const n = e[t];
    if (a) {
      if (n[0] === "enter")
        n[1].type === "tableContent" && r.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (n[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const s = r.length - 1;
          r[s] = r[s] === "left" ? "center" : "right";
        }
      } else if (n[1].type === "tableDelimiterRow")
        break;
    } else n[0] === "enter" && n[1].type === "tableDelimiterRow" && (a = !0);
    t += 1;
  }
  return r;
}
function Vg() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: Gg,
        resolveAll: Wg
      }
    }
  };
}
function Gg(e, t, a) {
  const r = this;
  let n = 0, s = 0, i;
  return o;
  function o(P) {
    let re = r.events.length - 1;
    for (; re > -1; ) {
      const de = r.events[re][1].type;
      if (de === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      de === "linePrefix") re--;
      else break;
    }
    const ae = re > -1 ? r.events[re][1].type : null, ue = ae === "tableHead" || ae === "tableRow" ? p : c;
    return ue === p && r.parser.lazy[r.now().line] ? a(P) : ue(P);
  }
  function c(P) {
    return e.enter("tableHead"), e.enter("tableRow"), u(P);
  }
  function u(P) {
    return P === 124 || (i = !0, s += 1), d(P);
  }
  function d(P) {
    return P === null ? a(P) : le(P) ? s > 1 ? (s = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(P), e.exit("lineEnding"), y) : a(P) : Ae(P) ? xe(e, d, "whitespace")(P) : (s += 1, i && (i = !1, n += 1), P === 124 ? (e.enter("tableCellDivider"), e.consume(P), e.exit("tableCellDivider"), i = !0, d) : (e.enter("data"), m(P)));
  }
  function m(P) {
    return P === null || P === 124 || Oe(P) ? (e.exit("data"), d(P)) : (e.consume(P), P === 92 ? h : m);
  }
  function h(P) {
    return P === 92 || P === 124 ? (e.consume(P), m) : m(P);
  }
  function y(P) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? a(P) : (e.enter("tableDelimiterRow"), i = !1, Ae(P) ? xe(e, w, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(P) : w(P));
  }
  function w(P) {
    return P === 45 || P === 58 ? F(P) : P === 124 ? (i = !0, e.enter("tableCellDivider"), e.consume(P), e.exit("tableCellDivider"), v) : O(P);
  }
  function v(P) {
    return Ae(P) ? xe(e, F, "whitespace")(P) : F(P);
  }
  function F(P) {
    return P === 58 ? (s += 1, i = !0, e.enter("tableDelimiterMarker"), e.consume(P), e.exit("tableDelimiterMarker"), z) : P === 45 ? (s += 1, z(P)) : P === null || le(P) ? $(P) : O(P);
  }
  function z(P) {
    return P === 45 ? (e.enter("tableDelimiterFiller"), C(P)) : O(P);
  }
  function C(P) {
    return P === 45 ? (e.consume(P), C) : P === 58 ? (i = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(P), e.exit("tableDelimiterMarker"), U) : (e.exit("tableDelimiterFiller"), U(P));
  }
  function U(P) {
    return Ae(P) ? xe(e, $, "whitespace")(P) : $(P);
  }
  function $(P) {
    return P === 124 ? w(P) : P === null || le(P) ? !i || n !== s ? O(P) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(P)) : O(P);
  }
  function O(P) {
    return a(P);
  }
  function p(P) {
    return e.enter("tableRow"), M(P);
  }
  function M(P) {
    return P === 124 ? (e.enter("tableCellDivider"), e.consume(P), e.exit("tableCellDivider"), M) : P === null || le(P) ? (e.exit("tableRow"), t(P)) : Ae(P) ? xe(e, M, "whitespace")(P) : (e.enter("data"), te(P));
  }
  function te(P) {
    return P === null || P === 124 || Oe(P) ? (e.exit("data"), M(P)) : (e.consume(P), P === 92 ? Z : te);
  }
  function Z(P) {
    return P === 92 || P === 124 ? (e.consume(P), te) : te(P);
  }
}
function Wg(e, t) {
  let a = -1, r = !0, n = 0, s = [0, 0, 0, 0], i = [0, 0, 0, 0], o = !1, c = 0, u, d, m;
  const h = new jg();
  for (; ++a < e.length; ) {
    const y = e[a], w = y[1];
    y[0] === "enter" ? w.type === "tableHead" ? (o = !1, c !== 0 && (lc(h, t, c, u, d), d = void 0, c = 0), u = {
      type: "table",
      start: Object.assign({}, w.start),
      // Note: correct end is set later.
      end: Object.assign({}, w.end)
    }, h.add(a, 0, [["enter", u, t]])) : w.type === "tableRow" || w.type === "tableDelimiterRow" ? (r = !0, m = void 0, s = [0, 0, 0, 0], i = [0, a + 1, 0, 0], o && (o = !1, d = {
      type: "tableBody",
      start: Object.assign({}, w.start),
      // Note: correct end is set later.
      end: Object.assign({}, w.end)
    }, h.add(a, 0, [["enter", d, t]])), n = w.type === "tableDelimiterRow" ? 2 : d ? 3 : 1) : n && (w.type === "data" || w.type === "tableDelimiterMarker" || w.type === "tableDelimiterFiller") ? (r = !1, i[2] === 0 && (s[1] !== 0 && (i[0] = i[1], m = ln(h, t, s, n, void 0, m), s = [0, 0, 0, 0]), i[2] = a)) : w.type === "tableCellDivider" && (r ? r = !1 : (s[1] !== 0 && (i[0] = i[1], m = ln(h, t, s, n, void 0, m)), s = i, i = [s[1], a, 0, 0])) : w.type === "tableHead" ? (o = !0, c = a) : w.type === "tableRow" || w.type === "tableDelimiterRow" ? (c = a, s[1] !== 0 ? (i[0] = i[1], m = ln(h, t, s, n, a, m)) : i[1] !== 0 && (m = ln(h, t, i, n, a, m)), n = 0) : n && (w.type === "data" || w.type === "tableDelimiterMarker" || w.type === "tableDelimiterFiller") && (i[3] = a);
  }
  for (c !== 0 && lc(h, t, c, u, d), h.consume(t.events), a = -1; ++a < t.events.length; ) {
    const y = t.events[a];
    y[0] === "enter" && y[1].type === "table" && (y[1]._align = Yg(t.events, a));
  }
  return e;
}
function ln(e, t, a, r, n, s) {
  const i = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", o = "tableContent";
  a[0] !== 0 && (s.end = Object.assign({}, Za(t.events, a[0])), e.add(a[0], 0, [["exit", s, t]]));
  const c = Za(t.events, a[1]);
  if (s = {
    type: i,
    start: Object.assign({}, c),
    // Note: correct end is set later.
    end: Object.assign({}, c)
  }, e.add(a[1], 0, [["enter", s, t]]), a[2] !== 0) {
    const u = Za(t.events, a[2]), d = Za(t.events, a[3]), m = {
      type: o,
      start: Object.assign({}, u),
      end: Object.assign({}, d)
    };
    if (e.add(a[2], 0, [["enter", m, t]]), r !== 2) {
      const h = t.events[a[2]], y = t.events[a[3]];
      if (h[1].end = Object.assign({}, y[1].end), h[1].type = "chunkText", h[1].contentType = "text", a[3] > a[2] + 1) {
        const w = a[2] + 1, v = a[3] - a[2] - 1;
        e.add(w, v, []);
      }
    }
    e.add(a[3] + 1, 0, [["exit", m, t]]);
  }
  return n !== void 0 && (s.end = Object.assign({}, Za(t.events, n)), e.add(n, 0, [["exit", s, t]]), s = void 0), s;
}
function lc(e, t, a, r, n) {
  const s = [], i = Za(t.events, a);
  n && (n.end = Object.assign({}, i), s.push(["exit", n, t])), r.end = Object.assign({}, i), s.push(["exit", r, t]), e.add(a + 1, 0, s);
}
function Za(e, t) {
  const a = e[t], r = a[0] === "enter" ? "start" : "end";
  return a[1][r];
}
const $g = {
  name: "tasklistCheck",
  tokenize: Qg
};
function Xg() {
  return {
    text: {
      91: $g
    }
  };
}
function Qg(e, t, a) {
  const r = this;
  return n;
  function n(c) {
    return (
      // Exit if theres stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? a(c) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(c), e.exit("taskListCheckMarker"), s)
    );
  }
  function s(c) {
    return Oe(c) ? (e.enter("taskListCheckValueUnchecked"), e.consume(c), e.exit("taskListCheckValueUnchecked"), i) : c === 88 || c === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(c), e.exit("taskListCheckValueChecked"), i) : a(c);
  }
  function i(c) {
    return c === 93 ? (e.enter("taskListCheckMarker"), e.consume(c), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), o) : a(c);
  }
  function o(c) {
    return le(c) ? t(c) : Ae(c) ? e.check({
      tokenize: Kg
    }, t, a)(c) : a(c);
  }
}
function Kg(e, t, a) {
  return xe(e, r, "whitespace");
  function r(n) {
    return n === null ? a(n) : t(n);
  }
}
function Jg(e) {
  return Ol([
    Tg(),
    Rg(),
    Ug(e),
    Vg(),
    Xg()
  ]);
}
const Zg = {};
function ey(e) {
  const t = (
    /** @type {Processor} */
    this
  ), a = e || Zg, r = t.data(), n = r.micromarkExtensions || (r.micromarkExtensions = []), s = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), i = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  n.push(Jg(a)), s.push(bg()), i.push(kg(a));
}
function ty() {
  return {
    enter: {
      mathFlow: e,
      mathFlowFenceMeta: t,
      mathText: s
    },
    exit: {
      mathFlow: n,
      mathFlowFence: r,
      mathFlowFenceMeta: a,
      mathFlowValue: o,
      mathText: i,
      mathTextData: o
    }
  };
  function e(c) {
    const u = {
      type: "element",
      tagName: "code",
      properties: { className: ["language-math", "math-display"] },
      children: []
    };
    this.enter(
      {
        type: "math",
        meta: null,
        value: "",
        data: { hName: "pre", hChildren: [u] }
      },
      c
    );
  }
  function t() {
    this.buffer();
  }
  function a() {
    const c = this.resume(), u = this.stack[this.stack.length - 1];
    u.type, u.meta = c;
  }
  function r() {
    this.data.mathFlowInside || (this.buffer(), this.data.mathFlowInside = !0);
  }
  function n(c) {
    const u = this.resume().replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), d = this.stack[this.stack.length - 1];
    d.type, this.exit(c), d.value = u;
    const m = (
      /** @type {HastElement} */
      d.data.hChildren[0]
    );
    m.type, m.tagName, m.children.push({ type: "text", value: u }), this.data.mathFlowInside = void 0;
  }
  function s(c) {
    this.enter(
      {
        type: "inlineMath",
        value: "",
        data: {
          hName: "code",
          hProperties: { className: ["language-math", "math-inline"] },
          hChildren: []
        }
      },
      c
    ), this.buffer();
  }
  function i(c) {
    const u = this.resume(), d = this.stack[this.stack.length - 1];
    d.type, this.exit(c), d.value = u, /** @type {Array<HastElementContent>} */
    // @ts-expect-error: we defined it in `enterMathFlow`.
    d.data.hChildren.push({ type: "text", value: u });
  }
  function o(c) {
    this.config.enter.data.call(this, c), this.config.exit.data.call(this, c);
  }
}
function ay(e) {
  let t = (e || {}).singleDollarTextMath;
  return t == null && (t = !0), r.peek = n, {
    unsafe: [
      { character: "\r", inConstruct: "mathFlowMeta" },
      { character: `
`, inConstruct: "mathFlowMeta" },
      {
        character: "$",
        after: t ? void 0 : "\\$",
        inConstruct: "phrasing"
      },
      { character: "$", inConstruct: "mathFlowMeta" },
      { atBreak: !0, character: "$", after: "\\$" }
    ],
    handlers: { math: a, inlineMath: r }
  };
  function a(s, i, o, c) {
    const u = s.value || "", d = o.createTracker(c), m = "$".repeat(Math.max(cu(u, "$") + 1, 2)), h = o.enter("mathFlow");
    let y = d.move(m);
    if (s.meta) {
      const w = o.enter("mathFlowMeta");
      y += d.move(
        o.safe(s.meta, {
          after: `
`,
          before: y,
          encode: ["$"],
          ...d.current()
        })
      ), w();
    }
    return y += d.move(`
`), u && (y += d.move(u + `
`)), y += d.move(m), h(), y;
  }
  function r(s, i, o) {
    let c = s.value || "", u = 1;
    for (t || u++; new RegExp("(^|[^$])" + "\\$".repeat(u) + "([^$]|$)").test(c); )
      u++;
    const d = "$".repeat(u);
    // Contains non-space.
    /[^ \r\n]/.test(c) && // Starts with space and ends with space.
    (/^[ \r\n]/.test(c) && /[ \r\n]$/.test(c) || // Starts or ends with dollar.
    /^\$|\$$/.test(c)) && (c = " " + c + " ");
    let m = -1;
    for (; ++m < o.unsafe.length; ) {
      const h = o.unsafe[m];
      if (!h.atBreak) continue;
      const y = o.compilePattern(h);
      let w;
      for (; w = y.exec(c); ) {
        let v = w.index;
        c.codePointAt(v) === 10 && c.codePointAt(v - 1) === 13 && v--, c = c.slice(0, v) + " " + c.slice(w.index + 1);
      }
    }
    return d + c + d;
  }
  function n() {
    return "$";
  }
}
const ry = {
  tokenize: ny,
  concrete: !0,
  name: "mathFlow"
}, uc = {
  tokenize: sy,
  partial: !0
};
function ny(e, t, a) {
  const r = this, n = r.events[r.events.length - 1], s = n && n[1].type === "linePrefix" ? n[2].sliceSerialize(n[1], !0).length : 0;
  let i = 0;
  return o;
  function o(C) {
    return e.enter("mathFlow"), e.enter("mathFlowFence"), e.enter("mathFlowFenceSequence"), c(C);
  }
  function c(C) {
    return C === 36 ? (e.consume(C), i++, c) : i < 2 ? a(C) : (e.exit("mathFlowFenceSequence"), xe(e, u, "whitespace")(C));
  }
  function u(C) {
    return C === null || le(C) ? m(C) : (e.enter("mathFlowFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), d(C));
  }
  function d(C) {
    return C === null || le(C) ? (e.exit("chunkString"), e.exit("mathFlowFenceMeta"), m(C)) : C === 36 ? a(C) : (e.consume(C), d);
  }
  function m(C) {
    return e.exit("mathFlowFence"), r.interrupt ? t(C) : e.attempt(uc, h, F)(C);
  }
  function h(C) {
    return e.attempt({
      tokenize: z,
      partial: !0
    }, F, y)(C);
  }
  function y(C) {
    return (s ? xe(e, w, "linePrefix", s + 1) : w)(C);
  }
  function w(C) {
    return C === null ? F(C) : le(C) ? e.attempt(uc, h, F)(C) : (e.enter("mathFlowValue"), v(C));
  }
  function v(C) {
    return C === null || le(C) ? (e.exit("mathFlowValue"), w(C)) : (e.consume(C), v);
  }
  function F(C) {
    return e.exit("mathFlow"), t(C);
  }
  function z(C, U, $) {
    let O = 0;
    return xe(C, p, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
    function p(Z) {
      return C.enter("mathFlowFence"), C.enter("mathFlowFenceSequence"), M(Z);
    }
    function M(Z) {
      return Z === 36 ? (O++, C.consume(Z), M) : O < i ? $(Z) : (C.exit("mathFlowFenceSequence"), xe(C, te, "whitespace")(Z));
    }
    function te(Z) {
      return Z === null || le(Z) ? (C.exit("mathFlowFence"), U(Z)) : $(Z);
    }
  }
}
function sy(e, t, a) {
  const r = this;
  return n;
  function n(i) {
    return i === null ? t(i) : (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), s);
  }
  function s(i) {
    return r.parser.lazy[r.now().line] ? a(i) : t(i);
  }
}
function iy(e) {
  let a = (e || {}).singleDollarTextMath;
  return a == null && (a = !0), {
    tokenize: r,
    resolve: oy,
    previous: cy,
    name: "mathText"
  };
  function r(n, s, i) {
    let o = 0, c, u;
    return d;
    function d(v) {
      return n.enter("mathText"), n.enter("mathTextSequence"), m(v);
    }
    function m(v) {
      return v === 36 ? (n.consume(v), o++, m) : o < 2 && !a ? i(v) : (n.exit("mathTextSequence"), h(v));
    }
    function h(v) {
      return v === null ? i(v) : v === 36 ? (u = n.enter("mathTextSequence"), c = 0, w(v)) : v === 32 ? (n.enter("space"), n.consume(v), n.exit("space"), h) : le(v) ? (n.enter("lineEnding"), n.consume(v), n.exit("lineEnding"), h) : (n.enter("mathTextData"), y(v));
    }
    function y(v) {
      return v === null || v === 32 || v === 36 || le(v) ? (n.exit("mathTextData"), h(v)) : (n.consume(v), y);
    }
    function w(v) {
      return v === 36 ? (n.consume(v), c++, w) : c === o ? (n.exit("mathTextSequence"), n.exit("mathText"), s(v)) : (u.type = "mathTextData", y(v));
    }
  }
}
function oy(e) {
  let t = e.length - 4, a = 3, r, n;
  if ((e[a][1].type === "lineEnding" || e[a][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (r = a; ++r < t; )
      if (e[r][1].type === "mathTextData") {
        e[t][1].type = "mathTextPadding", e[a][1].type = "mathTextPadding", a += 2, t -= 2;
        break;
      }
  }
  for (r = a - 1, t++; ++r <= t; )
    n === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (n = r) : (r === t || e[r][1].type === "lineEnding") && (e[n][1].type = "mathTextData", r !== n + 2 && (e[n][1].end = e[r - 1][1].end, e.splice(n + 2, r - n - 2), t -= r - n - 2, r = n + 2), n = void 0);
  return e;
}
function cy(e) {
  return e !== 36 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function ly(e) {
  return {
    flow: {
      36: ry
    },
    text: {
      36: iy(e)
    }
  };
}
class zt {
  // The + prefix indicates that these fields aren't writeable
  // Lexer holding the input string.
  // Start offset, zero-based inclusive.
  // End offset, zero-based exclusive.
  constructor(t, a, r) {
    this.lexer = void 0, this.start = void 0, this.end = void 0, this.lexer = t, this.start = a, this.end = r;
  }
  /**
   * Merges two `SourceLocation`s from location providers, given they are
   * provided in order of appearance.
   * - Returns the first one's location if only the first is provided.
   * - Returns a merged range of the first and the last if both are provided
   *   and their lexers match.
   * - Otherwise, returns null.
   */
  static range(t, a) {
    return a ? !t || !t.loc || !a.loc || t.loc.lexer !== a.loc.lexer ? null : new zt(t.loc.lexer, t.loc.start, a.loc.end) : t && t.loc;
  }
}
class Pt {
  // don't expand the token
  // used in \noexpand
  constructor(t, a) {
    this.text = void 0, this.loc = void 0, this.noexpand = void 0, this.treatAsRelax = void 0, this.text = t, this.loc = a;
  }
  /**
   * Given a pair of tokens (this and endToken), compute a `Token` encompassing
   * the whole input range enclosed by these two.
   */
  range(t, a) {
    return new Pt(a, zt.range(this, t));
  }
}
class Q {
  // Error start position based on passed-in Token or ParseNode.
  // Length of affected text based on passed-in Token or ParseNode.
  // The underlying error message without any context added.
  constructor(t, a) {
    this.name = void 0, this.position = void 0, this.length = void 0, this.rawMessage = void 0;
    var r = "KaTeX parse error: " + t, n, s, i = a && a.loc;
    if (i && i.start <= i.end) {
      var o = i.lexer.input;
      n = i.start, s = i.end, n === o.length ? r += " at end of input: " : r += " at position " + (n + 1) + ": ";
      var c = o.slice(n, s).replace(/[^]/g, "$&"), u;
      n > 15 ? u = "" + o.slice(n - 15, n) : u = o.slice(0, n);
      var d;
      s + 15 < o.length ? d = o.slice(s, s + 15) + "" : d = o.slice(s), r += u + c + d;
    }
    var m = new Error(r);
    return m.name = "ParseError", m.__proto__ = Q.prototype, m.position = n, n != null && s != null && (m.length = s - n), m.rawMessage = t, m;
  }
}
Q.prototype.__proto__ = Error.prototype;
var uy = function(t, a) {
  return t.indexOf(a) !== -1;
}, fy = function(t, a) {
  return t === void 0 ? a : t;
}, hy = /([A-Z])/g, dy = function(t) {
  return t.replace(hy, "-$1").toLowerCase();
}, my = {
  "&": "&amp;",
  ">": "&gt;",
  "<": "&lt;",
  '"': "&quot;",
  "'": "&#x27;"
}, py = /[&><"']/g;
function gy(e) {
  return String(e).replace(py, (t) => my[t]);
}
var Cu = function e(t) {
  return t.type === "ordgroup" || t.type === "color" ? t.body.length === 1 ? e(t.body[0]) : t : t.type === "font" ? e(t.body) : t;
}, yy = function(t) {
  var a = Cu(t);
  return a.type === "mathord" || a.type === "textord" || a.type === "atom";
}, _y = function(t) {
  if (!t)
    throw new Error("Expected non-null, but got " + String(t));
  return t;
}, by = function(t) {
  var a = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(t);
  return a ? a[2] !== ":" || !/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(a[1]) ? null : a[1].toLowerCase() : "_relative";
}, me = {
  contains: uy,
  deflt: fy,
  escape: gy,
  hyphenate: dy,
  getBaseElem: Cu,
  isCharacterBox: yy,
  protocolFromUrl: by
}, vn = {
  displayMode: {
    type: "boolean",
    description: "Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.",
    cli: "-d, --display-mode"
  },
  output: {
    type: {
      enum: ["htmlAndMathml", "html", "mathml"]
    },
    description: "Determines the markup language of the output.",
    cli: "-F, --format <type>"
  },
  leqno: {
    type: "boolean",
    description: "Render display math in leqno style (left-justified tags)."
  },
  fleqn: {
    type: "boolean",
    description: "Render display math flush left."
  },
  throwOnError: {
    type: "boolean",
    default: !0,
    cli: "-t, --no-throw-on-error",
    cliDescription: "Render errors (in the color given by --error-color) instead of throwing a ParseError exception when encountering an error."
  },
  errorColor: {
    type: "string",
    default: "#cc0000",
    cli: "-c, --error-color <color>",
    cliDescription: "A color string given in the format 'rgb' or 'rrggbb' (no #). This option determines the color of errors rendered by the -t option.",
    cliProcessor: (e) => "#" + e
  },
  macros: {
    type: "object",
    cli: "-m, --macro <def>",
    cliDescription: "Define custom macro of the form '\\foo:expansion' (use multiple -m arguments for multiple macros).",
    cliDefault: [],
    cliProcessor: (e, t) => (t.push(e), t)
  },
  minRuleThickness: {
    type: "number",
    description: "Specifies a minimum thickness, in ems, for fraction lines, `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, `\\hdashline`, `\\underline`, `\\overline`, and the borders of `\\fbox`, `\\boxed`, and `\\fcolorbox`.",
    processor: (e) => Math.max(0, e),
    cli: "--min-rule-thickness <size>",
    cliProcessor: parseFloat
  },
  colorIsTextColor: {
    type: "boolean",
    description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, instead of LaTeX's one-argument \\color mode change.",
    cli: "-b, --color-is-text-color"
  },
  strict: {
    type: [{
      enum: ["warn", "ignore", "error"]
    }, "boolean", "function"],
    description: "Turn on strict / LaTeX faithfulness mode, which throws an error if the input uses features that are not supported by LaTeX.",
    cli: "-S, --strict",
    cliDefault: !1
  },
  trust: {
    type: ["boolean", "function"],
    description: "Trust the input, enabling all HTML features such as \\url.",
    cli: "-T, --trust"
  },
  maxSize: {
    type: "number",
    default: 1 / 0,
    description: "If non-zero, all user-specified sizes, e.g. in \\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, elements and spaces can be arbitrarily large",
    processor: (e) => Math.max(0, e),
    cli: "-s, --max-size <n>",
    cliProcessor: parseInt
  },
  maxExpand: {
    type: "number",
    default: 1e3,
    description: "Limit the number of macro expansions to the specified number, to prevent e.g. infinite macro loops. If set to Infinity, the macro expander will try to fully expand as in LaTeX.",
    processor: (e) => Math.max(0, e),
    cli: "-e, --max-expand <n>",
    cliProcessor: (e) => e === "Infinity" ? 1 / 0 : parseInt(e)
  },
  globalGroup: {
    type: "boolean",
    cli: !1
  }
};
function ky(e) {
  if (e.default)
    return e.default;
  var t = e.type, a = Array.isArray(t) ? t[0] : t;
  if (typeof a != "string")
    return a.enum[0];
  switch (a) {
    case "boolean":
      return !1;
    case "string":
      return "";
    case "number":
      return 0;
    case "object":
      return {};
  }
}
class Oi {
  constructor(t) {
    this.displayMode = void 0, this.output = void 0, this.leqno = void 0, this.fleqn = void 0, this.throwOnError = void 0, this.errorColor = void 0, this.macros = void 0, this.minRuleThickness = void 0, this.colorIsTextColor = void 0, this.strict = void 0, this.trust = void 0, this.maxSize = void 0, this.maxExpand = void 0, this.globalGroup = void 0, t = t || {};
    for (var a in vn)
      if (vn.hasOwnProperty(a)) {
        var r = vn[a];
        this[a] = t[a] !== void 0 ? r.processor ? r.processor(t[a]) : t[a] : ky(r);
      }
  }
  /**
   * Report nonstrict (non-LaTeX-compatible) input.
   * Can safely not be called if `this.strict` is false in JavaScript.
   */
  reportNonstrict(t, a, r) {
    var n = this.strict;
    if (typeof n == "function" && (n = n(t, a, r)), !(!n || n === "ignore")) {
      if (n === !0 || n === "error")
        throw new Q("LaTeX-incompatible input and strict mode is set to 'error': " + (a + " [" + t + "]"), r);
      n === "warn" ? typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (a + " [" + t + "]")) : typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + n + "': " + a + " [" + t + "]"));
    }
  }
  /**
   * Check whether to apply strict (LaTeX-adhering) behavior for unusual
   * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
   * instead, "error" translates to a return value of `true`, while "ignore"
   * translates to a return value of `false`.  May still print a warning:
   * "warn" prints a warning and returns `false`.
   * This is for the second category of `errorCode`s listed in the README.
   */
  useStrictBehavior(t, a, r) {
    var n = this.strict;
    if (typeof n == "function")
      try {
        n = n(t, a, r);
      } catch {
        n = "error";
      }
    return !n || n === "ignore" ? !1 : n === !0 || n === "error" ? !0 : n === "warn" ? (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (a + " [" + t + "]")), !1) : (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + n + "': " + a + " [" + t + "]")), !1);
  }
  /**
   * Check whether to test potentially dangerous input, and return
   * `true` (trusted) or `false` (untrusted).  The sole argument `context`
   * should be an object with `command` field specifying the relevant LaTeX
   * command (as a string starting with `\`), and any other arguments, etc.
   * If `context` has a `url` field, a `protocol` field will automatically
   * get added by this function (changing the specified object).
   */
  isTrusted(t) {
    if (t.url && !t.protocol) {
      var a = me.protocolFromUrl(t.url);
      if (a == null)
        return !1;
      t.protocol = a;
    }
    var r = typeof this.trust == "function" ? this.trust(t) : this.trust;
    return !!r;
  }
}
class wa {
  constructor(t, a, r) {
    this.id = void 0, this.size = void 0, this.cramped = void 0, this.id = t, this.size = a, this.cramped = r;
  }
  /**
   * Get the style of a superscript given a base in the current style.
   */
  sup() {
    return Kt[wy[this.id]];
  }
  /**
   * Get the style of a subscript given a base in the current style.
   */
  sub() {
    return Kt[Ey[this.id]];
  }
  /**
   * Get the style of a fraction numerator given the fraction in the current
   * style.
   */
  fracNum() {
    return Kt[Ty[this.id]];
  }
  /**
   * Get the style of a fraction denominator given the fraction in the current
   * style.
   */
  fracDen() {
    return Kt[vy[this.id]];
  }
  /**
   * Get the cramped version of a style (in particular, cramping a cramped style
   * doesn't change the style).
   */
  cramp() {
    return Kt[xy[this.id]];
  }
  /**
   * Get a text or display version of this style.
   */
  text() {
    return Kt[Ay[this.id]];
  }
  /**
   * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
   */
  isTight() {
    return this.size >= 2;
  }
}
var Li = 0, In = 1, rr = 2, da = 3, Wr = 4, Mt = 5, nr = 6, _t = 7, Kt = [new wa(Li, 0, !1), new wa(In, 0, !0), new wa(rr, 1, !1), new wa(da, 1, !0), new wa(Wr, 2, !1), new wa(Mt, 2, !0), new wa(nr, 3, !1), new wa(_t, 3, !0)], wy = [Wr, Mt, Wr, Mt, nr, _t, nr, _t], Ey = [Mt, Mt, Mt, Mt, _t, _t, _t, _t], Ty = [rr, da, Wr, Mt, nr, _t, nr, _t], vy = [da, da, Mt, Mt, _t, _t, _t, _t], xy = [In, In, da, da, Mt, Mt, _t, _t], Ay = [Li, In, rr, da, rr, da, rr, da], ge = {
  DISPLAY: Kt[Li],
  TEXT: Kt[rr],
  SCRIPT: Kt[Wr],
  SCRIPTSCRIPT: Kt[nr]
}, ti = [{
  // Latin characters beyond the Latin-1 characters we have metrics for.
  // Needed for Czech, Hungarian and Turkish text, for example.
  name: "latin",
  blocks: [
    [256, 591],
    // Latin Extended-A and Latin Extended-B
    [768, 879]
    // Combining Diacritical marks
  ]
}, {
  // The Cyrillic script used by Russian and related languages.
  // A Cyrillic subset used to be supported as explicitly defined
  // symbols in symbols.js
  name: "cyrillic",
  blocks: [[1024, 1279]]
}, {
  // Armenian
  name: "armenian",
  blocks: [[1328, 1423]]
}, {
  // The Brahmic scripts of South and Southeast Asia
  // Devanagari (0900097F)
  // Bengali (098009FF)
  // Gurmukhi (0A000A7F)
  // Gujarati (0A800AFF)
  // Oriya (0B000B7F)
  // Tamil (0B800BFF)
  // Telugu (0C000C7F)
  // Kannada (0C800CFF)
  // Malayalam (0D000D7F)
  // Sinhala (0D800DFF)
  // Thai (0E000E7F)
  // Lao (0E800EFF)
  // Tibetan (0F000FFF)
  // Myanmar (1000109F)
  name: "brahmic",
  blocks: [[2304, 4255]]
}, {
  name: "georgian",
  blocks: [[4256, 4351]]
}, {
  // Chinese and Japanese.
  // The "k" in cjk is for Korean, but we've separated Korean out
  name: "cjk",
  blocks: [
    [12288, 12543],
    // CJK symbols and punctuation, Hiragana, Katakana
    [19968, 40879],
    // CJK ideograms
    [65280, 65376]
    // Fullwidth punctuation
    // TODO: add halfwidth Katakana and Romanji glyphs
  ]
}, {
  // Korean
  name: "hangul",
  blocks: [[44032, 55215]]
}];
function Dy(e) {
  for (var t = 0; t < ti.length; t++)
    for (var a = ti[t], r = 0; r < a.blocks.length; r++) {
      var n = a.blocks[r];
      if (e >= n[0] && e <= n[1])
        return a.name;
    }
  return null;
}
var xn = [];
ti.forEach((e) => e.blocks.forEach((t) => xn.push(...t)));
function Su(e) {
  for (var t = 0; t < xn.length; t += 2)
    if (e >= xn[t] && e <= xn[t + 1])
      return !0;
  return !1;
}
var Ja = 80, Cy = function(t, a) {
  return "M95," + (622 + t + a) + `
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l` + t / 2.075 + " -" + t + `
c5.3,-9.3,12,-14,20,-14
H400000v` + (40 + t) + `H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M` + (834 + t) + " " + a + "h400000v" + (40 + t) + "h-400000z";
}, Sy = function(t, a) {
  return "M263," + (601 + t + a) + `c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l` + t / 2.084 + " -" + t + `
c4.7,-7.3,11,-11,19,-11
H40000v` + (40 + t) + `H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M` + (1001 + t) + " " + a + "h400000v" + (40 + t) + "h-400000z";
}, zy = function(t, a) {
  return "M983 " + (10 + t + a) + `
l` + t / 3.13 + " -" + t + `
c4,-6.7,10,-10,18,-10 H400000v` + (40 + t) + `
H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7
s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744
c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30
c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722
c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5
c53.7,-170.3,84.5,-266.8,92.5,-289.5z
M` + (1001 + t) + " " + a + "h400000v" + (40 + t) + "h-400000z";
}, Ny = function(t, a) {
  return "M424," + (2398 + t + a) + `
c-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514
c0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20
s-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121
s209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081
l` + t / 4.223 + " -" + t + `c4,-6.7,10,-10,18,-10 H400000
v` + (40 + t) + `H1014.6
s-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185
c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2z M` + (1001 + t) + " " + a + `
h400000v` + (40 + t) + "h-400000z";
}, Iy = function(t, a) {
  return "M473," + (2713 + t + a) + `
c339.3,-1799.3,509.3,-2700,510,-2702 l` + t / 5.298 + " -" + t + `
c3.3,-7.3,9.3,-11,18,-11 H400000v` + (40 + t) + `H1017.7
s-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200
c0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26
s76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,
606zM` + (1001 + t) + " " + a + "h400000v" + (40 + t) + "H1017.7z";
}, Ry = function(t) {
  var a = t / 2;
  return "M400000 " + t + " H0 L" + a + " 0 l65 45 L145 " + (t - 80) + " H400000z";
}, Fy = function(t, a, r) {
  var n = r - 54 - a - t;
  return "M702 " + (t + a) + "H400000" + (40 + t) + `
H742v` + n + `l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1
h-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170
c-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667
219 661 l218 661zM702 ` + a + "H400000v" + (40 + t) + "H742z";
}, Oy = function(t, a, r) {
  a = 1e3 * a;
  var n = "";
  switch (t) {
    case "sqrtMain":
      n = Cy(a, Ja);
      break;
    case "sqrtSize1":
      n = Sy(a, Ja);
      break;
    case "sqrtSize2":
      n = zy(a, Ja);
      break;
    case "sqrtSize3":
      n = Ny(a, Ja);
      break;
    case "sqrtSize4":
      n = Iy(a, Ja);
      break;
    case "sqrtTall":
      n = Fy(a, Ja, r);
  }
  return n;
}, Ly = function(t, a) {
  switch (t) {
    case "":
      return "M291 0 H417 V" + a + " H291z M291 0 H417 V" + a + " H291z";
    case "":
      return "M145 0 H188 V" + a + " H145z M145 0 H188 V" + a + " H145z";
    case "":
      return "M145 0 H188 V" + a + " H145z M145 0 H188 V" + a + " H145z" + ("M367 0 H410 V" + a + " H367z M367 0 H410 V" + a + " H367z");
    case "":
      return "M457 0 H583 V" + a + " H457z M457 0 H583 V" + a + " H457z";
    case "":
      return "M319 0 H403 V" + a + " H319z M319 0 H403 V" + a + " H319z";
    case "":
      return "M263 0 H347 V" + a + " H263z M263 0 H347 V" + a + " H263z";
    case "":
      return "M384 0 H504 V" + a + " H384z M384 0 H504 V" + a + " H384z";
    case "":
      return "M312 0 H355 V" + a + " H312z M312 0 H355 V" + a + " H312z";
    case "":
      return "M257 0 H300 V" + a + " H257z M257 0 H300 V" + a + " H257z" + ("M478 0 H521 V" + a + " H478z M478 0 H521 V" + a + " H478z");
    default:
      return "";
  }
}, fc = {
  // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
  doubleleftarrow: `M262 157
l10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3
 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28
 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5
c2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5
 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87
-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7
-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z
m8 0v40h399730v-40zm0 194v40h399730v-40z`,
  // doublerightarrow is from glyph U+21D2 in font KaTeX Main
  doublerightarrow: `M399738 392l
-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5
 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88
-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68
-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18
-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782
c-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3
-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z`,
  // leftarrow is from glyph U+2190 in font KaTeX Main
  leftarrow: `M400000 241H110l3-3c68.7-52.7 113.7-120
 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8
-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247
c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208
 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3
 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202
 l-3-3h399890zM100 241v40h399900v-40z`,
  // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
  leftbrace: `M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117
-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7
 5-6 9-10 13-.7 1-7.3 1-20 1H6z`,
  leftbraceunder: `M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z`,
  // overgroup is from the MnSymbol package (public domain)
  leftgroup: `M400000 80
H435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0
 435 0h399565z`,
  leftgroupunder: `M400000 262
H435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219
 435 219h399565z`,
  // Harpoons are from glyph U+21BD in font KaTeX Main
  leftharpoon: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3
-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5
-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7
-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z`,
  leftharpoonplus: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5
 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3
-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7
-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z
m0 0v40h400000v-40z`,
  leftharpoondown: `M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333
 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5
 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667
-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z`,
  leftharpoondownplus: `M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12
 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7
-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0
v40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z`,
  // hook is from glyph U+21A9 in font KaTeX Main
  lefthook: `M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5
-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3
-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21
 71.5 23h399859zM103 281v-40h399897v40z`,
  leftlinesegment: `M40 281 V428 H0 V94 H40 V241 H400000 v40z
M40 281 V428 H0 V94 H40 V241 H400000 v40z`,
  leftmapsto: `M40 281 V448H0V74H40V241H400000v40z
M40 281 V448H0V74H40V241H400000v40z`,
  // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
  leftToFrom: `M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23
-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8
c28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3
 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z`,
  longequal: `M0 50 h400000 v40H0z m0 194h40000v40H0z
M0 50 h400000 v40H0z m0 194h40000v40H0z`,
  midbrace: `M200428 334
c-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14
-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7
 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11
 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z`,
  midbraceunder: `M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z`,
  oiintSize1: `M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6
-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z
m368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8
60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z`,
  oiintSize2: `M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8
-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z
m502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2
c0 110 84 276 504 276s502.4-166 502.4-276z`,
  oiiintSize1: `M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6
-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z
m525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0
85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z`,
  oiiintSize2: `M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8
-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z
m770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1
c0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z`,
  rightarrow: `M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z`,
  rightbrace: `M400000 542l
-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5
s-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1
c124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z`,
  rightbraceunder: `M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z`,
  rightgroup: `M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0
 3-1 3-3v-38c-76-158-257-219-435-219H0z`,
  rightgroupunder: `M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18
 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z`,
  rightharpoon: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3
-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2
-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58
 69.2 92 94.5zm0 0v40h399900v-40z`,
  rightharpoonplus: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11
-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7
 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z
m0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z`,
  rightharpoondown: `M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8
 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5
-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95
-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z`,
  rightharpoondownplus: `M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8
 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3
 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3
-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z
m0-194v40h400000v-40zm0 0v40h400000v-40z`,
  righthook: `M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3
 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0
-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21
 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z`,
  rightlinesegment: `M399960 241 V94 h40 V428 h-40 V281 H0 v-40z
M399960 241 V94 h40 V428 h-40 V281 H0 v-40z`,
  rightToFrom: `M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23
 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32
-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142
-167z M100 147v40h399900v-40zM0 341v40h399900v-40z`,
  // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
  twoheadleftarrow: `M0 167c68 40
 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69
-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3
-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19
-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101
 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z`,
  twoheadrightarrow: `M400000 167
c-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3
 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42
 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333
-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70
 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z`,
  // tilde1 is a modified version of a glyph from the MnSymbol package
  tilde1: `M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z`,
  // ditto tilde2, tilde3, & tilde4
  tilde2: `M344 55.266c-142 0-300.638 81.316-311.5 86.418
-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9
 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114
c1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751
 181.476 676 181.476c-149 0-189-126.21-332-126.21z`,
  tilde3: `M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457
-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0
 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697
 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696
 -338 0-409-156.573-744-156.573z`,
  tilde4: `M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345
-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409
 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9
 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409
 -175.236-744-175.236z`,
  // vec is from glyph U+20D7 in font KaTeX Main
  vec: `M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z`,
  // widehat1 is a modified version of a glyph from the MnSymbol package
  widehat1: `M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z`,
  // ditto widehat2, widehat3, & widehat4
  widehat2: `M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  widehat3: `M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  widehat4: `M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  // widecheck paths are all inverted versions of widehat
  widecheck1: `M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,
-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z`,
  widecheck2: `M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  widecheck3: `M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  widecheck4: `M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  // The next ten paths support reaction arrows from the mhchem package.
  // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
  // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main
  baraboveleftarrow: `M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202
c4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5
c-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130
s-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47
121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6
s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11
c0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z
M100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z`,
  // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
  rightarrowabovebar: `M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32
-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0
13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39
-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5
-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z`,
  // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
  // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
  baraboveshortleftharpoon: `M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17
c2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21
c-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40
c-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z
M0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z`,
  rightharpoonaboveshortbar: `M0,241 l0,40c399126,0,399993,0,399993,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z`,
  shortbaraboveleftharpoon: `M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,
1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,
-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z
M93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z`,
  shortrightharpoonabovebar: `M53,241l0,40c398570,0,399437,0,399437,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z`
}, My = function(t, a) {
  switch (t) {
    case "lbrack":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + a + ` v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v` + a + " v1759 h84z";
    case "rbrack":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + a + ` v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v` + a + " v1759 h84z";
    case "vert":
      return "M145 15 v585 v" + a + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -a + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + a + " v585 h43z";
    case "doublevert":
      return "M145 15 v585 v" + a + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -a + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + a + ` v585 h43z
M367 15 v585 v` + a + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -a + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M410 15 H367 v585 v` + a + " v585 h43z";
    case "lfloor":
      return "M319 602 V0 H403 V602 v" + a + ` v1715 h263 v84 H319z
MM319 602 V0 H403 V602 v` + a + " v1715 H319z";
    case "rfloor":
      return "M319 602 V0 H403 V602 v" + a + ` v1799 H0 v-84 H319z
MM319 602 V0 H403 V602 v` + a + " v1715 H319z";
    case "lceil":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + a + ` v602 h84z
M403 1759 V0 H319 V1759 v` + a + " v602 h84z";
    case "rceil":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + a + ` v602 h84z
M347 1759 V0 h-84 V1759 v` + a + " v602 h84z";
    case "lparen":
      return `M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1
c-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,
-36,557 l0,` + (a + 84) + `c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,
949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9
c0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,
-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189
l0,-` + (a + 92) + `c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,
-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z`;
    case "rparen":
      return `M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,
63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5
c11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0,` + (a + 9) + `
c-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664
c-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11
c0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17
c242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558
l0,-` + (a + 144) + `c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,
-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z`;
    default:
      throw new Error("Unknown stretchy delimiter.");
  }
};
class en {
  // HtmlDomNode
  // Never used; needed for satisfying interface.
  constructor(t) {
    this.children = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.children = t, this.classes = [], this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = {};
  }
  hasClass(t) {
    return me.contains(this.classes, t);
  }
  /** Convert the fragment into a node. */
  toNode() {
    for (var t = document.createDocumentFragment(), a = 0; a < this.children.length; a++)
      t.appendChild(this.children[a].toNode());
    return t;
  }
  /** Convert the fragment into HTML markup. */
  toMarkup() {
    for (var t = "", a = 0; a < this.children.length; a++)
      t += this.children[a].toMarkup();
    return t;
  }
  /**
   * Converts the math node into a string, similar to innerText. Applies to
   * MathDomNode's only.
   */
  toText() {
    var t = (a) => a.toText();
    return this.children.map(t).join("");
  }
}
var Jt = {
  "AMS-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.68889, 0, 0, 0.72222],
    66: [0, 0.68889, 0, 0, 0.66667],
    67: [0, 0.68889, 0, 0, 0.72222],
    68: [0, 0.68889, 0, 0, 0.72222],
    69: [0, 0.68889, 0, 0, 0.66667],
    70: [0, 0.68889, 0, 0, 0.61111],
    71: [0, 0.68889, 0, 0, 0.77778],
    72: [0, 0.68889, 0, 0, 0.77778],
    73: [0, 0.68889, 0, 0, 0.38889],
    74: [0.16667, 0.68889, 0, 0, 0.5],
    75: [0, 0.68889, 0, 0, 0.77778],
    76: [0, 0.68889, 0, 0, 0.66667],
    77: [0, 0.68889, 0, 0, 0.94445],
    78: [0, 0.68889, 0, 0, 0.72222],
    79: [0.16667, 0.68889, 0, 0, 0.77778],
    80: [0, 0.68889, 0, 0, 0.61111],
    81: [0.16667, 0.68889, 0, 0, 0.77778],
    82: [0, 0.68889, 0, 0, 0.72222],
    83: [0, 0.68889, 0, 0, 0.55556],
    84: [0, 0.68889, 0, 0, 0.66667],
    85: [0, 0.68889, 0, 0, 0.72222],
    86: [0, 0.68889, 0, 0, 0.72222],
    87: [0, 0.68889, 0, 0, 1],
    88: [0, 0.68889, 0, 0, 0.72222],
    89: [0, 0.68889, 0, 0, 0.72222],
    90: [0, 0.68889, 0, 0, 0.66667],
    107: [0, 0.68889, 0, 0, 0.55556],
    160: [0, 0, 0, 0, 0.25],
    165: [0, 0.675, 0.025, 0, 0.75],
    174: [0.15559, 0.69224, 0, 0, 0.94666],
    240: [0, 0.68889, 0, 0, 0.55556],
    295: [0, 0.68889, 0, 0, 0.54028],
    710: [0, 0.825, 0, 0, 2.33334],
    732: [0, 0.9, 0, 0, 2.33334],
    770: [0, 0.825, 0, 0, 2.33334],
    771: [0, 0.9, 0, 0, 2.33334],
    989: [0.08167, 0.58167, 0, 0, 0.77778],
    1008: [0, 0.43056, 0.04028, 0, 0.66667],
    8245: [0, 0.54986, 0, 0, 0.275],
    8463: [0, 0.68889, 0, 0, 0.54028],
    8487: [0, 0.68889, 0, 0, 0.72222],
    8498: [0, 0.68889, 0, 0, 0.55556],
    8502: [0, 0.68889, 0, 0, 0.66667],
    8503: [0, 0.68889, 0, 0, 0.44445],
    8504: [0, 0.68889, 0, 0, 0.66667],
    8513: [0, 0.68889, 0, 0, 0.63889],
    8592: [-0.03598, 0.46402, 0, 0, 0.5],
    8594: [-0.03598, 0.46402, 0, 0, 0.5],
    8602: [-0.13313, 0.36687, 0, 0, 1],
    8603: [-0.13313, 0.36687, 0, 0, 1],
    8606: [0.01354, 0.52239, 0, 0, 1],
    8608: [0.01354, 0.52239, 0, 0, 1],
    8610: [0.01354, 0.52239, 0, 0, 1.11111],
    8611: [0.01354, 0.52239, 0, 0, 1.11111],
    8619: [0, 0.54986, 0, 0, 1],
    8620: [0, 0.54986, 0, 0, 1],
    8621: [-0.13313, 0.37788, 0, 0, 1.38889],
    8622: [-0.13313, 0.36687, 0, 0, 1],
    8624: [0, 0.69224, 0, 0, 0.5],
    8625: [0, 0.69224, 0, 0, 0.5],
    8630: [0, 0.43056, 0, 0, 1],
    8631: [0, 0.43056, 0, 0, 1],
    8634: [0.08198, 0.58198, 0, 0, 0.77778],
    8635: [0.08198, 0.58198, 0, 0, 0.77778],
    8638: [0.19444, 0.69224, 0, 0, 0.41667],
    8639: [0.19444, 0.69224, 0, 0, 0.41667],
    8642: [0.19444, 0.69224, 0, 0, 0.41667],
    8643: [0.19444, 0.69224, 0, 0, 0.41667],
    8644: [0.1808, 0.675, 0, 0, 1],
    8646: [0.1808, 0.675, 0, 0, 1],
    8647: [0.1808, 0.675, 0, 0, 1],
    8648: [0.19444, 0.69224, 0, 0, 0.83334],
    8649: [0.1808, 0.675, 0, 0, 1],
    8650: [0.19444, 0.69224, 0, 0, 0.83334],
    8651: [0.01354, 0.52239, 0, 0, 1],
    8652: [0.01354, 0.52239, 0, 0, 1],
    8653: [-0.13313, 0.36687, 0, 0, 1],
    8654: [-0.13313, 0.36687, 0, 0, 1],
    8655: [-0.13313, 0.36687, 0, 0, 1],
    8666: [0.13667, 0.63667, 0, 0, 1],
    8667: [0.13667, 0.63667, 0, 0, 1],
    8669: [-0.13313, 0.37788, 0, 0, 1],
    8672: [-0.064, 0.437, 0, 0, 1.334],
    8674: [-0.064, 0.437, 0, 0, 1.334],
    8705: [0, 0.825, 0, 0, 0.5],
    8708: [0, 0.68889, 0, 0, 0.55556],
    8709: [0.08167, 0.58167, 0, 0, 0.77778],
    8717: [0, 0.43056, 0, 0, 0.42917],
    8722: [-0.03598, 0.46402, 0, 0, 0.5],
    8724: [0.08198, 0.69224, 0, 0, 0.77778],
    8726: [0.08167, 0.58167, 0, 0, 0.77778],
    8733: [0, 0.69224, 0, 0, 0.77778],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8737: [0, 0.69224, 0, 0, 0.72222],
    8738: [0.03517, 0.52239, 0, 0, 0.72222],
    8739: [0.08167, 0.58167, 0, 0, 0.22222],
    8740: [0.25142, 0.74111, 0, 0, 0.27778],
    8741: [0.08167, 0.58167, 0, 0, 0.38889],
    8742: [0.25142, 0.74111, 0, 0, 0.5],
    8756: [0, 0.69224, 0, 0, 0.66667],
    8757: [0, 0.69224, 0, 0, 0.66667],
    8764: [-0.13313, 0.36687, 0, 0, 0.77778],
    8765: [-0.13313, 0.37788, 0, 0, 0.77778],
    8769: [-0.13313, 0.36687, 0, 0, 0.77778],
    8770: [-0.03625, 0.46375, 0, 0, 0.77778],
    8774: [0.30274, 0.79383, 0, 0, 0.77778],
    8776: [-0.01688, 0.48312, 0, 0, 0.77778],
    8778: [0.08167, 0.58167, 0, 0, 0.77778],
    8782: [0.06062, 0.54986, 0, 0, 0.77778],
    8783: [0.06062, 0.54986, 0, 0, 0.77778],
    8785: [0.08198, 0.58198, 0, 0, 0.77778],
    8786: [0.08198, 0.58198, 0, 0, 0.77778],
    8787: [0.08198, 0.58198, 0, 0, 0.77778],
    8790: [0, 0.69224, 0, 0, 0.77778],
    8791: [0.22958, 0.72958, 0, 0, 0.77778],
    8796: [0.08198, 0.91667, 0, 0, 0.77778],
    8806: [0.25583, 0.75583, 0, 0, 0.77778],
    8807: [0.25583, 0.75583, 0, 0, 0.77778],
    8808: [0.25142, 0.75726, 0, 0, 0.77778],
    8809: [0.25142, 0.75726, 0, 0, 0.77778],
    8812: [0.25583, 0.75583, 0, 0, 0.5],
    8814: [0.20576, 0.70576, 0, 0, 0.77778],
    8815: [0.20576, 0.70576, 0, 0, 0.77778],
    8816: [0.30274, 0.79383, 0, 0, 0.77778],
    8817: [0.30274, 0.79383, 0, 0, 0.77778],
    8818: [0.22958, 0.72958, 0, 0, 0.77778],
    8819: [0.22958, 0.72958, 0, 0, 0.77778],
    8822: [0.1808, 0.675, 0, 0, 0.77778],
    8823: [0.1808, 0.675, 0, 0, 0.77778],
    8828: [0.13667, 0.63667, 0, 0, 0.77778],
    8829: [0.13667, 0.63667, 0, 0, 0.77778],
    8830: [0.22958, 0.72958, 0, 0, 0.77778],
    8831: [0.22958, 0.72958, 0, 0, 0.77778],
    8832: [0.20576, 0.70576, 0, 0, 0.77778],
    8833: [0.20576, 0.70576, 0, 0, 0.77778],
    8840: [0.30274, 0.79383, 0, 0, 0.77778],
    8841: [0.30274, 0.79383, 0, 0, 0.77778],
    8842: [0.13597, 0.63597, 0, 0, 0.77778],
    8843: [0.13597, 0.63597, 0, 0, 0.77778],
    8847: [0.03517, 0.54986, 0, 0, 0.77778],
    8848: [0.03517, 0.54986, 0, 0, 0.77778],
    8858: [0.08198, 0.58198, 0, 0, 0.77778],
    8859: [0.08198, 0.58198, 0, 0, 0.77778],
    8861: [0.08198, 0.58198, 0, 0, 0.77778],
    8862: [0, 0.675, 0, 0, 0.77778],
    8863: [0, 0.675, 0, 0, 0.77778],
    8864: [0, 0.675, 0, 0, 0.77778],
    8865: [0, 0.675, 0, 0, 0.77778],
    8872: [0, 0.69224, 0, 0, 0.61111],
    8873: [0, 0.69224, 0, 0, 0.72222],
    8874: [0, 0.69224, 0, 0, 0.88889],
    8876: [0, 0.68889, 0, 0, 0.61111],
    8877: [0, 0.68889, 0, 0, 0.61111],
    8878: [0, 0.68889, 0, 0, 0.72222],
    8879: [0, 0.68889, 0, 0, 0.72222],
    8882: [0.03517, 0.54986, 0, 0, 0.77778],
    8883: [0.03517, 0.54986, 0, 0, 0.77778],
    8884: [0.13667, 0.63667, 0, 0, 0.77778],
    8885: [0.13667, 0.63667, 0, 0, 0.77778],
    8888: [0, 0.54986, 0, 0, 1.11111],
    8890: [0.19444, 0.43056, 0, 0, 0.55556],
    8891: [0.19444, 0.69224, 0, 0, 0.61111],
    8892: [0.19444, 0.69224, 0, 0, 0.61111],
    8901: [0, 0.54986, 0, 0, 0.27778],
    8903: [0.08167, 0.58167, 0, 0, 0.77778],
    8905: [0.08167, 0.58167, 0, 0, 0.77778],
    8906: [0.08167, 0.58167, 0, 0, 0.77778],
    8907: [0, 0.69224, 0, 0, 0.77778],
    8908: [0, 0.69224, 0, 0, 0.77778],
    8909: [-0.03598, 0.46402, 0, 0, 0.77778],
    8910: [0, 0.54986, 0, 0, 0.76042],
    8911: [0, 0.54986, 0, 0, 0.76042],
    8912: [0.03517, 0.54986, 0, 0, 0.77778],
    8913: [0.03517, 0.54986, 0, 0, 0.77778],
    8914: [0, 0.54986, 0, 0, 0.66667],
    8915: [0, 0.54986, 0, 0, 0.66667],
    8916: [0, 0.69224, 0, 0, 0.66667],
    8918: [0.0391, 0.5391, 0, 0, 0.77778],
    8919: [0.0391, 0.5391, 0, 0, 0.77778],
    8920: [0.03517, 0.54986, 0, 0, 1.33334],
    8921: [0.03517, 0.54986, 0, 0, 1.33334],
    8922: [0.38569, 0.88569, 0, 0, 0.77778],
    8923: [0.38569, 0.88569, 0, 0, 0.77778],
    8926: [0.13667, 0.63667, 0, 0, 0.77778],
    8927: [0.13667, 0.63667, 0, 0, 0.77778],
    8928: [0.30274, 0.79383, 0, 0, 0.77778],
    8929: [0.30274, 0.79383, 0, 0, 0.77778],
    8934: [0.23222, 0.74111, 0, 0, 0.77778],
    8935: [0.23222, 0.74111, 0, 0, 0.77778],
    8936: [0.23222, 0.74111, 0, 0, 0.77778],
    8937: [0.23222, 0.74111, 0, 0, 0.77778],
    8938: [0.20576, 0.70576, 0, 0, 0.77778],
    8939: [0.20576, 0.70576, 0, 0, 0.77778],
    8940: [0.30274, 0.79383, 0, 0, 0.77778],
    8941: [0.30274, 0.79383, 0, 0, 0.77778],
    8994: [0.19444, 0.69224, 0, 0, 0.77778],
    8995: [0.19444, 0.69224, 0, 0, 0.77778],
    9416: [0.15559, 0.69224, 0, 0, 0.90222],
    9484: [0, 0.69224, 0, 0, 0.5],
    9488: [0, 0.69224, 0, 0, 0.5],
    9492: [0, 0.37788, 0, 0, 0.5],
    9496: [0, 0.37788, 0, 0, 0.5],
    9585: [0.19444, 0.68889, 0, 0, 0.88889],
    9586: [0.19444, 0.74111, 0, 0, 0.88889],
    9632: [0, 0.675, 0, 0, 0.77778],
    9633: [0, 0.675, 0, 0, 0.77778],
    9650: [0, 0.54986, 0, 0, 0.72222],
    9651: [0, 0.54986, 0, 0, 0.72222],
    9654: [0.03517, 0.54986, 0, 0, 0.77778],
    9660: [0, 0.54986, 0, 0, 0.72222],
    9661: [0, 0.54986, 0, 0, 0.72222],
    9664: [0.03517, 0.54986, 0, 0, 0.77778],
    9674: [0.11111, 0.69224, 0, 0, 0.66667],
    9733: [0.19444, 0.69224, 0, 0, 0.94445],
    10003: [0, 0.69224, 0, 0, 0.83334],
    10016: [0, 0.69224, 0, 0, 0.83334],
    10731: [0.11111, 0.69224, 0, 0, 0.66667],
    10846: [0.19444, 0.75583, 0, 0, 0.61111],
    10877: [0.13667, 0.63667, 0, 0, 0.77778],
    10878: [0.13667, 0.63667, 0, 0, 0.77778],
    10885: [0.25583, 0.75583, 0, 0, 0.77778],
    10886: [0.25583, 0.75583, 0, 0, 0.77778],
    10887: [0.13597, 0.63597, 0, 0, 0.77778],
    10888: [0.13597, 0.63597, 0, 0, 0.77778],
    10889: [0.26167, 0.75726, 0, 0, 0.77778],
    10890: [0.26167, 0.75726, 0, 0, 0.77778],
    10891: [0.48256, 0.98256, 0, 0, 0.77778],
    10892: [0.48256, 0.98256, 0, 0, 0.77778],
    10901: [0.13667, 0.63667, 0, 0, 0.77778],
    10902: [0.13667, 0.63667, 0, 0, 0.77778],
    10933: [0.25142, 0.75726, 0, 0, 0.77778],
    10934: [0.25142, 0.75726, 0, 0, 0.77778],
    10935: [0.26167, 0.75726, 0, 0, 0.77778],
    10936: [0.26167, 0.75726, 0, 0, 0.77778],
    10937: [0.26167, 0.75726, 0, 0, 0.77778],
    10938: [0.26167, 0.75726, 0, 0, 0.77778],
    10949: [0.25583, 0.75583, 0, 0, 0.77778],
    10950: [0.25583, 0.75583, 0, 0, 0.77778],
    10955: [0.28481, 0.79383, 0, 0, 0.77778],
    10956: [0.28481, 0.79383, 0, 0, 0.77778],
    57350: [0.08167, 0.58167, 0, 0, 0.22222],
    57351: [0.08167, 0.58167, 0, 0, 0.38889],
    57352: [0.08167, 0.58167, 0, 0, 0.77778],
    57353: [0, 0.43056, 0.04028, 0, 0.66667],
    57356: [0.25142, 0.75726, 0, 0, 0.77778],
    57357: [0.25142, 0.75726, 0, 0, 0.77778],
    57358: [0.41951, 0.91951, 0, 0, 0.77778],
    57359: [0.30274, 0.79383, 0, 0, 0.77778],
    57360: [0.30274, 0.79383, 0, 0, 0.77778],
    57361: [0.41951, 0.91951, 0, 0, 0.77778],
    57366: [0.25142, 0.75726, 0, 0, 0.77778],
    57367: [0.25142, 0.75726, 0, 0, 0.77778],
    57368: [0.25142, 0.75726, 0, 0, 0.77778],
    57369: [0.25142, 0.75726, 0, 0, 0.77778],
    57370: [0.13597, 0.63597, 0, 0, 0.77778],
    57371: [0.13597, 0.63597, 0, 0, 0.77778]
  },
  "Caligraphic-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.68333, 0, 0.19445, 0.79847],
    66: [0, 0.68333, 0.03041, 0.13889, 0.65681],
    67: [0, 0.68333, 0.05834, 0.13889, 0.52653],
    68: [0, 0.68333, 0.02778, 0.08334, 0.77139],
    69: [0, 0.68333, 0.08944, 0.11111, 0.52778],
    70: [0, 0.68333, 0.09931, 0.11111, 0.71875],
    71: [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
    72: [0, 0.68333, 965e-5, 0.11111, 0.84452],
    73: [0, 0.68333, 0.07382, 0, 0.54452],
    74: [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
    75: [0, 0.68333, 0.01445, 0.05556, 0.76195],
    76: [0, 0.68333, 0, 0.13889, 0.68972],
    77: [0, 0.68333, 0, 0.13889, 1.2009],
    78: [0, 0.68333, 0.14736, 0.08334, 0.82049],
    79: [0, 0.68333, 0.02778, 0.11111, 0.79611],
    80: [0, 0.68333, 0.08222, 0.08334, 0.69556],
    81: [0.09722, 0.68333, 0, 0.11111, 0.81667],
    82: [0, 0.68333, 0, 0.08334, 0.8475],
    83: [0, 0.68333, 0.075, 0.13889, 0.60556],
    84: [0, 0.68333, 0.25417, 0, 0.54464],
    85: [0, 0.68333, 0.09931, 0.08334, 0.62583],
    86: [0, 0.68333, 0.08222, 0, 0.61278],
    87: [0, 0.68333, 0.08222, 0.08334, 0.98778],
    88: [0, 0.68333, 0.14643, 0.13889, 0.7133],
    89: [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
    90: [0, 0.68333, 0.07944, 0.13889, 0.72473],
    160: [0, 0, 0, 0, 0.25]
  },
  "Fraktur-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69141, 0, 0, 0.29574],
    34: [0, 0.69141, 0, 0, 0.21471],
    38: [0, 0.69141, 0, 0, 0.73786],
    39: [0, 0.69141, 0, 0, 0.21201],
    40: [0.24982, 0.74947, 0, 0, 0.38865],
    41: [0.24982, 0.74947, 0, 0, 0.38865],
    42: [0, 0.62119, 0, 0, 0.27764],
    43: [0.08319, 0.58283, 0, 0, 0.75623],
    44: [0, 0.10803, 0, 0, 0.27764],
    45: [0.08319, 0.58283, 0, 0, 0.75623],
    46: [0, 0.10803, 0, 0, 0.27764],
    47: [0.24982, 0.74947, 0, 0, 0.50181],
    48: [0, 0.47534, 0, 0, 0.50181],
    49: [0, 0.47534, 0, 0, 0.50181],
    50: [0, 0.47534, 0, 0, 0.50181],
    51: [0.18906, 0.47534, 0, 0, 0.50181],
    52: [0.18906, 0.47534, 0, 0, 0.50181],
    53: [0.18906, 0.47534, 0, 0, 0.50181],
    54: [0, 0.69141, 0, 0, 0.50181],
    55: [0.18906, 0.47534, 0, 0, 0.50181],
    56: [0, 0.69141, 0, 0, 0.50181],
    57: [0.18906, 0.47534, 0, 0, 0.50181],
    58: [0, 0.47534, 0, 0, 0.21606],
    59: [0.12604, 0.47534, 0, 0, 0.21606],
    61: [-0.13099, 0.36866, 0, 0, 0.75623],
    63: [0, 0.69141, 0, 0, 0.36245],
    65: [0, 0.69141, 0, 0, 0.7176],
    66: [0, 0.69141, 0, 0, 0.88397],
    67: [0, 0.69141, 0, 0, 0.61254],
    68: [0, 0.69141, 0, 0, 0.83158],
    69: [0, 0.69141, 0, 0, 0.66278],
    70: [0.12604, 0.69141, 0, 0, 0.61119],
    71: [0, 0.69141, 0, 0, 0.78539],
    72: [0.06302, 0.69141, 0, 0, 0.7203],
    73: [0, 0.69141, 0, 0, 0.55448],
    74: [0.12604, 0.69141, 0, 0, 0.55231],
    75: [0, 0.69141, 0, 0, 0.66845],
    76: [0, 0.69141, 0, 0, 0.66602],
    77: [0, 0.69141, 0, 0, 1.04953],
    78: [0, 0.69141, 0, 0, 0.83212],
    79: [0, 0.69141, 0, 0, 0.82699],
    80: [0.18906, 0.69141, 0, 0, 0.82753],
    81: [0.03781, 0.69141, 0, 0, 0.82699],
    82: [0, 0.69141, 0, 0, 0.82807],
    83: [0, 0.69141, 0, 0, 0.82861],
    84: [0, 0.69141, 0, 0, 0.66899],
    85: [0, 0.69141, 0, 0, 0.64576],
    86: [0, 0.69141, 0, 0, 0.83131],
    87: [0, 0.69141, 0, 0, 1.04602],
    88: [0, 0.69141, 0, 0, 0.71922],
    89: [0.18906, 0.69141, 0, 0, 0.83293],
    90: [0.12604, 0.69141, 0, 0, 0.60201],
    91: [0.24982, 0.74947, 0, 0, 0.27764],
    93: [0.24982, 0.74947, 0, 0, 0.27764],
    94: [0, 0.69141, 0, 0, 0.49965],
    97: [0, 0.47534, 0, 0, 0.50046],
    98: [0, 0.69141, 0, 0, 0.51315],
    99: [0, 0.47534, 0, 0, 0.38946],
    100: [0, 0.62119, 0, 0, 0.49857],
    101: [0, 0.47534, 0, 0, 0.40053],
    102: [0.18906, 0.69141, 0, 0, 0.32626],
    103: [0.18906, 0.47534, 0, 0, 0.5037],
    104: [0.18906, 0.69141, 0, 0, 0.52126],
    105: [0, 0.69141, 0, 0, 0.27899],
    106: [0, 0.69141, 0, 0, 0.28088],
    107: [0, 0.69141, 0, 0, 0.38946],
    108: [0, 0.69141, 0, 0, 0.27953],
    109: [0, 0.47534, 0, 0, 0.76676],
    110: [0, 0.47534, 0, 0, 0.52666],
    111: [0, 0.47534, 0, 0, 0.48885],
    112: [0.18906, 0.52396, 0, 0, 0.50046],
    113: [0.18906, 0.47534, 0, 0, 0.48912],
    114: [0, 0.47534, 0, 0, 0.38919],
    115: [0, 0.47534, 0, 0, 0.44266],
    116: [0, 0.62119, 0, 0, 0.33301],
    117: [0, 0.47534, 0, 0, 0.5172],
    118: [0, 0.52396, 0, 0, 0.5118],
    119: [0, 0.52396, 0, 0, 0.77351],
    120: [0.18906, 0.47534, 0, 0, 0.38865],
    121: [0.18906, 0.47534, 0, 0, 0.49884],
    122: [0.18906, 0.47534, 0, 0, 0.39054],
    160: [0, 0, 0, 0, 0.25],
    8216: [0, 0.69141, 0, 0, 0.21471],
    8217: [0, 0.69141, 0, 0, 0.21471],
    58112: [0, 0.62119, 0, 0, 0.49749],
    58113: [0, 0.62119, 0, 0, 0.4983],
    58114: [0.18906, 0.69141, 0, 0, 0.33328],
    58115: [0.18906, 0.69141, 0, 0, 0.32923],
    58116: [0.18906, 0.47534, 0, 0, 0.50343],
    58117: [0, 0.69141, 0, 0, 0.33301],
    58118: [0, 0.62119, 0, 0, 0.33409],
    58119: [0, 0.47534, 0, 0, 0.50073]
  },
  "Main-Bold": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.35],
    34: [0, 0.69444, 0, 0, 0.60278],
    35: [0.19444, 0.69444, 0, 0, 0.95833],
    36: [0.05556, 0.75, 0, 0, 0.575],
    37: [0.05556, 0.75, 0, 0, 0.95833],
    38: [0, 0.69444, 0, 0, 0.89444],
    39: [0, 0.69444, 0, 0, 0.31944],
    40: [0.25, 0.75, 0, 0, 0.44722],
    41: [0.25, 0.75, 0, 0, 0.44722],
    42: [0, 0.75, 0, 0, 0.575],
    43: [0.13333, 0.63333, 0, 0, 0.89444],
    44: [0.19444, 0.15556, 0, 0, 0.31944],
    45: [0, 0.44444, 0, 0, 0.38333],
    46: [0, 0.15556, 0, 0, 0.31944],
    47: [0.25, 0.75, 0, 0, 0.575],
    48: [0, 0.64444, 0, 0, 0.575],
    49: [0, 0.64444, 0, 0, 0.575],
    50: [0, 0.64444, 0, 0, 0.575],
    51: [0, 0.64444, 0, 0, 0.575],
    52: [0, 0.64444, 0, 0, 0.575],
    53: [0, 0.64444, 0, 0, 0.575],
    54: [0, 0.64444, 0, 0, 0.575],
    55: [0, 0.64444, 0, 0, 0.575],
    56: [0, 0.64444, 0, 0, 0.575],
    57: [0, 0.64444, 0, 0, 0.575],
    58: [0, 0.44444, 0, 0, 0.31944],
    59: [0.19444, 0.44444, 0, 0, 0.31944],
    60: [0.08556, 0.58556, 0, 0, 0.89444],
    61: [-0.10889, 0.39111, 0, 0, 0.89444],
    62: [0.08556, 0.58556, 0, 0, 0.89444],
    63: [0, 0.69444, 0, 0, 0.54305],
    64: [0, 0.69444, 0, 0, 0.89444],
    65: [0, 0.68611, 0, 0, 0.86944],
    66: [0, 0.68611, 0, 0, 0.81805],
    67: [0, 0.68611, 0, 0, 0.83055],
    68: [0, 0.68611, 0, 0, 0.88194],
    69: [0, 0.68611, 0, 0, 0.75555],
    70: [0, 0.68611, 0, 0, 0.72361],
    71: [0, 0.68611, 0, 0, 0.90416],
    72: [0, 0.68611, 0, 0, 0.9],
    73: [0, 0.68611, 0, 0, 0.43611],
    74: [0, 0.68611, 0, 0, 0.59444],
    75: [0, 0.68611, 0, 0, 0.90138],
    76: [0, 0.68611, 0, 0, 0.69166],
    77: [0, 0.68611, 0, 0, 1.09166],
    78: [0, 0.68611, 0, 0, 0.9],
    79: [0, 0.68611, 0, 0, 0.86388],
    80: [0, 0.68611, 0, 0, 0.78611],
    81: [0.19444, 0.68611, 0, 0, 0.86388],
    82: [0, 0.68611, 0, 0, 0.8625],
    83: [0, 0.68611, 0, 0, 0.63889],
    84: [0, 0.68611, 0, 0, 0.8],
    85: [0, 0.68611, 0, 0, 0.88472],
    86: [0, 0.68611, 0.01597, 0, 0.86944],
    87: [0, 0.68611, 0.01597, 0, 1.18888],
    88: [0, 0.68611, 0, 0, 0.86944],
    89: [0, 0.68611, 0.02875, 0, 0.86944],
    90: [0, 0.68611, 0, 0, 0.70277],
    91: [0.25, 0.75, 0, 0, 0.31944],
    92: [0.25, 0.75, 0, 0, 0.575],
    93: [0.25, 0.75, 0, 0, 0.31944],
    94: [0, 0.69444, 0, 0, 0.575],
    95: [0.31, 0.13444, 0.03194, 0, 0.575],
    97: [0, 0.44444, 0, 0, 0.55902],
    98: [0, 0.69444, 0, 0, 0.63889],
    99: [0, 0.44444, 0, 0, 0.51111],
    100: [0, 0.69444, 0, 0, 0.63889],
    101: [0, 0.44444, 0, 0, 0.52708],
    102: [0, 0.69444, 0.10903, 0, 0.35139],
    103: [0.19444, 0.44444, 0.01597, 0, 0.575],
    104: [0, 0.69444, 0, 0, 0.63889],
    105: [0, 0.69444, 0, 0, 0.31944],
    106: [0.19444, 0.69444, 0, 0, 0.35139],
    107: [0, 0.69444, 0, 0, 0.60694],
    108: [0, 0.69444, 0, 0, 0.31944],
    109: [0, 0.44444, 0, 0, 0.95833],
    110: [0, 0.44444, 0, 0, 0.63889],
    111: [0, 0.44444, 0, 0, 0.575],
    112: [0.19444, 0.44444, 0, 0, 0.63889],
    113: [0.19444, 0.44444, 0, 0, 0.60694],
    114: [0, 0.44444, 0, 0, 0.47361],
    115: [0, 0.44444, 0, 0, 0.45361],
    116: [0, 0.63492, 0, 0, 0.44722],
    117: [0, 0.44444, 0, 0, 0.63889],
    118: [0, 0.44444, 0.01597, 0, 0.60694],
    119: [0, 0.44444, 0.01597, 0, 0.83055],
    120: [0, 0.44444, 0, 0, 0.60694],
    121: [0.19444, 0.44444, 0.01597, 0, 0.60694],
    122: [0, 0.44444, 0, 0, 0.51111],
    123: [0.25, 0.75, 0, 0, 0.575],
    124: [0.25, 0.75, 0, 0, 0.31944],
    125: [0.25, 0.75, 0, 0, 0.575],
    126: [0.35, 0.34444, 0, 0, 0.575],
    160: [0, 0, 0, 0, 0.25],
    163: [0, 0.69444, 0, 0, 0.86853],
    168: [0, 0.69444, 0, 0, 0.575],
    172: [0, 0.44444, 0, 0, 0.76666],
    176: [0, 0.69444, 0, 0, 0.86944],
    177: [0.13333, 0.63333, 0, 0, 0.89444],
    184: [0.17014, 0, 0, 0, 0.51111],
    198: [0, 0.68611, 0, 0, 1.04166],
    215: [0.13333, 0.63333, 0, 0, 0.89444],
    216: [0.04861, 0.73472, 0, 0, 0.89444],
    223: [0, 0.69444, 0, 0, 0.59722],
    230: [0, 0.44444, 0, 0, 0.83055],
    247: [0.13333, 0.63333, 0, 0, 0.89444],
    248: [0.09722, 0.54167, 0, 0, 0.575],
    305: [0, 0.44444, 0, 0, 0.31944],
    338: [0, 0.68611, 0, 0, 1.16944],
    339: [0, 0.44444, 0, 0, 0.89444],
    567: [0.19444, 0.44444, 0, 0, 0.35139],
    710: [0, 0.69444, 0, 0, 0.575],
    711: [0, 0.63194, 0, 0, 0.575],
    713: [0, 0.59611, 0, 0, 0.575],
    714: [0, 0.69444, 0, 0, 0.575],
    715: [0, 0.69444, 0, 0, 0.575],
    728: [0, 0.69444, 0, 0, 0.575],
    729: [0, 0.69444, 0, 0, 0.31944],
    730: [0, 0.69444, 0, 0, 0.86944],
    732: [0, 0.69444, 0, 0, 0.575],
    733: [0, 0.69444, 0, 0, 0.575],
    915: [0, 0.68611, 0, 0, 0.69166],
    916: [0, 0.68611, 0, 0, 0.95833],
    920: [0, 0.68611, 0, 0, 0.89444],
    923: [0, 0.68611, 0, 0, 0.80555],
    926: [0, 0.68611, 0, 0, 0.76666],
    928: [0, 0.68611, 0, 0, 0.9],
    931: [0, 0.68611, 0, 0, 0.83055],
    933: [0, 0.68611, 0, 0, 0.89444],
    934: [0, 0.68611, 0, 0, 0.83055],
    936: [0, 0.68611, 0, 0, 0.89444],
    937: [0, 0.68611, 0, 0, 0.83055],
    8211: [0, 0.44444, 0.03194, 0, 0.575],
    8212: [0, 0.44444, 0.03194, 0, 1.14999],
    8216: [0, 0.69444, 0, 0, 0.31944],
    8217: [0, 0.69444, 0, 0, 0.31944],
    8220: [0, 0.69444, 0, 0, 0.60278],
    8221: [0, 0.69444, 0, 0, 0.60278],
    8224: [0.19444, 0.69444, 0, 0, 0.51111],
    8225: [0.19444, 0.69444, 0, 0, 0.51111],
    8242: [0, 0.55556, 0, 0, 0.34444],
    8407: [0, 0.72444, 0.15486, 0, 0.575],
    8463: [0, 0.69444, 0, 0, 0.66759],
    8465: [0, 0.69444, 0, 0, 0.83055],
    8467: [0, 0.69444, 0, 0, 0.47361],
    8472: [0.19444, 0.44444, 0, 0, 0.74027],
    8476: [0, 0.69444, 0, 0, 0.83055],
    8501: [0, 0.69444, 0, 0, 0.70277],
    8592: [-0.10889, 0.39111, 0, 0, 1.14999],
    8593: [0.19444, 0.69444, 0, 0, 0.575],
    8594: [-0.10889, 0.39111, 0, 0, 1.14999],
    8595: [0.19444, 0.69444, 0, 0, 0.575],
    8596: [-0.10889, 0.39111, 0, 0, 1.14999],
    8597: [0.25, 0.75, 0, 0, 0.575],
    8598: [0.19444, 0.69444, 0, 0, 1.14999],
    8599: [0.19444, 0.69444, 0, 0, 1.14999],
    8600: [0.19444, 0.69444, 0, 0, 1.14999],
    8601: [0.19444, 0.69444, 0, 0, 1.14999],
    8636: [-0.10889, 0.39111, 0, 0, 1.14999],
    8637: [-0.10889, 0.39111, 0, 0, 1.14999],
    8640: [-0.10889, 0.39111, 0, 0, 1.14999],
    8641: [-0.10889, 0.39111, 0, 0, 1.14999],
    8656: [-0.10889, 0.39111, 0, 0, 1.14999],
    8657: [0.19444, 0.69444, 0, 0, 0.70277],
    8658: [-0.10889, 0.39111, 0, 0, 1.14999],
    8659: [0.19444, 0.69444, 0, 0, 0.70277],
    8660: [-0.10889, 0.39111, 0, 0, 1.14999],
    8661: [0.25, 0.75, 0, 0, 0.70277],
    8704: [0, 0.69444, 0, 0, 0.63889],
    8706: [0, 0.69444, 0.06389, 0, 0.62847],
    8707: [0, 0.69444, 0, 0, 0.63889],
    8709: [0.05556, 0.75, 0, 0, 0.575],
    8711: [0, 0.68611, 0, 0, 0.95833],
    8712: [0.08556, 0.58556, 0, 0, 0.76666],
    8715: [0.08556, 0.58556, 0, 0, 0.76666],
    8722: [0.13333, 0.63333, 0, 0, 0.89444],
    8723: [0.13333, 0.63333, 0, 0, 0.89444],
    8725: [0.25, 0.75, 0, 0, 0.575],
    8726: [0.25, 0.75, 0, 0, 0.575],
    8727: [-0.02778, 0.47222, 0, 0, 0.575],
    8728: [-0.02639, 0.47361, 0, 0, 0.575],
    8729: [-0.02639, 0.47361, 0, 0, 0.575],
    8730: [0.18, 0.82, 0, 0, 0.95833],
    8733: [0, 0.44444, 0, 0, 0.89444],
    8734: [0, 0.44444, 0, 0, 1.14999],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8739: [0.25, 0.75, 0, 0, 0.31944],
    8741: [0.25, 0.75, 0, 0, 0.575],
    8743: [0, 0.55556, 0, 0, 0.76666],
    8744: [0, 0.55556, 0, 0, 0.76666],
    8745: [0, 0.55556, 0, 0, 0.76666],
    8746: [0, 0.55556, 0, 0, 0.76666],
    8747: [0.19444, 0.69444, 0.12778, 0, 0.56875],
    8764: [-0.10889, 0.39111, 0, 0, 0.89444],
    8768: [0.19444, 0.69444, 0, 0, 0.31944],
    8771: [222e-5, 0.50222, 0, 0, 0.89444],
    8773: [0.027, 0.638, 0, 0, 0.894],
    8776: [0.02444, 0.52444, 0, 0, 0.89444],
    8781: [222e-5, 0.50222, 0, 0, 0.89444],
    8801: [222e-5, 0.50222, 0, 0, 0.89444],
    8804: [0.19667, 0.69667, 0, 0, 0.89444],
    8805: [0.19667, 0.69667, 0, 0, 0.89444],
    8810: [0.08556, 0.58556, 0, 0, 1.14999],
    8811: [0.08556, 0.58556, 0, 0, 1.14999],
    8826: [0.08556, 0.58556, 0, 0, 0.89444],
    8827: [0.08556, 0.58556, 0, 0, 0.89444],
    8834: [0.08556, 0.58556, 0, 0, 0.89444],
    8835: [0.08556, 0.58556, 0, 0, 0.89444],
    8838: [0.19667, 0.69667, 0, 0, 0.89444],
    8839: [0.19667, 0.69667, 0, 0, 0.89444],
    8846: [0, 0.55556, 0, 0, 0.76666],
    8849: [0.19667, 0.69667, 0, 0, 0.89444],
    8850: [0.19667, 0.69667, 0, 0, 0.89444],
    8851: [0, 0.55556, 0, 0, 0.76666],
    8852: [0, 0.55556, 0, 0, 0.76666],
    8853: [0.13333, 0.63333, 0, 0, 0.89444],
    8854: [0.13333, 0.63333, 0, 0, 0.89444],
    8855: [0.13333, 0.63333, 0, 0, 0.89444],
    8856: [0.13333, 0.63333, 0, 0, 0.89444],
    8857: [0.13333, 0.63333, 0, 0, 0.89444],
    8866: [0, 0.69444, 0, 0, 0.70277],
    8867: [0, 0.69444, 0, 0, 0.70277],
    8868: [0, 0.69444, 0, 0, 0.89444],
    8869: [0, 0.69444, 0, 0, 0.89444],
    8900: [-0.02639, 0.47361, 0, 0, 0.575],
    8901: [-0.02639, 0.47361, 0, 0, 0.31944],
    8902: [-0.02778, 0.47222, 0, 0, 0.575],
    8968: [0.25, 0.75, 0, 0, 0.51111],
    8969: [0.25, 0.75, 0, 0, 0.51111],
    8970: [0.25, 0.75, 0, 0, 0.51111],
    8971: [0.25, 0.75, 0, 0, 0.51111],
    8994: [-0.13889, 0.36111, 0, 0, 1.14999],
    8995: [-0.13889, 0.36111, 0, 0, 1.14999],
    9651: [0.19444, 0.69444, 0, 0, 1.02222],
    9657: [-0.02778, 0.47222, 0, 0, 0.575],
    9661: [0.19444, 0.69444, 0, 0, 1.02222],
    9667: [-0.02778, 0.47222, 0, 0, 0.575],
    9711: [0.19444, 0.69444, 0, 0, 1.14999],
    9824: [0.12963, 0.69444, 0, 0, 0.89444],
    9825: [0.12963, 0.69444, 0, 0, 0.89444],
    9826: [0.12963, 0.69444, 0, 0, 0.89444],
    9827: [0.12963, 0.69444, 0, 0, 0.89444],
    9837: [0, 0.75, 0, 0, 0.44722],
    9838: [0.19444, 0.69444, 0, 0, 0.44722],
    9839: [0.19444, 0.69444, 0, 0, 0.44722],
    10216: [0.25, 0.75, 0, 0, 0.44722],
    10217: [0.25, 0.75, 0, 0, 0.44722],
    10815: [0, 0.68611, 0, 0, 0.9],
    10927: [0.19667, 0.69667, 0, 0, 0.89444],
    10928: [0.19667, 0.69667, 0, 0, 0.89444],
    57376: [0.19444, 0.69444, 0, 0, 0]
  },
  "Main-BoldItalic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.11417, 0, 0.38611],
    34: [0, 0.69444, 0.07939, 0, 0.62055],
    35: [0.19444, 0.69444, 0.06833, 0, 0.94444],
    37: [0.05556, 0.75, 0.12861, 0, 0.94444],
    38: [0, 0.69444, 0.08528, 0, 0.88555],
    39: [0, 0.69444, 0.12945, 0, 0.35555],
    40: [0.25, 0.75, 0.15806, 0, 0.47333],
    41: [0.25, 0.75, 0.03306, 0, 0.47333],
    42: [0, 0.75, 0.14333, 0, 0.59111],
    43: [0.10333, 0.60333, 0.03306, 0, 0.88555],
    44: [0.19444, 0.14722, 0, 0, 0.35555],
    45: [0, 0.44444, 0.02611, 0, 0.41444],
    46: [0, 0.14722, 0, 0, 0.35555],
    47: [0.25, 0.75, 0.15806, 0, 0.59111],
    48: [0, 0.64444, 0.13167, 0, 0.59111],
    49: [0, 0.64444, 0.13167, 0, 0.59111],
    50: [0, 0.64444, 0.13167, 0, 0.59111],
    51: [0, 0.64444, 0.13167, 0, 0.59111],
    52: [0.19444, 0.64444, 0.13167, 0, 0.59111],
    53: [0, 0.64444, 0.13167, 0, 0.59111],
    54: [0, 0.64444, 0.13167, 0, 0.59111],
    55: [0.19444, 0.64444, 0.13167, 0, 0.59111],
    56: [0, 0.64444, 0.13167, 0, 0.59111],
    57: [0, 0.64444, 0.13167, 0, 0.59111],
    58: [0, 0.44444, 0.06695, 0, 0.35555],
    59: [0.19444, 0.44444, 0.06695, 0, 0.35555],
    61: [-0.10889, 0.39111, 0.06833, 0, 0.88555],
    63: [0, 0.69444, 0.11472, 0, 0.59111],
    64: [0, 0.69444, 0.09208, 0, 0.88555],
    65: [0, 0.68611, 0, 0, 0.86555],
    66: [0, 0.68611, 0.0992, 0, 0.81666],
    67: [0, 0.68611, 0.14208, 0, 0.82666],
    68: [0, 0.68611, 0.09062, 0, 0.87555],
    69: [0, 0.68611, 0.11431, 0, 0.75666],
    70: [0, 0.68611, 0.12903, 0, 0.72722],
    71: [0, 0.68611, 0.07347, 0, 0.89527],
    72: [0, 0.68611, 0.17208, 0, 0.8961],
    73: [0, 0.68611, 0.15681, 0, 0.47166],
    74: [0, 0.68611, 0.145, 0, 0.61055],
    75: [0, 0.68611, 0.14208, 0, 0.89499],
    76: [0, 0.68611, 0, 0, 0.69777],
    77: [0, 0.68611, 0.17208, 0, 1.07277],
    78: [0, 0.68611, 0.17208, 0, 0.8961],
    79: [0, 0.68611, 0.09062, 0, 0.85499],
    80: [0, 0.68611, 0.0992, 0, 0.78721],
    81: [0.19444, 0.68611, 0.09062, 0, 0.85499],
    82: [0, 0.68611, 0.02559, 0, 0.85944],
    83: [0, 0.68611, 0.11264, 0, 0.64999],
    84: [0, 0.68611, 0.12903, 0, 0.7961],
    85: [0, 0.68611, 0.17208, 0, 0.88083],
    86: [0, 0.68611, 0.18625, 0, 0.86555],
    87: [0, 0.68611, 0.18625, 0, 1.15999],
    88: [0, 0.68611, 0.15681, 0, 0.86555],
    89: [0, 0.68611, 0.19803, 0, 0.86555],
    90: [0, 0.68611, 0.14208, 0, 0.70888],
    91: [0.25, 0.75, 0.1875, 0, 0.35611],
    93: [0.25, 0.75, 0.09972, 0, 0.35611],
    94: [0, 0.69444, 0.06709, 0, 0.59111],
    95: [0.31, 0.13444, 0.09811, 0, 0.59111],
    97: [0, 0.44444, 0.09426, 0, 0.59111],
    98: [0, 0.69444, 0.07861, 0, 0.53222],
    99: [0, 0.44444, 0.05222, 0, 0.53222],
    100: [0, 0.69444, 0.10861, 0, 0.59111],
    101: [0, 0.44444, 0.085, 0, 0.53222],
    102: [0.19444, 0.69444, 0.21778, 0, 0.4],
    103: [0.19444, 0.44444, 0.105, 0, 0.53222],
    104: [0, 0.69444, 0.09426, 0, 0.59111],
    105: [0, 0.69326, 0.11387, 0, 0.35555],
    106: [0.19444, 0.69326, 0.1672, 0, 0.35555],
    107: [0, 0.69444, 0.11111, 0, 0.53222],
    108: [0, 0.69444, 0.10861, 0, 0.29666],
    109: [0, 0.44444, 0.09426, 0, 0.94444],
    110: [0, 0.44444, 0.09426, 0, 0.64999],
    111: [0, 0.44444, 0.07861, 0, 0.59111],
    112: [0.19444, 0.44444, 0.07861, 0, 0.59111],
    113: [0.19444, 0.44444, 0.105, 0, 0.53222],
    114: [0, 0.44444, 0.11111, 0, 0.50167],
    115: [0, 0.44444, 0.08167, 0, 0.48694],
    116: [0, 0.63492, 0.09639, 0, 0.385],
    117: [0, 0.44444, 0.09426, 0, 0.62055],
    118: [0, 0.44444, 0.11111, 0, 0.53222],
    119: [0, 0.44444, 0.11111, 0, 0.76777],
    120: [0, 0.44444, 0.12583, 0, 0.56055],
    121: [0.19444, 0.44444, 0.105, 0, 0.56166],
    122: [0, 0.44444, 0.13889, 0, 0.49055],
    126: [0.35, 0.34444, 0.11472, 0, 0.59111],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.69444, 0.11473, 0, 0.59111],
    176: [0, 0.69444, 0, 0, 0.94888],
    184: [0.17014, 0, 0, 0, 0.53222],
    198: [0, 0.68611, 0.11431, 0, 1.02277],
    216: [0.04861, 0.73472, 0.09062, 0, 0.88555],
    223: [0.19444, 0.69444, 0.09736, 0, 0.665],
    230: [0, 0.44444, 0.085, 0, 0.82666],
    248: [0.09722, 0.54167, 0.09458, 0, 0.59111],
    305: [0, 0.44444, 0.09426, 0, 0.35555],
    338: [0, 0.68611, 0.11431, 0, 1.14054],
    339: [0, 0.44444, 0.085, 0, 0.82666],
    567: [0.19444, 0.44444, 0.04611, 0, 0.385],
    710: [0, 0.69444, 0.06709, 0, 0.59111],
    711: [0, 0.63194, 0.08271, 0, 0.59111],
    713: [0, 0.59444, 0.10444, 0, 0.59111],
    714: [0, 0.69444, 0.08528, 0, 0.59111],
    715: [0, 0.69444, 0, 0, 0.59111],
    728: [0, 0.69444, 0.10333, 0, 0.59111],
    729: [0, 0.69444, 0.12945, 0, 0.35555],
    730: [0, 0.69444, 0, 0, 0.94888],
    732: [0, 0.69444, 0.11472, 0, 0.59111],
    733: [0, 0.69444, 0.11472, 0, 0.59111],
    915: [0, 0.68611, 0.12903, 0, 0.69777],
    916: [0, 0.68611, 0, 0, 0.94444],
    920: [0, 0.68611, 0.09062, 0, 0.88555],
    923: [0, 0.68611, 0, 0, 0.80666],
    926: [0, 0.68611, 0.15092, 0, 0.76777],
    928: [0, 0.68611, 0.17208, 0, 0.8961],
    931: [0, 0.68611, 0.11431, 0, 0.82666],
    933: [0, 0.68611, 0.10778, 0, 0.88555],
    934: [0, 0.68611, 0.05632, 0, 0.82666],
    936: [0, 0.68611, 0.10778, 0, 0.88555],
    937: [0, 0.68611, 0.0992, 0, 0.82666],
    8211: [0, 0.44444, 0.09811, 0, 0.59111],
    8212: [0, 0.44444, 0.09811, 0, 1.18221],
    8216: [0, 0.69444, 0.12945, 0, 0.35555],
    8217: [0, 0.69444, 0.12945, 0, 0.35555],
    8220: [0, 0.69444, 0.16772, 0, 0.62055],
    8221: [0, 0.69444, 0.07939, 0, 0.62055]
  },
  "Main-Italic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.12417, 0, 0.30667],
    34: [0, 0.69444, 0.06961, 0, 0.51444],
    35: [0.19444, 0.69444, 0.06616, 0, 0.81777],
    37: [0.05556, 0.75, 0.13639, 0, 0.81777],
    38: [0, 0.69444, 0.09694, 0, 0.76666],
    39: [0, 0.69444, 0.12417, 0, 0.30667],
    40: [0.25, 0.75, 0.16194, 0, 0.40889],
    41: [0.25, 0.75, 0.03694, 0, 0.40889],
    42: [0, 0.75, 0.14917, 0, 0.51111],
    43: [0.05667, 0.56167, 0.03694, 0, 0.76666],
    44: [0.19444, 0.10556, 0, 0, 0.30667],
    45: [0, 0.43056, 0.02826, 0, 0.35778],
    46: [0, 0.10556, 0, 0, 0.30667],
    47: [0.25, 0.75, 0.16194, 0, 0.51111],
    48: [0, 0.64444, 0.13556, 0, 0.51111],
    49: [0, 0.64444, 0.13556, 0, 0.51111],
    50: [0, 0.64444, 0.13556, 0, 0.51111],
    51: [0, 0.64444, 0.13556, 0, 0.51111],
    52: [0.19444, 0.64444, 0.13556, 0, 0.51111],
    53: [0, 0.64444, 0.13556, 0, 0.51111],
    54: [0, 0.64444, 0.13556, 0, 0.51111],
    55: [0.19444, 0.64444, 0.13556, 0, 0.51111],
    56: [0, 0.64444, 0.13556, 0, 0.51111],
    57: [0, 0.64444, 0.13556, 0, 0.51111],
    58: [0, 0.43056, 0.0582, 0, 0.30667],
    59: [0.19444, 0.43056, 0.0582, 0, 0.30667],
    61: [-0.13313, 0.36687, 0.06616, 0, 0.76666],
    63: [0, 0.69444, 0.1225, 0, 0.51111],
    64: [0, 0.69444, 0.09597, 0, 0.76666],
    65: [0, 0.68333, 0, 0, 0.74333],
    66: [0, 0.68333, 0.10257, 0, 0.70389],
    67: [0, 0.68333, 0.14528, 0, 0.71555],
    68: [0, 0.68333, 0.09403, 0, 0.755],
    69: [0, 0.68333, 0.12028, 0, 0.67833],
    70: [0, 0.68333, 0.13305, 0, 0.65277],
    71: [0, 0.68333, 0.08722, 0, 0.77361],
    72: [0, 0.68333, 0.16389, 0, 0.74333],
    73: [0, 0.68333, 0.15806, 0, 0.38555],
    74: [0, 0.68333, 0.14028, 0, 0.525],
    75: [0, 0.68333, 0.14528, 0, 0.76888],
    76: [0, 0.68333, 0, 0, 0.62722],
    77: [0, 0.68333, 0.16389, 0, 0.89666],
    78: [0, 0.68333, 0.16389, 0, 0.74333],
    79: [0, 0.68333, 0.09403, 0, 0.76666],
    80: [0, 0.68333, 0.10257, 0, 0.67833],
    81: [0.19444, 0.68333, 0.09403, 0, 0.76666],
    82: [0, 0.68333, 0.03868, 0, 0.72944],
    83: [0, 0.68333, 0.11972, 0, 0.56222],
    84: [0, 0.68333, 0.13305, 0, 0.71555],
    85: [0, 0.68333, 0.16389, 0, 0.74333],
    86: [0, 0.68333, 0.18361, 0, 0.74333],
    87: [0, 0.68333, 0.18361, 0, 0.99888],
    88: [0, 0.68333, 0.15806, 0, 0.74333],
    89: [0, 0.68333, 0.19383, 0, 0.74333],
    90: [0, 0.68333, 0.14528, 0, 0.61333],
    91: [0.25, 0.75, 0.1875, 0, 0.30667],
    93: [0.25, 0.75, 0.10528, 0, 0.30667],
    94: [0, 0.69444, 0.06646, 0, 0.51111],
    95: [0.31, 0.12056, 0.09208, 0, 0.51111],
    97: [0, 0.43056, 0.07671, 0, 0.51111],
    98: [0, 0.69444, 0.06312, 0, 0.46],
    99: [0, 0.43056, 0.05653, 0, 0.46],
    100: [0, 0.69444, 0.10333, 0, 0.51111],
    101: [0, 0.43056, 0.07514, 0, 0.46],
    102: [0.19444, 0.69444, 0.21194, 0, 0.30667],
    103: [0.19444, 0.43056, 0.08847, 0, 0.46],
    104: [0, 0.69444, 0.07671, 0, 0.51111],
    105: [0, 0.65536, 0.1019, 0, 0.30667],
    106: [0.19444, 0.65536, 0.14467, 0, 0.30667],
    107: [0, 0.69444, 0.10764, 0, 0.46],
    108: [0, 0.69444, 0.10333, 0, 0.25555],
    109: [0, 0.43056, 0.07671, 0, 0.81777],
    110: [0, 0.43056, 0.07671, 0, 0.56222],
    111: [0, 0.43056, 0.06312, 0, 0.51111],
    112: [0.19444, 0.43056, 0.06312, 0, 0.51111],
    113: [0.19444, 0.43056, 0.08847, 0, 0.46],
    114: [0, 0.43056, 0.10764, 0, 0.42166],
    115: [0, 0.43056, 0.08208, 0, 0.40889],
    116: [0, 0.61508, 0.09486, 0, 0.33222],
    117: [0, 0.43056, 0.07671, 0, 0.53666],
    118: [0, 0.43056, 0.10764, 0, 0.46],
    119: [0, 0.43056, 0.10764, 0, 0.66444],
    120: [0, 0.43056, 0.12042, 0, 0.46389],
    121: [0.19444, 0.43056, 0.08847, 0, 0.48555],
    122: [0, 0.43056, 0.12292, 0, 0.40889],
    126: [0.35, 0.31786, 0.11585, 0, 0.51111],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.66786, 0.10474, 0, 0.51111],
    176: [0, 0.69444, 0, 0, 0.83129],
    184: [0.17014, 0, 0, 0, 0.46],
    198: [0, 0.68333, 0.12028, 0, 0.88277],
    216: [0.04861, 0.73194, 0.09403, 0, 0.76666],
    223: [0.19444, 0.69444, 0.10514, 0, 0.53666],
    230: [0, 0.43056, 0.07514, 0, 0.71555],
    248: [0.09722, 0.52778, 0.09194, 0, 0.51111],
    338: [0, 0.68333, 0.12028, 0, 0.98499],
    339: [0, 0.43056, 0.07514, 0, 0.71555],
    710: [0, 0.69444, 0.06646, 0, 0.51111],
    711: [0, 0.62847, 0.08295, 0, 0.51111],
    713: [0, 0.56167, 0.10333, 0, 0.51111],
    714: [0, 0.69444, 0.09694, 0, 0.51111],
    715: [0, 0.69444, 0, 0, 0.51111],
    728: [0, 0.69444, 0.10806, 0, 0.51111],
    729: [0, 0.66786, 0.11752, 0, 0.30667],
    730: [0, 0.69444, 0, 0, 0.83129],
    732: [0, 0.66786, 0.11585, 0, 0.51111],
    733: [0, 0.69444, 0.1225, 0, 0.51111],
    915: [0, 0.68333, 0.13305, 0, 0.62722],
    916: [0, 0.68333, 0, 0, 0.81777],
    920: [0, 0.68333, 0.09403, 0, 0.76666],
    923: [0, 0.68333, 0, 0, 0.69222],
    926: [0, 0.68333, 0.15294, 0, 0.66444],
    928: [0, 0.68333, 0.16389, 0, 0.74333],
    931: [0, 0.68333, 0.12028, 0, 0.71555],
    933: [0, 0.68333, 0.11111, 0, 0.76666],
    934: [0, 0.68333, 0.05986, 0, 0.71555],
    936: [0, 0.68333, 0.11111, 0, 0.76666],
    937: [0, 0.68333, 0.10257, 0, 0.71555],
    8211: [0, 0.43056, 0.09208, 0, 0.51111],
    8212: [0, 0.43056, 0.09208, 0, 1.02222],
    8216: [0, 0.69444, 0.12417, 0, 0.30667],
    8217: [0, 0.69444, 0.12417, 0, 0.30667],
    8220: [0, 0.69444, 0.1685, 0, 0.51444],
    8221: [0, 0.69444, 0.06961, 0, 0.51444],
    8463: [0, 0.68889, 0, 0, 0.54028]
  },
  "Main-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.27778],
    34: [0, 0.69444, 0, 0, 0.5],
    35: [0.19444, 0.69444, 0, 0, 0.83334],
    36: [0.05556, 0.75, 0, 0, 0.5],
    37: [0.05556, 0.75, 0, 0, 0.83334],
    38: [0, 0.69444, 0, 0, 0.77778],
    39: [0, 0.69444, 0, 0, 0.27778],
    40: [0.25, 0.75, 0, 0, 0.38889],
    41: [0.25, 0.75, 0, 0, 0.38889],
    42: [0, 0.75, 0, 0, 0.5],
    43: [0.08333, 0.58333, 0, 0, 0.77778],
    44: [0.19444, 0.10556, 0, 0, 0.27778],
    45: [0, 0.43056, 0, 0, 0.33333],
    46: [0, 0.10556, 0, 0, 0.27778],
    47: [0.25, 0.75, 0, 0, 0.5],
    48: [0, 0.64444, 0, 0, 0.5],
    49: [0, 0.64444, 0, 0, 0.5],
    50: [0, 0.64444, 0, 0, 0.5],
    51: [0, 0.64444, 0, 0, 0.5],
    52: [0, 0.64444, 0, 0, 0.5],
    53: [0, 0.64444, 0, 0, 0.5],
    54: [0, 0.64444, 0, 0, 0.5],
    55: [0, 0.64444, 0, 0, 0.5],
    56: [0, 0.64444, 0, 0, 0.5],
    57: [0, 0.64444, 0, 0, 0.5],
    58: [0, 0.43056, 0, 0, 0.27778],
    59: [0.19444, 0.43056, 0, 0, 0.27778],
    60: [0.0391, 0.5391, 0, 0, 0.77778],
    61: [-0.13313, 0.36687, 0, 0, 0.77778],
    62: [0.0391, 0.5391, 0, 0, 0.77778],
    63: [0, 0.69444, 0, 0, 0.47222],
    64: [0, 0.69444, 0, 0, 0.77778],
    65: [0, 0.68333, 0, 0, 0.75],
    66: [0, 0.68333, 0, 0, 0.70834],
    67: [0, 0.68333, 0, 0, 0.72222],
    68: [0, 0.68333, 0, 0, 0.76389],
    69: [0, 0.68333, 0, 0, 0.68056],
    70: [0, 0.68333, 0, 0, 0.65278],
    71: [0, 0.68333, 0, 0, 0.78472],
    72: [0, 0.68333, 0, 0, 0.75],
    73: [0, 0.68333, 0, 0, 0.36111],
    74: [0, 0.68333, 0, 0, 0.51389],
    75: [0, 0.68333, 0, 0, 0.77778],
    76: [0, 0.68333, 0, 0, 0.625],
    77: [0, 0.68333, 0, 0, 0.91667],
    78: [0, 0.68333, 0, 0, 0.75],
    79: [0, 0.68333, 0, 0, 0.77778],
    80: [0, 0.68333, 0, 0, 0.68056],
    81: [0.19444, 0.68333, 0, 0, 0.77778],
    82: [0, 0.68333, 0, 0, 0.73611],
    83: [0, 0.68333, 0, 0, 0.55556],
    84: [0, 0.68333, 0, 0, 0.72222],
    85: [0, 0.68333, 0, 0, 0.75],
    86: [0, 0.68333, 0.01389, 0, 0.75],
    87: [0, 0.68333, 0.01389, 0, 1.02778],
    88: [0, 0.68333, 0, 0, 0.75],
    89: [0, 0.68333, 0.025, 0, 0.75],
    90: [0, 0.68333, 0, 0, 0.61111],
    91: [0.25, 0.75, 0, 0, 0.27778],
    92: [0.25, 0.75, 0, 0, 0.5],
    93: [0.25, 0.75, 0, 0, 0.27778],
    94: [0, 0.69444, 0, 0, 0.5],
    95: [0.31, 0.12056, 0.02778, 0, 0.5],
    97: [0, 0.43056, 0, 0, 0.5],
    98: [0, 0.69444, 0, 0, 0.55556],
    99: [0, 0.43056, 0, 0, 0.44445],
    100: [0, 0.69444, 0, 0, 0.55556],
    101: [0, 0.43056, 0, 0, 0.44445],
    102: [0, 0.69444, 0.07778, 0, 0.30556],
    103: [0.19444, 0.43056, 0.01389, 0, 0.5],
    104: [0, 0.69444, 0, 0, 0.55556],
    105: [0, 0.66786, 0, 0, 0.27778],
    106: [0.19444, 0.66786, 0, 0, 0.30556],
    107: [0, 0.69444, 0, 0, 0.52778],
    108: [0, 0.69444, 0, 0, 0.27778],
    109: [0, 0.43056, 0, 0, 0.83334],
    110: [0, 0.43056, 0, 0, 0.55556],
    111: [0, 0.43056, 0, 0, 0.5],
    112: [0.19444, 0.43056, 0, 0, 0.55556],
    113: [0.19444, 0.43056, 0, 0, 0.52778],
    114: [0, 0.43056, 0, 0, 0.39167],
    115: [0, 0.43056, 0, 0, 0.39445],
    116: [0, 0.61508, 0, 0, 0.38889],
    117: [0, 0.43056, 0, 0, 0.55556],
    118: [0, 0.43056, 0.01389, 0, 0.52778],
    119: [0, 0.43056, 0.01389, 0, 0.72222],
    120: [0, 0.43056, 0, 0, 0.52778],
    121: [0.19444, 0.43056, 0.01389, 0, 0.52778],
    122: [0, 0.43056, 0, 0, 0.44445],
    123: [0.25, 0.75, 0, 0, 0.5],
    124: [0.25, 0.75, 0, 0, 0.27778],
    125: [0.25, 0.75, 0, 0, 0.5],
    126: [0.35, 0.31786, 0, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    163: [0, 0.69444, 0, 0, 0.76909],
    167: [0.19444, 0.69444, 0, 0, 0.44445],
    168: [0, 0.66786, 0, 0, 0.5],
    172: [0, 0.43056, 0, 0, 0.66667],
    176: [0, 0.69444, 0, 0, 0.75],
    177: [0.08333, 0.58333, 0, 0, 0.77778],
    182: [0.19444, 0.69444, 0, 0, 0.61111],
    184: [0.17014, 0, 0, 0, 0.44445],
    198: [0, 0.68333, 0, 0, 0.90278],
    215: [0.08333, 0.58333, 0, 0, 0.77778],
    216: [0.04861, 0.73194, 0, 0, 0.77778],
    223: [0, 0.69444, 0, 0, 0.5],
    230: [0, 0.43056, 0, 0, 0.72222],
    247: [0.08333, 0.58333, 0, 0, 0.77778],
    248: [0.09722, 0.52778, 0, 0, 0.5],
    305: [0, 0.43056, 0, 0, 0.27778],
    338: [0, 0.68333, 0, 0, 1.01389],
    339: [0, 0.43056, 0, 0, 0.77778],
    567: [0.19444, 0.43056, 0, 0, 0.30556],
    710: [0, 0.69444, 0, 0, 0.5],
    711: [0, 0.62847, 0, 0, 0.5],
    713: [0, 0.56778, 0, 0, 0.5],
    714: [0, 0.69444, 0, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0, 0, 0.5],
    729: [0, 0.66786, 0, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.75],
    732: [0, 0.66786, 0, 0, 0.5],
    733: [0, 0.69444, 0, 0, 0.5],
    915: [0, 0.68333, 0, 0, 0.625],
    916: [0, 0.68333, 0, 0, 0.83334],
    920: [0, 0.68333, 0, 0, 0.77778],
    923: [0, 0.68333, 0, 0, 0.69445],
    926: [0, 0.68333, 0, 0, 0.66667],
    928: [0, 0.68333, 0, 0, 0.75],
    931: [0, 0.68333, 0, 0, 0.72222],
    933: [0, 0.68333, 0, 0, 0.77778],
    934: [0, 0.68333, 0, 0, 0.72222],
    936: [0, 0.68333, 0, 0, 0.77778],
    937: [0, 0.68333, 0, 0, 0.72222],
    8211: [0, 0.43056, 0.02778, 0, 0.5],
    8212: [0, 0.43056, 0.02778, 0, 1],
    8216: [0, 0.69444, 0, 0, 0.27778],
    8217: [0, 0.69444, 0, 0, 0.27778],
    8220: [0, 0.69444, 0, 0, 0.5],
    8221: [0, 0.69444, 0, 0, 0.5],
    8224: [0.19444, 0.69444, 0, 0, 0.44445],
    8225: [0.19444, 0.69444, 0, 0, 0.44445],
    8230: [0, 0.123, 0, 0, 1.172],
    8242: [0, 0.55556, 0, 0, 0.275],
    8407: [0, 0.71444, 0.15382, 0, 0.5],
    8463: [0, 0.68889, 0, 0, 0.54028],
    8465: [0, 0.69444, 0, 0, 0.72222],
    8467: [0, 0.69444, 0, 0.11111, 0.41667],
    8472: [0.19444, 0.43056, 0, 0.11111, 0.63646],
    8476: [0, 0.69444, 0, 0, 0.72222],
    8501: [0, 0.69444, 0, 0, 0.61111],
    8592: [-0.13313, 0.36687, 0, 0, 1],
    8593: [0.19444, 0.69444, 0, 0, 0.5],
    8594: [-0.13313, 0.36687, 0, 0, 1],
    8595: [0.19444, 0.69444, 0, 0, 0.5],
    8596: [-0.13313, 0.36687, 0, 0, 1],
    8597: [0.25, 0.75, 0, 0, 0.5],
    8598: [0.19444, 0.69444, 0, 0, 1],
    8599: [0.19444, 0.69444, 0, 0, 1],
    8600: [0.19444, 0.69444, 0, 0, 1],
    8601: [0.19444, 0.69444, 0, 0, 1],
    8614: [0.011, 0.511, 0, 0, 1],
    8617: [0.011, 0.511, 0, 0, 1.126],
    8618: [0.011, 0.511, 0, 0, 1.126],
    8636: [-0.13313, 0.36687, 0, 0, 1],
    8637: [-0.13313, 0.36687, 0, 0, 1],
    8640: [-0.13313, 0.36687, 0, 0, 1],
    8641: [-0.13313, 0.36687, 0, 0, 1],
    8652: [0.011, 0.671, 0, 0, 1],
    8656: [-0.13313, 0.36687, 0, 0, 1],
    8657: [0.19444, 0.69444, 0, 0, 0.61111],
    8658: [-0.13313, 0.36687, 0, 0, 1],
    8659: [0.19444, 0.69444, 0, 0, 0.61111],
    8660: [-0.13313, 0.36687, 0, 0, 1],
    8661: [0.25, 0.75, 0, 0, 0.61111],
    8704: [0, 0.69444, 0, 0, 0.55556],
    8706: [0, 0.69444, 0.05556, 0.08334, 0.5309],
    8707: [0, 0.69444, 0, 0, 0.55556],
    8709: [0.05556, 0.75, 0, 0, 0.5],
    8711: [0, 0.68333, 0, 0, 0.83334],
    8712: [0.0391, 0.5391, 0, 0, 0.66667],
    8715: [0.0391, 0.5391, 0, 0, 0.66667],
    8722: [0.08333, 0.58333, 0, 0, 0.77778],
    8723: [0.08333, 0.58333, 0, 0, 0.77778],
    8725: [0.25, 0.75, 0, 0, 0.5],
    8726: [0.25, 0.75, 0, 0, 0.5],
    8727: [-0.03472, 0.46528, 0, 0, 0.5],
    8728: [-0.05555, 0.44445, 0, 0, 0.5],
    8729: [-0.05555, 0.44445, 0, 0, 0.5],
    8730: [0.2, 0.8, 0, 0, 0.83334],
    8733: [0, 0.43056, 0, 0, 0.77778],
    8734: [0, 0.43056, 0, 0, 1],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8739: [0.25, 0.75, 0, 0, 0.27778],
    8741: [0.25, 0.75, 0, 0, 0.5],
    8743: [0, 0.55556, 0, 0, 0.66667],
    8744: [0, 0.55556, 0, 0, 0.66667],
    8745: [0, 0.55556, 0, 0, 0.66667],
    8746: [0, 0.55556, 0, 0, 0.66667],
    8747: [0.19444, 0.69444, 0.11111, 0, 0.41667],
    8764: [-0.13313, 0.36687, 0, 0, 0.77778],
    8768: [0.19444, 0.69444, 0, 0, 0.27778],
    8771: [-0.03625, 0.46375, 0, 0, 0.77778],
    8773: [-0.022, 0.589, 0, 0, 0.778],
    8776: [-0.01688, 0.48312, 0, 0, 0.77778],
    8781: [-0.03625, 0.46375, 0, 0, 0.77778],
    8784: [-0.133, 0.673, 0, 0, 0.778],
    8801: [-0.03625, 0.46375, 0, 0, 0.77778],
    8804: [0.13597, 0.63597, 0, 0, 0.77778],
    8805: [0.13597, 0.63597, 0, 0, 0.77778],
    8810: [0.0391, 0.5391, 0, 0, 1],
    8811: [0.0391, 0.5391, 0, 0, 1],
    8826: [0.0391, 0.5391, 0, 0, 0.77778],
    8827: [0.0391, 0.5391, 0, 0, 0.77778],
    8834: [0.0391, 0.5391, 0, 0, 0.77778],
    8835: [0.0391, 0.5391, 0, 0, 0.77778],
    8838: [0.13597, 0.63597, 0, 0, 0.77778],
    8839: [0.13597, 0.63597, 0, 0, 0.77778],
    8846: [0, 0.55556, 0, 0, 0.66667],
    8849: [0.13597, 0.63597, 0, 0, 0.77778],
    8850: [0.13597, 0.63597, 0, 0, 0.77778],
    8851: [0, 0.55556, 0, 0, 0.66667],
    8852: [0, 0.55556, 0, 0, 0.66667],
    8853: [0.08333, 0.58333, 0, 0, 0.77778],
    8854: [0.08333, 0.58333, 0, 0, 0.77778],
    8855: [0.08333, 0.58333, 0, 0, 0.77778],
    8856: [0.08333, 0.58333, 0, 0, 0.77778],
    8857: [0.08333, 0.58333, 0, 0, 0.77778],
    8866: [0, 0.69444, 0, 0, 0.61111],
    8867: [0, 0.69444, 0, 0, 0.61111],
    8868: [0, 0.69444, 0, 0, 0.77778],
    8869: [0, 0.69444, 0, 0, 0.77778],
    8872: [0.249, 0.75, 0, 0, 0.867],
    8900: [-0.05555, 0.44445, 0, 0, 0.5],
    8901: [-0.05555, 0.44445, 0, 0, 0.27778],
    8902: [-0.03472, 0.46528, 0, 0, 0.5],
    8904: [5e-3, 0.505, 0, 0, 0.9],
    8942: [0.03, 0.903, 0, 0, 0.278],
    8943: [-0.19, 0.313, 0, 0, 1.172],
    8945: [-0.1, 0.823, 0, 0, 1.282],
    8968: [0.25, 0.75, 0, 0, 0.44445],
    8969: [0.25, 0.75, 0, 0, 0.44445],
    8970: [0.25, 0.75, 0, 0, 0.44445],
    8971: [0.25, 0.75, 0, 0, 0.44445],
    8994: [-0.14236, 0.35764, 0, 0, 1],
    8995: [-0.14236, 0.35764, 0, 0, 1],
    9136: [0.244, 0.744, 0, 0, 0.412],
    9137: [0.244, 0.745, 0, 0, 0.412],
    9651: [0.19444, 0.69444, 0, 0, 0.88889],
    9657: [-0.03472, 0.46528, 0, 0, 0.5],
    9661: [0.19444, 0.69444, 0, 0, 0.88889],
    9667: [-0.03472, 0.46528, 0, 0, 0.5],
    9711: [0.19444, 0.69444, 0, 0, 1],
    9824: [0.12963, 0.69444, 0, 0, 0.77778],
    9825: [0.12963, 0.69444, 0, 0, 0.77778],
    9826: [0.12963, 0.69444, 0, 0, 0.77778],
    9827: [0.12963, 0.69444, 0, 0, 0.77778],
    9837: [0, 0.75, 0, 0, 0.38889],
    9838: [0.19444, 0.69444, 0, 0, 0.38889],
    9839: [0.19444, 0.69444, 0, 0, 0.38889],
    10216: [0.25, 0.75, 0, 0, 0.38889],
    10217: [0.25, 0.75, 0, 0, 0.38889],
    10222: [0.244, 0.744, 0, 0, 0.412],
    10223: [0.244, 0.745, 0, 0, 0.412],
    10229: [0.011, 0.511, 0, 0, 1.609],
    10230: [0.011, 0.511, 0, 0, 1.638],
    10231: [0.011, 0.511, 0, 0, 1.859],
    10232: [0.024, 0.525, 0, 0, 1.609],
    10233: [0.024, 0.525, 0, 0, 1.638],
    10234: [0.024, 0.525, 0, 0, 1.858],
    10236: [0.011, 0.511, 0, 0, 1.638],
    10815: [0, 0.68333, 0, 0, 0.75],
    10927: [0.13597, 0.63597, 0, 0, 0.77778],
    10928: [0.13597, 0.63597, 0, 0, 0.77778],
    57376: [0.19444, 0.69444, 0, 0, 0]
  },
  "Math-BoldItalic": {
    32: [0, 0, 0, 0, 0.25],
    48: [0, 0.44444, 0, 0, 0.575],
    49: [0, 0.44444, 0, 0, 0.575],
    50: [0, 0.44444, 0, 0, 0.575],
    51: [0.19444, 0.44444, 0, 0, 0.575],
    52: [0.19444, 0.44444, 0, 0, 0.575],
    53: [0.19444, 0.44444, 0, 0, 0.575],
    54: [0, 0.64444, 0, 0, 0.575],
    55: [0.19444, 0.44444, 0, 0, 0.575],
    56: [0, 0.64444, 0, 0, 0.575],
    57: [0.19444, 0.44444, 0, 0, 0.575],
    65: [0, 0.68611, 0, 0, 0.86944],
    66: [0, 0.68611, 0.04835, 0, 0.8664],
    67: [0, 0.68611, 0.06979, 0, 0.81694],
    68: [0, 0.68611, 0.03194, 0, 0.93812],
    69: [0, 0.68611, 0.05451, 0, 0.81007],
    70: [0, 0.68611, 0.15972, 0, 0.68889],
    71: [0, 0.68611, 0, 0, 0.88673],
    72: [0, 0.68611, 0.08229, 0, 0.98229],
    73: [0, 0.68611, 0.07778, 0, 0.51111],
    74: [0, 0.68611, 0.10069, 0, 0.63125],
    75: [0, 0.68611, 0.06979, 0, 0.97118],
    76: [0, 0.68611, 0, 0, 0.75555],
    77: [0, 0.68611, 0.11424, 0, 1.14201],
    78: [0, 0.68611, 0.11424, 0, 0.95034],
    79: [0, 0.68611, 0.03194, 0, 0.83666],
    80: [0, 0.68611, 0.15972, 0, 0.72309],
    81: [0.19444, 0.68611, 0, 0, 0.86861],
    82: [0, 0.68611, 421e-5, 0, 0.87235],
    83: [0, 0.68611, 0.05382, 0, 0.69271],
    84: [0, 0.68611, 0.15972, 0, 0.63663],
    85: [0, 0.68611, 0.11424, 0, 0.80027],
    86: [0, 0.68611, 0.25555, 0, 0.67778],
    87: [0, 0.68611, 0.15972, 0, 1.09305],
    88: [0, 0.68611, 0.07778, 0, 0.94722],
    89: [0, 0.68611, 0.25555, 0, 0.67458],
    90: [0, 0.68611, 0.06979, 0, 0.77257],
    97: [0, 0.44444, 0, 0, 0.63287],
    98: [0, 0.69444, 0, 0, 0.52083],
    99: [0, 0.44444, 0, 0, 0.51342],
    100: [0, 0.69444, 0, 0, 0.60972],
    101: [0, 0.44444, 0, 0, 0.55361],
    102: [0.19444, 0.69444, 0.11042, 0, 0.56806],
    103: [0.19444, 0.44444, 0.03704, 0, 0.5449],
    104: [0, 0.69444, 0, 0, 0.66759],
    105: [0, 0.69326, 0, 0, 0.4048],
    106: [0.19444, 0.69326, 0.0622, 0, 0.47083],
    107: [0, 0.69444, 0.01852, 0, 0.6037],
    108: [0, 0.69444, 88e-4, 0, 0.34815],
    109: [0, 0.44444, 0, 0, 1.0324],
    110: [0, 0.44444, 0, 0, 0.71296],
    111: [0, 0.44444, 0, 0, 0.58472],
    112: [0.19444, 0.44444, 0, 0, 0.60092],
    113: [0.19444, 0.44444, 0.03704, 0, 0.54213],
    114: [0, 0.44444, 0.03194, 0, 0.5287],
    115: [0, 0.44444, 0, 0, 0.53125],
    116: [0, 0.63492, 0, 0, 0.41528],
    117: [0, 0.44444, 0, 0, 0.68102],
    118: [0, 0.44444, 0.03704, 0, 0.56666],
    119: [0, 0.44444, 0.02778, 0, 0.83148],
    120: [0, 0.44444, 0, 0, 0.65903],
    121: [0.19444, 0.44444, 0.03704, 0, 0.59028],
    122: [0, 0.44444, 0.04213, 0, 0.55509],
    160: [0, 0, 0, 0, 0.25],
    915: [0, 0.68611, 0.15972, 0, 0.65694],
    916: [0, 0.68611, 0, 0, 0.95833],
    920: [0, 0.68611, 0.03194, 0, 0.86722],
    923: [0, 0.68611, 0, 0, 0.80555],
    926: [0, 0.68611, 0.07458, 0, 0.84125],
    928: [0, 0.68611, 0.08229, 0, 0.98229],
    931: [0, 0.68611, 0.05451, 0, 0.88507],
    933: [0, 0.68611, 0.15972, 0, 0.67083],
    934: [0, 0.68611, 0, 0, 0.76666],
    936: [0, 0.68611, 0.11653, 0, 0.71402],
    937: [0, 0.68611, 0.04835, 0, 0.8789],
    945: [0, 0.44444, 0, 0, 0.76064],
    946: [0.19444, 0.69444, 0.03403, 0, 0.65972],
    947: [0.19444, 0.44444, 0.06389, 0, 0.59003],
    948: [0, 0.69444, 0.03819, 0, 0.52222],
    949: [0, 0.44444, 0, 0, 0.52882],
    950: [0.19444, 0.69444, 0.06215, 0, 0.50833],
    951: [0.19444, 0.44444, 0.03704, 0, 0.6],
    952: [0, 0.69444, 0.03194, 0, 0.5618],
    953: [0, 0.44444, 0, 0, 0.41204],
    954: [0, 0.44444, 0, 0, 0.66759],
    955: [0, 0.69444, 0, 0, 0.67083],
    956: [0.19444, 0.44444, 0, 0, 0.70787],
    957: [0, 0.44444, 0.06898, 0, 0.57685],
    958: [0.19444, 0.69444, 0.03021, 0, 0.50833],
    959: [0, 0.44444, 0, 0, 0.58472],
    960: [0, 0.44444, 0.03704, 0, 0.68241],
    961: [0.19444, 0.44444, 0, 0, 0.6118],
    962: [0.09722, 0.44444, 0.07917, 0, 0.42361],
    963: [0, 0.44444, 0.03704, 0, 0.68588],
    964: [0, 0.44444, 0.13472, 0, 0.52083],
    965: [0, 0.44444, 0.03704, 0, 0.63055],
    966: [0.19444, 0.44444, 0, 0, 0.74722],
    967: [0.19444, 0.44444, 0, 0, 0.71805],
    968: [0.19444, 0.69444, 0.03704, 0, 0.75833],
    969: [0, 0.44444, 0.03704, 0, 0.71782],
    977: [0, 0.69444, 0, 0, 0.69155],
    981: [0.19444, 0.69444, 0, 0, 0.7125],
    982: [0, 0.44444, 0.03194, 0, 0.975],
    1009: [0.19444, 0.44444, 0, 0, 0.6118],
    1013: [0, 0.44444, 0, 0, 0.48333],
    57649: [0, 0.44444, 0, 0, 0.39352],
    57911: [0.19444, 0.44444, 0, 0, 0.43889]
  },
  "Math-Italic": {
    32: [0, 0, 0, 0, 0.25],
    48: [0, 0.43056, 0, 0, 0.5],
    49: [0, 0.43056, 0, 0, 0.5],
    50: [0, 0.43056, 0, 0, 0.5],
    51: [0.19444, 0.43056, 0, 0, 0.5],
    52: [0.19444, 0.43056, 0, 0, 0.5],
    53: [0.19444, 0.43056, 0, 0, 0.5],
    54: [0, 0.64444, 0, 0, 0.5],
    55: [0.19444, 0.43056, 0, 0, 0.5],
    56: [0, 0.64444, 0, 0, 0.5],
    57: [0.19444, 0.43056, 0, 0, 0.5],
    65: [0, 0.68333, 0, 0.13889, 0.75],
    66: [0, 0.68333, 0.05017, 0.08334, 0.75851],
    67: [0, 0.68333, 0.07153, 0.08334, 0.71472],
    68: [0, 0.68333, 0.02778, 0.05556, 0.82792],
    69: [0, 0.68333, 0.05764, 0.08334, 0.7382],
    70: [0, 0.68333, 0.13889, 0.08334, 0.64306],
    71: [0, 0.68333, 0, 0.08334, 0.78625],
    72: [0, 0.68333, 0.08125, 0.05556, 0.83125],
    73: [0, 0.68333, 0.07847, 0.11111, 0.43958],
    74: [0, 0.68333, 0.09618, 0.16667, 0.55451],
    75: [0, 0.68333, 0.07153, 0.05556, 0.84931],
    76: [0, 0.68333, 0, 0.02778, 0.68056],
    77: [0, 0.68333, 0.10903, 0.08334, 0.97014],
    78: [0, 0.68333, 0.10903, 0.08334, 0.80347],
    79: [0, 0.68333, 0.02778, 0.08334, 0.76278],
    80: [0, 0.68333, 0.13889, 0.08334, 0.64201],
    81: [0.19444, 0.68333, 0, 0.08334, 0.79056],
    82: [0, 0.68333, 773e-5, 0.08334, 0.75929],
    83: [0, 0.68333, 0.05764, 0.08334, 0.6132],
    84: [0, 0.68333, 0.13889, 0.08334, 0.58438],
    85: [0, 0.68333, 0.10903, 0.02778, 0.68278],
    86: [0, 0.68333, 0.22222, 0, 0.58333],
    87: [0, 0.68333, 0.13889, 0, 0.94445],
    88: [0, 0.68333, 0.07847, 0.08334, 0.82847],
    89: [0, 0.68333, 0.22222, 0, 0.58056],
    90: [0, 0.68333, 0.07153, 0.08334, 0.68264],
    97: [0, 0.43056, 0, 0, 0.52859],
    98: [0, 0.69444, 0, 0, 0.42917],
    99: [0, 0.43056, 0, 0.05556, 0.43276],
    100: [0, 0.69444, 0, 0.16667, 0.52049],
    101: [0, 0.43056, 0, 0.05556, 0.46563],
    102: [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
    103: [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
    104: [0, 0.69444, 0, 0, 0.57616],
    105: [0, 0.65952, 0, 0, 0.34451],
    106: [0.19444, 0.65952, 0.05724, 0, 0.41181],
    107: [0, 0.69444, 0.03148, 0, 0.5206],
    108: [0, 0.69444, 0.01968, 0.08334, 0.29838],
    109: [0, 0.43056, 0, 0, 0.87801],
    110: [0, 0.43056, 0, 0, 0.60023],
    111: [0, 0.43056, 0, 0.05556, 0.48472],
    112: [0.19444, 0.43056, 0, 0.08334, 0.50313],
    113: [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
    114: [0, 0.43056, 0.02778, 0.05556, 0.45116],
    115: [0, 0.43056, 0, 0.05556, 0.46875],
    116: [0, 0.61508, 0, 0.08334, 0.36111],
    117: [0, 0.43056, 0, 0.02778, 0.57246],
    118: [0, 0.43056, 0.03588, 0.02778, 0.48472],
    119: [0, 0.43056, 0.02691, 0.08334, 0.71592],
    120: [0, 0.43056, 0, 0.02778, 0.57153],
    121: [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
    122: [0, 0.43056, 0.04398, 0.05556, 0.46505],
    160: [0, 0, 0, 0, 0.25],
    915: [0, 0.68333, 0.13889, 0.08334, 0.61528],
    916: [0, 0.68333, 0, 0.16667, 0.83334],
    920: [0, 0.68333, 0.02778, 0.08334, 0.76278],
    923: [0, 0.68333, 0, 0.16667, 0.69445],
    926: [0, 0.68333, 0.07569, 0.08334, 0.74236],
    928: [0, 0.68333, 0.08125, 0.05556, 0.83125],
    931: [0, 0.68333, 0.05764, 0.08334, 0.77986],
    933: [0, 0.68333, 0.13889, 0.05556, 0.58333],
    934: [0, 0.68333, 0, 0.08334, 0.66667],
    936: [0, 0.68333, 0.11, 0.05556, 0.61222],
    937: [0, 0.68333, 0.05017, 0.08334, 0.7724],
    945: [0, 0.43056, 37e-4, 0.02778, 0.6397],
    946: [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
    947: [0.19444, 0.43056, 0.05556, 0, 0.51773],
    948: [0, 0.69444, 0.03785, 0.05556, 0.44444],
    949: [0, 0.43056, 0, 0.08334, 0.46632],
    950: [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
    951: [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
    952: [0, 0.69444, 0.02778, 0.08334, 0.46944],
    953: [0, 0.43056, 0, 0.05556, 0.35394],
    954: [0, 0.43056, 0, 0, 0.57616],
    955: [0, 0.69444, 0, 0, 0.58334],
    956: [0.19444, 0.43056, 0, 0.02778, 0.60255],
    957: [0, 0.43056, 0.06366, 0.02778, 0.49398],
    958: [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
    959: [0, 0.43056, 0, 0.05556, 0.48472],
    960: [0, 0.43056, 0.03588, 0, 0.57003],
    961: [0.19444, 0.43056, 0, 0.08334, 0.51702],
    962: [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
    963: [0, 0.43056, 0.03588, 0, 0.57141],
    964: [0, 0.43056, 0.1132, 0.02778, 0.43715],
    965: [0, 0.43056, 0.03588, 0.02778, 0.54028],
    966: [0.19444, 0.43056, 0, 0.08334, 0.65417],
    967: [0.19444, 0.43056, 0, 0.05556, 0.62569],
    968: [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
    969: [0, 0.43056, 0.03588, 0, 0.62245],
    977: [0, 0.69444, 0, 0.08334, 0.59144],
    981: [0.19444, 0.69444, 0, 0.08334, 0.59583],
    982: [0, 0.43056, 0.02778, 0, 0.82813],
    1009: [0.19444, 0.43056, 0, 0.08334, 0.51702],
    1013: [0, 0.43056, 0, 0.05556, 0.4059],
    57649: [0, 0.43056, 0, 0.02778, 0.32246],
    57911: [0.19444, 0.43056, 0, 0.08334, 0.38403]
  },
  "SansSerif-Bold": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.36667],
    34: [0, 0.69444, 0, 0, 0.55834],
    35: [0.19444, 0.69444, 0, 0, 0.91667],
    36: [0.05556, 0.75, 0, 0, 0.55],
    37: [0.05556, 0.75, 0, 0, 1.02912],
    38: [0, 0.69444, 0, 0, 0.83056],
    39: [0, 0.69444, 0, 0, 0.30556],
    40: [0.25, 0.75, 0, 0, 0.42778],
    41: [0.25, 0.75, 0, 0, 0.42778],
    42: [0, 0.75, 0, 0, 0.55],
    43: [0.11667, 0.61667, 0, 0, 0.85556],
    44: [0.10556, 0.13056, 0, 0, 0.30556],
    45: [0, 0.45833, 0, 0, 0.36667],
    46: [0, 0.13056, 0, 0, 0.30556],
    47: [0.25, 0.75, 0, 0, 0.55],
    48: [0, 0.69444, 0, 0, 0.55],
    49: [0, 0.69444, 0, 0, 0.55],
    50: [0, 0.69444, 0, 0, 0.55],
    51: [0, 0.69444, 0, 0, 0.55],
    52: [0, 0.69444, 0, 0, 0.55],
    53: [0, 0.69444, 0, 0, 0.55],
    54: [0, 0.69444, 0, 0, 0.55],
    55: [0, 0.69444, 0, 0, 0.55],
    56: [0, 0.69444, 0, 0, 0.55],
    57: [0, 0.69444, 0, 0, 0.55],
    58: [0, 0.45833, 0, 0, 0.30556],
    59: [0.10556, 0.45833, 0, 0, 0.30556],
    61: [-0.09375, 0.40625, 0, 0, 0.85556],
    63: [0, 0.69444, 0, 0, 0.51945],
    64: [0, 0.69444, 0, 0, 0.73334],
    65: [0, 0.69444, 0, 0, 0.73334],
    66: [0, 0.69444, 0, 0, 0.73334],
    67: [0, 0.69444, 0, 0, 0.70278],
    68: [0, 0.69444, 0, 0, 0.79445],
    69: [0, 0.69444, 0, 0, 0.64167],
    70: [0, 0.69444, 0, 0, 0.61111],
    71: [0, 0.69444, 0, 0, 0.73334],
    72: [0, 0.69444, 0, 0, 0.79445],
    73: [0, 0.69444, 0, 0, 0.33056],
    74: [0, 0.69444, 0, 0, 0.51945],
    75: [0, 0.69444, 0, 0, 0.76389],
    76: [0, 0.69444, 0, 0, 0.58056],
    77: [0, 0.69444, 0, 0, 0.97778],
    78: [0, 0.69444, 0, 0, 0.79445],
    79: [0, 0.69444, 0, 0, 0.79445],
    80: [0, 0.69444, 0, 0, 0.70278],
    81: [0.10556, 0.69444, 0, 0, 0.79445],
    82: [0, 0.69444, 0, 0, 0.70278],
    83: [0, 0.69444, 0, 0, 0.61111],
    84: [0, 0.69444, 0, 0, 0.73334],
    85: [0, 0.69444, 0, 0, 0.76389],
    86: [0, 0.69444, 0.01528, 0, 0.73334],
    87: [0, 0.69444, 0.01528, 0, 1.03889],
    88: [0, 0.69444, 0, 0, 0.73334],
    89: [0, 0.69444, 0.0275, 0, 0.73334],
    90: [0, 0.69444, 0, 0, 0.67223],
    91: [0.25, 0.75, 0, 0, 0.34306],
    93: [0.25, 0.75, 0, 0, 0.34306],
    94: [0, 0.69444, 0, 0, 0.55],
    95: [0.35, 0.10833, 0.03056, 0, 0.55],
    97: [0, 0.45833, 0, 0, 0.525],
    98: [0, 0.69444, 0, 0, 0.56111],
    99: [0, 0.45833, 0, 0, 0.48889],
    100: [0, 0.69444, 0, 0, 0.56111],
    101: [0, 0.45833, 0, 0, 0.51111],
    102: [0, 0.69444, 0.07639, 0, 0.33611],
    103: [0.19444, 0.45833, 0.01528, 0, 0.55],
    104: [0, 0.69444, 0, 0, 0.56111],
    105: [0, 0.69444, 0, 0, 0.25556],
    106: [0.19444, 0.69444, 0, 0, 0.28611],
    107: [0, 0.69444, 0, 0, 0.53056],
    108: [0, 0.69444, 0, 0, 0.25556],
    109: [0, 0.45833, 0, 0, 0.86667],
    110: [0, 0.45833, 0, 0, 0.56111],
    111: [0, 0.45833, 0, 0, 0.55],
    112: [0.19444, 0.45833, 0, 0, 0.56111],
    113: [0.19444, 0.45833, 0, 0, 0.56111],
    114: [0, 0.45833, 0.01528, 0, 0.37222],
    115: [0, 0.45833, 0, 0, 0.42167],
    116: [0, 0.58929, 0, 0, 0.40417],
    117: [0, 0.45833, 0, 0, 0.56111],
    118: [0, 0.45833, 0.01528, 0, 0.5],
    119: [0, 0.45833, 0.01528, 0, 0.74445],
    120: [0, 0.45833, 0, 0, 0.5],
    121: [0.19444, 0.45833, 0.01528, 0, 0.5],
    122: [0, 0.45833, 0, 0, 0.47639],
    126: [0.35, 0.34444, 0, 0, 0.55],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.69444, 0, 0, 0.55],
    176: [0, 0.69444, 0, 0, 0.73334],
    180: [0, 0.69444, 0, 0, 0.55],
    184: [0.17014, 0, 0, 0, 0.48889],
    305: [0, 0.45833, 0, 0, 0.25556],
    567: [0.19444, 0.45833, 0, 0, 0.28611],
    710: [0, 0.69444, 0, 0, 0.55],
    711: [0, 0.63542, 0, 0, 0.55],
    713: [0, 0.63778, 0, 0, 0.55],
    728: [0, 0.69444, 0, 0, 0.55],
    729: [0, 0.69444, 0, 0, 0.30556],
    730: [0, 0.69444, 0, 0, 0.73334],
    732: [0, 0.69444, 0, 0, 0.55],
    733: [0, 0.69444, 0, 0, 0.55],
    915: [0, 0.69444, 0, 0, 0.58056],
    916: [0, 0.69444, 0, 0, 0.91667],
    920: [0, 0.69444, 0, 0, 0.85556],
    923: [0, 0.69444, 0, 0, 0.67223],
    926: [0, 0.69444, 0, 0, 0.73334],
    928: [0, 0.69444, 0, 0, 0.79445],
    931: [0, 0.69444, 0, 0, 0.79445],
    933: [0, 0.69444, 0, 0, 0.85556],
    934: [0, 0.69444, 0, 0, 0.79445],
    936: [0, 0.69444, 0, 0, 0.85556],
    937: [0, 0.69444, 0, 0, 0.79445],
    8211: [0, 0.45833, 0.03056, 0, 0.55],
    8212: [0, 0.45833, 0.03056, 0, 1.10001],
    8216: [0, 0.69444, 0, 0, 0.30556],
    8217: [0, 0.69444, 0, 0, 0.30556],
    8220: [0, 0.69444, 0, 0, 0.55834],
    8221: [0, 0.69444, 0, 0, 0.55834]
  },
  "SansSerif-Italic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.05733, 0, 0.31945],
    34: [0, 0.69444, 316e-5, 0, 0.5],
    35: [0.19444, 0.69444, 0.05087, 0, 0.83334],
    36: [0.05556, 0.75, 0.11156, 0, 0.5],
    37: [0.05556, 0.75, 0.03126, 0, 0.83334],
    38: [0, 0.69444, 0.03058, 0, 0.75834],
    39: [0, 0.69444, 0.07816, 0, 0.27778],
    40: [0.25, 0.75, 0.13164, 0, 0.38889],
    41: [0.25, 0.75, 0.02536, 0, 0.38889],
    42: [0, 0.75, 0.11775, 0, 0.5],
    43: [0.08333, 0.58333, 0.02536, 0, 0.77778],
    44: [0.125, 0.08333, 0, 0, 0.27778],
    45: [0, 0.44444, 0.01946, 0, 0.33333],
    46: [0, 0.08333, 0, 0, 0.27778],
    47: [0.25, 0.75, 0.13164, 0, 0.5],
    48: [0, 0.65556, 0.11156, 0, 0.5],
    49: [0, 0.65556, 0.11156, 0, 0.5],
    50: [0, 0.65556, 0.11156, 0, 0.5],
    51: [0, 0.65556, 0.11156, 0, 0.5],
    52: [0, 0.65556, 0.11156, 0, 0.5],
    53: [0, 0.65556, 0.11156, 0, 0.5],
    54: [0, 0.65556, 0.11156, 0, 0.5],
    55: [0, 0.65556, 0.11156, 0, 0.5],
    56: [0, 0.65556, 0.11156, 0, 0.5],
    57: [0, 0.65556, 0.11156, 0, 0.5],
    58: [0, 0.44444, 0.02502, 0, 0.27778],
    59: [0.125, 0.44444, 0.02502, 0, 0.27778],
    61: [-0.13, 0.37, 0.05087, 0, 0.77778],
    63: [0, 0.69444, 0.11809, 0, 0.47222],
    64: [0, 0.69444, 0.07555, 0, 0.66667],
    65: [0, 0.69444, 0, 0, 0.66667],
    66: [0, 0.69444, 0.08293, 0, 0.66667],
    67: [0, 0.69444, 0.11983, 0, 0.63889],
    68: [0, 0.69444, 0.07555, 0, 0.72223],
    69: [0, 0.69444, 0.11983, 0, 0.59722],
    70: [0, 0.69444, 0.13372, 0, 0.56945],
    71: [0, 0.69444, 0.11983, 0, 0.66667],
    72: [0, 0.69444, 0.08094, 0, 0.70834],
    73: [0, 0.69444, 0.13372, 0, 0.27778],
    74: [0, 0.69444, 0.08094, 0, 0.47222],
    75: [0, 0.69444, 0.11983, 0, 0.69445],
    76: [0, 0.69444, 0, 0, 0.54167],
    77: [0, 0.69444, 0.08094, 0, 0.875],
    78: [0, 0.69444, 0.08094, 0, 0.70834],
    79: [0, 0.69444, 0.07555, 0, 0.73611],
    80: [0, 0.69444, 0.08293, 0, 0.63889],
    81: [0.125, 0.69444, 0.07555, 0, 0.73611],
    82: [0, 0.69444, 0.08293, 0, 0.64584],
    83: [0, 0.69444, 0.09205, 0, 0.55556],
    84: [0, 0.69444, 0.13372, 0, 0.68056],
    85: [0, 0.69444, 0.08094, 0, 0.6875],
    86: [0, 0.69444, 0.1615, 0, 0.66667],
    87: [0, 0.69444, 0.1615, 0, 0.94445],
    88: [0, 0.69444, 0.13372, 0, 0.66667],
    89: [0, 0.69444, 0.17261, 0, 0.66667],
    90: [0, 0.69444, 0.11983, 0, 0.61111],
    91: [0.25, 0.75, 0.15942, 0, 0.28889],
    93: [0.25, 0.75, 0.08719, 0, 0.28889],
    94: [0, 0.69444, 0.0799, 0, 0.5],
    95: [0.35, 0.09444, 0.08616, 0, 0.5],
    97: [0, 0.44444, 981e-5, 0, 0.48056],
    98: [0, 0.69444, 0.03057, 0, 0.51667],
    99: [0, 0.44444, 0.08336, 0, 0.44445],
    100: [0, 0.69444, 0.09483, 0, 0.51667],
    101: [0, 0.44444, 0.06778, 0, 0.44445],
    102: [0, 0.69444, 0.21705, 0, 0.30556],
    103: [0.19444, 0.44444, 0.10836, 0, 0.5],
    104: [0, 0.69444, 0.01778, 0, 0.51667],
    105: [0, 0.67937, 0.09718, 0, 0.23889],
    106: [0.19444, 0.67937, 0.09162, 0, 0.26667],
    107: [0, 0.69444, 0.08336, 0, 0.48889],
    108: [0, 0.69444, 0.09483, 0, 0.23889],
    109: [0, 0.44444, 0.01778, 0, 0.79445],
    110: [0, 0.44444, 0.01778, 0, 0.51667],
    111: [0, 0.44444, 0.06613, 0, 0.5],
    112: [0.19444, 0.44444, 0.0389, 0, 0.51667],
    113: [0.19444, 0.44444, 0.04169, 0, 0.51667],
    114: [0, 0.44444, 0.10836, 0, 0.34167],
    115: [0, 0.44444, 0.0778, 0, 0.38333],
    116: [0, 0.57143, 0.07225, 0, 0.36111],
    117: [0, 0.44444, 0.04169, 0, 0.51667],
    118: [0, 0.44444, 0.10836, 0, 0.46111],
    119: [0, 0.44444, 0.10836, 0, 0.68334],
    120: [0, 0.44444, 0.09169, 0, 0.46111],
    121: [0.19444, 0.44444, 0.10836, 0, 0.46111],
    122: [0, 0.44444, 0.08752, 0, 0.43472],
    126: [0.35, 0.32659, 0.08826, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.67937, 0.06385, 0, 0.5],
    176: [0, 0.69444, 0, 0, 0.73752],
    184: [0.17014, 0, 0, 0, 0.44445],
    305: [0, 0.44444, 0.04169, 0, 0.23889],
    567: [0.19444, 0.44444, 0.04169, 0, 0.26667],
    710: [0, 0.69444, 0.0799, 0, 0.5],
    711: [0, 0.63194, 0.08432, 0, 0.5],
    713: [0, 0.60889, 0.08776, 0, 0.5],
    714: [0, 0.69444, 0.09205, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0.09483, 0, 0.5],
    729: [0, 0.67937, 0.07774, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.73752],
    732: [0, 0.67659, 0.08826, 0, 0.5],
    733: [0, 0.69444, 0.09205, 0, 0.5],
    915: [0, 0.69444, 0.13372, 0, 0.54167],
    916: [0, 0.69444, 0, 0, 0.83334],
    920: [0, 0.69444, 0.07555, 0, 0.77778],
    923: [0, 0.69444, 0, 0, 0.61111],
    926: [0, 0.69444, 0.12816, 0, 0.66667],
    928: [0, 0.69444, 0.08094, 0, 0.70834],
    931: [0, 0.69444, 0.11983, 0, 0.72222],
    933: [0, 0.69444, 0.09031, 0, 0.77778],
    934: [0, 0.69444, 0.04603, 0, 0.72222],
    936: [0, 0.69444, 0.09031, 0, 0.77778],
    937: [0, 0.69444, 0.08293, 0, 0.72222],
    8211: [0, 0.44444, 0.08616, 0, 0.5],
    8212: [0, 0.44444, 0.08616, 0, 1],
    8216: [0, 0.69444, 0.07816, 0, 0.27778],
    8217: [0, 0.69444, 0.07816, 0, 0.27778],
    8220: [0, 0.69444, 0.14205, 0, 0.5],
    8221: [0, 0.69444, 316e-5, 0, 0.5]
  },
  "SansSerif-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.31945],
    34: [0, 0.69444, 0, 0, 0.5],
    35: [0.19444, 0.69444, 0, 0, 0.83334],
    36: [0.05556, 0.75, 0, 0, 0.5],
    37: [0.05556, 0.75, 0, 0, 0.83334],
    38: [0, 0.69444, 0, 0, 0.75834],
    39: [0, 0.69444, 0, 0, 0.27778],
    40: [0.25, 0.75, 0, 0, 0.38889],
    41: [0.25, 0.75, 0, 0, 0.38889],
    42: [0, 0.75, 0, 0, 0.5],
    43: [0.08333, 0.58333, 0, 0, 0.77778],
    44: [0.125, 0.08333, 0, 0, 0.27778],
    45: [0, 0.44444, 0, 0, 0.33333],
    46: [0, 0.08333, 0, 0, 0.27778],
    47: [0.25, 0.75, 0, 0, 0.5],
    48: [0, 0.65556, 0, 0, 0.5],
    49: [0, 0.65556, 0, 0, 0.5],
    50: [0, 0.65556, 0, 0, 0.5],
    51: [0, 0.65556, 0, 0, 0.5],
    52: [0, 0.65556, 0, 0, 0.5],
    53: [0, 0.65556, 0, 0, 0.5],
    54: [0, 0.65556, 0, 0, 0.5],
    55: [0, 0.65556, 0, 0, 0.5],
    56: [0, 0.65556, 0, 0, 0.5],
    57: [0, 0.65556, 0, 0, 0.5],
    58: [0, 0.44444, 0, 0, 0.27778],
    59: [0.125, 0.44444, 0, 0, 0.27778],
    61: [-0.13, 0.37, 0, 0, 0.77778],
    63: [0, 0.69444, 0, 0, 0.47222],
    64: [0, 0.69444, 0, 0, 0.66667],
    65: [0, 0.69444, 0, 0, 0.66667],
    66: [0, 0.69444, 0, 0, 0.66667],
    67: [0, 0.69444, 0, 0, 0.63889],
    68: [0, 0.69444, 0, 0, 0.72223],
    69: [0, 0.69444, 0, 0, 0.59722],
    70: [0, 0.69444, 0, 0, 0.56945],
    71: [0, 0.69444, 0, 0, 0.66667],
    72: [0, 0.69444, 0, 0, 0.70834],
    73: [0, 0.69444, 0, 0, 0.27778],
    74: [0, 0.69444, 0, 0, 0.47222],
    75: [0, 0.69444, 0, 0, 0.69445],
    76: [0, 0.69444, 0, 0, 0.54167],
    77: [0, 0.69444, 0, 0, 0.875],
    78: [0, 0.69444, 0, 0, 0.70834],
    79: [0, 0.69444, 0, 0, 0.73611],
    80: [0, 0.69444, 0, 0, 0.63889],
    81: [0.125, 0.69444, 0, 0, 0.73611],
    82: [0, 0.69444, 0, 0, 0.64584],
    83: [0, 0.69444, 0, 0, 0.55556],
    84: [0, 0.69444, 0, 0, 0.68056],
    85: [0, 0.69444, 0, 0, 0.6875],
    86: [0, 0.69444, 0.01389, 0, 0.66667],
    87: [0, 0.69444, 0.01389, 0, 0.94445],
    88: [0, 0.69444, 0, 0, 0.66667],
    89: [0, 0.69444, 0.025, 0, 0.66667],
    90: [0, 0.69444, 0, 0, 0.61111],
    91: [0.25, 0.75, 0, 0, 0.28889],
    93: [0.25, 0.75, 0, 0, 0.28889],
    94: [0, 0.69444, 0, 0, 0.5],
    95: [0.35, 0.09444, 0.02778, 0, 0.5],
    97: [0, 0.44444, 0, 0, 0.48056],
    98: [0, 0.69444, 0, 0, 0.51667],
    99: [0, 0.44444, 0, 0, 0.44445],
    100: [0, 0.69444, 0, 0, 0.51667],
    101: [0, 0.44444, 0, 0, 0.44445],
    102: [0, 0.69444, 0.06944, 0, 0.30556],
    103: [0.19444, 0.44444, 0.01389, 0, 0.5],
    104: [0, 0.69444, 0, 0, 0.51667],
    105: [0, 0.67937, 0, 0, 0.23889],
    106: [0.19444, 0.67937, 0, 0, 0.26667],
    107: [0, 0.69444, 0, 0, 0.48889],
    108: [0, 0.69444, 0, 0, 0.23889],
    109: [0, 0.44444, 0, 0, 0.79445],
    110: [0, 0.44444, 0, 0, 0.51667],
    111: [0, 0.44444, 0, 0, 0.5],
    112: [0.19444, 0.44444, 0, 0, 0.51667],
    113: [0.19444, 0.44444, 0, 0, 0.51667],
    114: [0, 0.44444, 0.01389, 0, 0.34167],
    115: [0, 0.44444, 0, 0, 0.38333],
    116: [0, 0.57143, 0, 0, 0.36111],
    117: [0, 0.44444, 0, 0, 0.51667],
    118: [0, 0.44444, 0.01389, 0, 0.46111],
    119: [0, 0.44444, 0.01389, 0, 0.68334],
    120: [0, 0.44444, 0, 0, 0.46111],
    121: [0.19444, 0.44444, 0.01389, 0, 0.46111],
    122: [0, 0.44444, 0, 0, 0.43472],
    126: [0.35, 0.32659, 0, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.67937, 0, 0, 0.5],
    176: [0, 0.69444, 0, 0, 0.66667],
    184: [0.17014, 0, 0, 0, 0.44445],
    305: [0, 0.44444, 0, 0, 0.23889],
    567: [0.19444, 0.44444, 0, 0, 0.26667],
    710: [0, 0.69444, 0, 0, 0.5],
    711: [0, 0.63194, 0, 0, 0.5],
    713: [0, 0.60889, 0, 0, 0.5],
    714: [0, 0.69444, 0, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0, 0, 0.5],
    729: [0, 0.67937, 0, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.66667],
    732: [0, 0.67659, 0, 0, 0.5],
    733: [0, 0.69444, 0, 0, 0.5],
    915: [0, 0.69444, 0, 0, 0.54167],
    916: [0, 0.69444, 0, 0, 0.83334],
    920: [0, 0.69444, 0, 0, 0.77778],
    923: [0, 0.69444, 0, 0, 0.61111],
    926: [0, 0.69444, 0, 0, 0.66667],
    928: [0, 0.69444, 0, 0, 0.70834],
    931: [0, 0.69444, 0, 0, 0.72222],
    933: [0, 0.69444, 0, 0, 0.77778],
    934: [0, 0.69444, 0, 0, 0.72222],
    936: [0, 0.69444, 0, 0, 0.77778],
    937: [0, 0.69444, 0, 0, 0.72222],
    8211: [0, 0.44444, 0.02778, 0, 0.5],
    8212: [0, 0.44444, 0.02778, 0, 1],
    8216: [0, 0.69444, 0, 0, 0.27778],
    8217: [0, 0.69444, 0, 0, 0.27778],
    8220: [0, 0.69444, 0, 0, 0.5],
    8221: [0, 0.69444, 0, 0, 0.5]
  },
  "Script-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.7, 0.22925, 0, 0.80253],
    66: [0, 0.7, 0.04087, 0, 0.90757],
    67: [0, 0.7, 0.1689, 0, 0.66619],
    68: [0, 0.7, 0.09371, 0, 0.77443],
    69: [0, 0.7, 0.18583, 0, 0.56162],
    70: [0, 0.7, 0.13634, 0, 0.89544],
    71: [0, 0.7, 0.17322, 0, 0.60961],
    72: [0, 0.7, 0.29694, 0, 0.96919],
    73: [0, 0.7, 0.19189, 0, 0.80907],
    74: [0.27778, 0.7, 0.19189, 0, 1.05159],
    75: [0, 0.7, 0.31259, 0, 0.91364],
    76: [0, 0.7, 0.19189, 0, 0.87373],
    77: [0, 0.7, 0.15981, 0, 1.08031],
    78: [0, 0.7, 0.3525, 0, 0.9015],
    79: [0, 0.7, 0.08078, 0, 0.73787],
    80: [0, 0.7, 0.08078, 0, 1.01262],
    81: [0, 0.7, 0.03305, 0, 0.88282],
    82: [0, 0.7, 0.06259, 0, 0.85],
    83: [0, 0.7, 0.19189, 0, 0.86767],
    84: [0, 0.7, 0.29087, 0, 0.74697],
    85: [0, 0.7, 0.25815, 0, 0.79996],
    86: [0, 0.7, 0.27523, 0, 0.62204],
    87: [0, 0.7, 0.27523, 0, 0.80532],
    88: [0, 0.7, 0.26006, 0, 0.94445],
    89: [0, 0.7, 0.2939, 0, 0.70961],
    90: [0, 0.7, 0.24037, 0, 0.8212],
    160: [0, 0, 0, 0, 0.25]
  },
  "Size1-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.35001, 0.85, 0, 0, 0.45834],
    41: [0.35001, 0.85, 0, 0, 0.45834],
    47: [0.35001, 0.85, 0, 0, 0.57778],
    91: [0.35001, 0.85, 0, 0, 0.41667],
    92: [0.35001, 0.85, 0, 0, 0.57778],
    93: [0.35001, 0.85, 0, 0, 0.41667],
    123: [0.35001, 0.85, 0, 0, 0.58334],
    125: [0.35001, 0.85, 0, 0, 0.58334],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.72222, 0, 0, 0.55556],
    732: [0, 0.72222, 0, 0, 0.55556],
    770: [0, 0.72222, 0, 0, 0.55556],
    771: [0, 0.72222, 0, 0, 0.55556],
    8214: [-99e-5, 0.601, 0, 0, 0.77778],
    8593: [1e-5, 0.6, 0, 0, 0.66667],
    8595: [1e-5, 0.6, 0, 0, 0.66667],
    8657: [1e-5, 0.6, 0, 0, 0.77778],
    8659: [1e-5, 0.6, 0, 0, 0.77778],
    8719: [0.25001, 0.75, 0, 0, 0.94445],
    8720: [0.25001, 0.75, 0, 0, 0.94445],
    8721: [0.25001, 0.75, 0, 0, 1.05556],
    8730: [0.35001, 0.85, 0, 0, 1],
    8739: [-599e-5, 0.606, 0, 0, 0.33333],
    8741: [-599e-5, 0.606, 0, 0, 0.55556],
    8747: [0.30612, 0.805, 0.19445, 0, 0.47222],
    8748: [0.306, 0.805, 0.19445, 0, 0.47222],
    8749: [0.306, 0.805, 0.19445, 0, 0.47222],
    8750: [0.30612, 0.805, 0.19445, 0, 0.47222],
    8896: [0.25001, 0.75, 0, 0, 0.83334],
    8897: [0.25001, 0.75, 0, 0, 0.83334],
    8898: [0.25001, 0.75, 0, 0, 0.83334],
    8899: [0.25001, 0.75, 0, 0, 0.83334],
    8968: [0.35001, 0.85, 0, 0, 0.47222],
    8969: [0.35001, 0.85, 0, 0, 0.47222],
    8970: [0.35001, 0.85, 0, 0, 0.47222],
    8971: [0.35001, 0.85, 0, 0, 0.47222],
    9168: [-99e-5, 0.601, 0, 0, 0.66667],
    10216: [0.35001, 0.85, 0, 0, 0.47222],
    10217: [0.35001, 0.85, 0, 0, 0.47222],
    10752: [0.25001, 0.75, 0, 0, 1.11111],
    10753: [0.25001, 0.75, 0, 0, 1.11111],
    10754: [0.25001, 0.75, 0, 0, 1.11111],
    10756: [0.25001, 0.75, 0, 0, 0.83334],
    10758: [0.25001, 0.75, 0, 0, 0.83334]
  },
  "Size2-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.65002, 1.15, 0, 0, 0.59722],
    41: [0.65002, 1.15, 0, 0, 0.59722],
    47: [0.65002, 1.15, 0, 0, 0.81111],
    91: [0.65002, 1.15, 0, 0, 0.47222],
    92: [0.65002, 1.15, 0, 0, 0.81111],
    93: [0.65002, 1.15, 0, 0, 0.47222],
    123: [0.65002, 1.15, 0, 0, 0.66667],
    125: [0.65002, 1.15, 0, 0, 0.66667],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.75, 0, 0, 1],
    732: [0, 0.75, 0, 0, 1],
    770: [0, 0.75, 0, 0, 1],
    771: [0, 0.75, 0, 0, 1],
    8719: [0.55001, 1.05, 0, 0, 1.27778],
    8720: [0.55001, 1.05, 0, 0, 1.27778],
    8721: [0.55001, 1.05, 0, 0, 1.44445],
    8730: [0.65002, 1.15, 0, 0, 1],
    8747: [0.86225, 1.36, 0.44445, 0, 0.55556],
    8748: [0.862, 1.36, 0.44445, 0, 0.55556],
    8749: [0.862, 1.36, 0.44445, 0, 0.55556],
    8750: [0.86225, 1.36, 0.44445, 0, 0.55556],
    8896: [0.55001, 1.05, 0, 0, 1.11111],
    8897: [0.55001, 1.05, 0, 0, 1.11111],
    8898: [0.55001, 1.05, 0, 0, 1.11111],
    8899: [0.55001, 1.05, 0, 0, 1.11111],
    8968: [0.65002, 1.15, 0, 0, 0.52778],
    8969: [0.65002, 1.15, 0, 0, 0.52778],
    8970: [0.65002, 1.15, 0, 0, 0.52778],
    8971: [0.65002, 1.15, 0, 0, 0.52778],
    10216: [0.65002, 1.15, 0, 0, 0.61111],
    10217: [0.65002, 1.15, 0, 0, 0.61111],
    10752: [0.55001, 1.05, 0, 0, 1.51112],
    10753: [0.55001, 1.05, 0, 0, 1.51112],
    10754: [0.55001, 1.05, 0, 0, 1.51112],
    10756: [0.55001, 1.05, 0, 0, 1.11111],
    10758: [0.55001, 1.05, 0, 0, 1.11111]
  },
  "Size3-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.95003, 1.45, 0, 0, 0.73611],
    41: [0.95003, 1.45, 0, 0, 0.73611],
    47: [0.95003, 1.45, 0, 0, 1.04445],
    91: [0.95003, 1.45, 0, 0, 0.52778],
    92: [0.95003, 1.45, 0, 0, 1.04445],
    93: [0.95003, 1.45, 0, 0, 0.52778],
    123: [0.95003, 1.45, 0, 0, 0.75],
    125: [0.95003, 1.45, 0, 0, 0.75],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.75, 0, 0, 1.44445],
    732: [0, 0.75, 0, 0, 1.44445],
    770: [0, 0.75, 0, 0, 1.44445],
    771: [0, 0.75, 0, 0, 1.44445],
    8730: [0.95003, 1.45, 0, 0, 1],
    8968: [0.95003, 1.45, 0, 0, 0.58334],
    8969: [0.95003, 1.45, 0, 0, 0.58334],
    8970: [0.95003, 1.45, 0, 0, 0.58334],
    8971: [0.95003, 1.45, 0, 0, 0.58334],
    10216: [0.95003, 1.45, 0, 0, 0.75],
    10217: [0.95003, 1.45, 0, 0, 0.75]
  },
  "Size4-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [1.25003, 1.75, 0, 0, 0.79167],
    41: [1.25003, 1.75, 0, 0, 0.79167],
    47: [1.25003, 1.75, 0, 0, 1.27778],
    91: [1.25003, 1.75, 0, 0, 0.58334],
    92: [1.25003, 1.75, 0, 0, 1.27778],
    93: [1.25003, 1.75, 0, 0, 0.58334],
    123: [1.25003, 1.75, 0, 0, 0.80556],
    125: [1.25003, 1.75, 0, 0, 0.80556],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.825, 0, 0, 1.8889],
    732: [0, 0.825, 0, 0, 1.8889],
    770: [0, 0.825, 0, 0, 1.8889],
    771: [0, 0.825, 0, 0, 1.8889],
    8730: [1.25003, 1.75, 0, 0, 1],
    8968: [1.25003, 1.75, 0, 0, 0.63889],
    8969: [1.25003, 1.75, 0, 0, 0.63889],
    8970: [1.25003, 1.75, 0, 0, 0.63889],
    8971: [1.25003, 1.75, 0, 0, 0.63889],
    9115: [0.64502, 1.155, 0, 0, 0.875],
    9116: [1e-5, 0.6, 0, 0, 0.875],
    9117: [0.64502, 1.155, 0, 0, 0.875],
    9118: [0.64502, 1.155, 0, 0, 0.875],
    9119: [1e-5, 0.6, 0, 0, 0.875],
    9120: [0.64502, 1.155, 0, 0, 0.875],
    9121: [0.64502, 1.155, 0, 0, 0.66667],
    9122: [-99e-5, 0.601, 0, 0, 0.66667],
    9123: [0.64502, 1.155, 0, 0, 0.66667],
    9124: [0.64502, 1.155, 0, 0, 0.66667],
    9125: [-99e-5, 0.601, 0, 0, 0.66667],
    9126: [0.64502, 1.155, 0, 0, 0.66667],
    9127: [1e-5, 0.9, 0, 0, 0.88889],
    9128: [0.65002, 1.15, 0, 0, 0.88889],
    9129: [0.90001, 0, 0, 0, 0.88889],
    9130: [0, 0.3, 0, 0, 0.88889],
    9131: [1e-5, 0.9, 0, 0, 0.88889],
    9132: [0.65002, 1.15, 0, 0, 0.88889],
    9133: [0.90001, 0, 0, 0, 0.88889],
    9143: [0.88502, 0.915, 0, 0, 1.05556],
    10216: [1.25003, 1.75, 0, 0, 0.80556],
    10217: [1.25003, 1.75, 0, 0, 0.80556],
    57344: [-499e-5, 0.605, 0, 0, 1.05556],
    57345: [-499e-5, 0.605, 0, 0, 1.05556],
    57680: [0, 0.12, 0, 0, 0.45],
    57681: [0, 0.12, 0, 0, 0.45],
    57682: [0, 0.12, 0, 0, 0.45],
    57683: [0, 0.12, 0, 0, 0.45]
  },
  "Typewriter-Regular": {
    32: [0, 0, 0, 0, 0.525],
    33: [0, 0.61111, 0, 0, 0.525],
    34: [0, 0.61111, 0, 0, 0.525],
    35: [0, 0.61111, 0, 0, 0.525],
    36: [0.08333, 0.69444, 0, 0, 0.525],
    37: [0.08333, 0.69444, 0, 0, 0.525],
    38: [0, 0.61111, 0, 0, 0.525],
    39: [0, 0.61111, 0, 0, 0.525],
    40: [0.08333, 0.69444, 0, 0, 0.525],
    41: [0.08333, 0.69444, 0, 0, 0.525],
    42: [0, 0.52083, 0, 0, 0.525],
    43: [-0.08056, 0.53055, 0, 0, 0.525],
    44: [0.13889, 0.125, 0, 0, 0.525],
    45: [-0.08056, 0.53055, 0, 0, 0.525],
    46: [0, 0.125, 0, 0, 0.525],
    47: [0.08333, 0.69444, 0, 0, 0.525],
    48: [0, 0.61111, 0, 0, 0.525],
    49: [0, 0.61111, 0, 0, 0.525],
    50: [0, 0.61111, 0, 0, 0.525],
    51: [0, 0.61111, 0, 0, 0.525],
    52: [0, 0.61111, 0, 0, 0.525],
    53: [0, 0.61111, 0, 0, 0.525],
    54: [0, 0.61111, 0, 0, 0.525],
    55: [0, 0.61111, 0, 0, 0.525],
    56: [0, 0.61111, 0, 0, 0.525],
    57: [0, 0.61111, 0, 0, 0.525],
    58: [0, 0.43056, 0, 0, 0.525],
    59: [0.13889, 0.43056, 0, 0, 0.525],
    60: [-0.05556, 0.55556, 0, 0, 0.525],
    61: [-0.19549, 0.41562, 0, 0, 0.525],
    62: [-0.05556, 0.55556, 0, 0, 0.525],
    63: [0, 0.61111, 0, 0, 0.525],
    64: [0, 0.61111, 0, 0, 0.525],
    65: [0, 0.61111, 0, 0, 0.525],
    66: [0, 0.61111, 0, 0, 0.525],
    67: [0, 0.61111, 0, 0, 0.525],
    68: [0, 0.61111, 0, 0, 0.525],
    69: [0, 0.61111, 0, 0, 0.525],
    70: [0, 0.61111, 0, 0, 0.525],
    71: [0, 0.61111, 0, 0, 0.525],
    72: [0, 0.61111, 0, 0, 0.525],
    73: [0, 0.61111, 0, 0, 0.525],
    74: [0, 0.61111, 0, 0, 0.525],
    75: [0, 0.61111, 0, 0, 0.525],
    76: [0, 0.61111, 0, 0, 0.525],
    77: [0, 0.61111, 0, 0, 0.525],
    78: [0, 0.61111, 0, 0, 0.525],
    79: [0, 0.61111, 0, 0, 0.525],
    80: [0, 0.61111, 0, 0, 0.525],
    81: [0.13889, 0.61111, 0, 0, 0.525],
    82: [0, 0.61111, 0, 0, 0.525],
    83: [0, 0.61111, 0, 0, 0.525],
    84: [0, 0.61111, 0, 0, 0.525],
    85: [0, 0.61111, 0, 0, 0.525],
    86: [0, 0.61111, 0, 0, 0.525],
    87: [0, 0.61111, 0, 0, 0.525],
    88: [0, 0.61111, 0, 0, 0.525],
    89: [0, 0.61111, 0, 0, 0.525],
    90: [0, 0.61111, 0, 0, 0.525],
    91: [0.08333, 0.69444, 0, 0, 0.525],
    92: [0.08333, 0.69444, 0, 0, 0.525],
    93: [0.08333, 0.69444, 0, 0, 0.525],
    94: [0, 0.61111, 0, 0, 0.525],
    95: [0.09514, 0, 0, 0, 0.525],
    96: [0, 0.61111, 0, 0, 0.525],
    97: [0, 0.43056, 0, 0, 0.525],
    98: [0, 0.61111, 0, 0, 0.525],
    99: [0, 0.43056, 0, 0, 0.525],
    100: [0, 0.61111, 0, 0, 0.525],
    101: [0, 0.43056, 0, 0, 0.525],
    102: [0, 0.61111, 0, 0, 0.525],
    103: [0.22222, 0.43056, 0, 0, 0.525],
    104: [0, 0.61111, 0, 0, 0.525],
    105: [0, 0.61111, 0, 0, 0.525],
    106: [0.22222, 0.61111, 0, 0, 0.525],
    107: [0, 0.61111, 0, 0, 0.525],
    108: [0, 0.61111, 0, 0, 0.525],
    109: [0, 0.43056, 0, 0, 0.525],
    110: [0, 0.43056, 0, 0, 0.525],
    111: [0, 0.43056, 0, 0, 0.525],
    112: [0.22222, 0.43056, 0, 0, 0.525],
    113: [0.22222, 0.43056, 0, 0, 0.525],
    114: [0, 0.43056, 0, 0, 0.525],
    115: [0, 0.43056, 0, 0, 0.525],
    116: [0, 0.55358, 0, 0, 0.525],
    117: [0, 0.43056, 0, 0, 0.525],
    118: [0, 0.43056, 0, 0, 0.525],
    119: [0, 0.43056, 0, 0, 0.525],
    120: [0, 0.43056, 0, 0, 0.525],
    121: [0.22222, 0.43056, 0, 0, 0.525],
    122: [0, 0.43056, 0, 0, 0.525],
    123: [0.08333, 0.69444, 0, 0, 0.525],
    124: [0.08333, 0.69444, 0, 0, 0.525],
    125: [0.08333, 0.69444, 0, 0, 0.525],
    126: [0, 0.61111, 0, 0, 0.525],
    127: [0, 0.61111, 0, 0, 0.525],
    160: [0, 0, 0, 0, 0.525],
    176: [0, 0.61111, 0, 0, 0.525],
    184: [0.19445, 0, 0, 0, 0.525],
    305: [0, 0.43056, 0, 0, 0.525],
    567: [0.22222, 0.43056, 0, 0, 0.525],
    711: [0, 0.56597, 0, 0, 0.525],
    713: [0, 0.56555, 0, 0, 0.525],
    714: [0, 0.61111, 0, 0, 0.525],
    715: [0, 0.61111, 0, 0, 0.525],
    728: [0, 0.61111, 0, 0, 0.525],
    730: [0, 0.61111, 0, 0, 0.525],
    770: [0, 0.61111, 0, 0, 0.525],
    771: [0, 0.61111, 0, 0, 0.525],
    776: [0, 0.61111, 0, 0, 0.525],
    915: [0, 0.61111, 0, 0, 0.525],
    916: [0, 0.61111, 0, 0, 0.525],
    920: [0, 0.61111, 0, 0, 0.525],
    923: [0, 0.61111, 0, 0, 0.525],
    926: [0, 0.61111, 0, 0, 0.525],
    928: [0, 0.61111, 0, 0, 0.525],
    931: [0, 0.61111, 0, 0, 0.525],
    933: [0, 0.61111, 0, 0, 0.525],
    934: [0, 0.61111, 0, 0, 0.525],
    936: [0, 0.61111, 0, 0, 0.525],
    937: [0, 0.61111, 0, 0, 0.525],
    8216: [0, 0.61111, 0, 0, 0.525],
    8217: [0, 0.61111, 0, 0, 0.525],
    8242: [0, 0.61111, 0, 0, 0.525],
    9251: [0.11111, 0.21944, 0, 0, 0.525]
  }
}, un = {
  slant: [0.25, 0.25, 0.25],
  // sigma1
  space: [0, 0, 0],
  // sigma2
  stretch: [0, 0, 0],
  // sigma3
  shrink: [0, 0, 0],
  // sigma4
  xHeight: [0.431, 0.431, 0.431],
  // sigma5
  quad: [1, 1.171, 1.472],
  // sigma6
  extraSpace: [0, 0, 0],
  // sigma7
  num1: [0.677, 0.732, 0.925],
  // sigma8
  num2: [0.394, 0.384, 0.387],
  // sigma9
  num3: [0.444, 0.471, 0.504],
  // sigma10
  denom1: [0.686, 0.752, 1.025],
  // sigma11
  denom2: [0.345, 0.344, 0.532],
  // sigma12
  sup1: [0.413, 0.503, 0.504],
  // sigma13
  sup2: [0.363, 0.431, 0.404],
  // sigma14
  sup3: [0.289, 0.286, 0.294],
  // sigma15
  sub1: [0.15, 0.143, 0.2],
  // sigma16
  sub2: [0.247, 0.286, 0.4],
  // sigma17
  supDrop: [0.386, 0.353, 0.494],
  // sigma18
  subDrop: [0.05, 0.071, 0.1],
  // sigma19
  delim1: [2.39, 1.7, 1.98],
  // sigma20
  delim2: [1.01, 1.157, 1.42],
  // sigma21
  axisHeight: [0.25, 0.25, 0.25],
  // sigma22
  // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
  // they correspond to the font parameters of the extension fonts (family 3).
  // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
  // match cmex7, we'd use cmex7.tfm values for script and scriptscript
  // values.
  defaultRuleThickness: [0.04, 0.049, 0.049],
  // xi8; cmex7: 0.049
  bigOpSpacing1: [0.111, 0.111, 0.111],
  // xi9
  bigOpSpacing2: [0.166, 0.166, 0.166],
  // xi10
  bigOpSpacing3: [0.2, 0.2, 0.2],
  // xi11
  bigOpSpacing4: [0.6, 0.611, 0.611],
  // xi12; cmex7: 0.611
  bigOpSpacing5: [0.1, 0.143, 0.143],
  // xi13; cmex7: 0.143
  // The \sqrt rule width is taken from the height of the surd character.
  // Since we use the same font at all sizes, this thickness doesn't scale.
  sqrtRuleThickness: [0.04, 0.04, 0.04],
  // This value determines how large a pt is, for metrics which are defined
  // in terms of pts.
  // This value is also used in katex.scss; if you change it make sure the
  // values match.
  ptPerEm: [10, 10, 10],
  // The space between adjacent `|` columns in an array definition. From
  // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
  doubleRuleSep: [0.2, 0.2, 0.2],
  // The width of separator lines in {array} environments. From
  // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
  arrayRuleWidth: [0.04, 0.04, 0.04],
  // Two values from LaTeX source2e:
  fboxsep: [0.3, 0.3, 0.3],
  //        3 pt / ptPerEm
  fboxrule: [0.04, 0.04, 0.04]
  // 0.4 pt / ptPerEm
}, hc = {
  // Latin-1
  : "A",
  : "D",
  : "o",
  : "a",
  : "d",
  : "o",
  // Cyrillic
  : "A",
  : "B",
  : "B",
  : "F",
  : "A",
  : "E",
  : "K",
  : "3",
  : "N",
  : "N",
  : "K",
  : "N",
  : "M",
  : "H",
  : "O",
  : "N",
  : "P",
  : "C",
  : "T",
  : "y",
  : "O",
  : "X",
  : "U",
  : "h",
  : "W",
  : "W",
  : "B",
  : "X",
  : "B",
  : "3",
  : "X",
  : "R",
  : "a",
  : "b",
  : "a",
  : "r",
  : "y",
  : "e",
  : "m",
  : "e",
  : "n",
  : "n",
  : "n",
  : "n",
  : "m",
  : "n",
  : "o",
  : "n",
  : "p",
  : "c",
  : "o",
  : "y",
  : "b",
  : "x",
  : "n",
  : "n",
  : "w",
  : "w",
  : "a",
  : "m",
  : "a",
  : "e",
  : "m",
  : "r"
};
function By(e, t) {
  Jt[e] = t;
}
function Mi(e, t, a) {
  if (!Jt[t])
    throw new Error("Font metrics not found for font: " + t + ".");
  var r = e.charCodeAt(0), n = Jt[t][r];
  if (!n && e[0] in hc && (r = hc[e[0]].charCodeAt(0), n = Jt[t][r]), !n && a === "text" && Su(r) && (n = Jt[t][77]), n)
    return {
      depth: n[0],
      height: n[1],
      italic: n[2],
      skew: n[3],
      width: n[4]
    };
}
var Cs = {};
function Py(e) {
  var t;
  if (e >= 5 ? t = 0 : e >= 3 ? t = 1 : t = 2, !Cs[t]) {
    var a = Cs[t] = {
      cssEmPerMu: un.quad[t] / 18
    };
    for (var r in un)
      un.hasOwnProperty(r) && (a[r] = un[r][t]);
  }
  return Cs[t];
}
var Hy = [
  // Each element contains [textsize, scriptsize, scriptscriptsize].
  // The size mappings are taken from TeX with \normalsize=10pt.
  [1, 1, 1],
  // size1: [5, 5, 5]              \tiny
  [2, 1, 1],
  // size2: [6, 5, 5]
  [3, 1, 1],
  // size3: [7, 5, 5]              \scriptsize
  [4, 2, 1],
  // size4: [8, 6, 5]              \footnotesize
  [5, 2, 1],
  // size5: [9, 6, 5]              \small
  [6, 3, 1],
  // size6: [10, 7, 5]             \normalsize
  [7, 4, 2],
  // size7: [12, 8, 6]             \large
  [8, 6, 3],
  // size8: [14.4, 10, 7]          \Large
  [9, 7, 6],
  // size9: [17.28, 12, 10]        \LARGE
  [10, 8, 7],
  // size10: [20.74, 14.4, 12]     \huge
  [11, 10, 9]
  // size11: [24.88, 20.74, 17.28] \HUGE
], dc = [
  // fontMetrics.js:getGlobalMetrics also uses size indexes, so if
  // you change size indexes, change that function.
  0.5,
  0.6,
  0.7,
  0.8,
  0.9,
  1,
  1.2,
  1.44,
  1.728,
  2.074,
  2.488
], mc = function(t, a) {
  return a.size < 2 ? t : Hy[t - 1][a.size - 1];
};
class ha {
  // A font family applies to a group of fonts (i.e. SansSerif), while a font
  // represents a specific font (i.e. SansSerif Bold).
  // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
  /**
   * The base size index.
   */
  constructor(t) {
    this.style = void 0, this.color = void 0, this.size = void 0, this.textSize = void 0, this.phantom = void 0, this.font = void 0, this.fontFamily = void 0, this.fontWeight = void 0, this.fontShape = void 0, this.sizeMultiplier = void 0, this.maxSize = void 0, this.minRuleThickness = void 0, this._fontMetrics = void 0, this.style = t.style, this.color = t.color, this.size = t.size || ha.BASESIZE, this.textSize = t.textSize || this.size, this.phantom = !!t.phantom, this.font = t.font || "", this.fontFamily = t.fontFamily || "", this.fontWeight = t.fontWeight || "", this.fontShape = t.fontShape || "", this.sizeMultiplier = dc[this.size - 1], this.maxSize = t.maxSize, this.minRuleThickness = t.minRuleThickness, this._fontMetrics = void 0;
  }
  /**
   * Returns a new options object with the same properties as "this".  Properties
   * from "extension" will be copied to the new options object.
   */
  extend(t) {
    var a = {
      style: this.style,
      size: this.size,
      textSize: this.textSize,
      color: this.color,
      phantom: this.phantom,
      font: this.font,
      fontFamily: this.fontFamily,
      fontWeight: this.fontWeight,
      fontShape: this.fontShape,
      maxSize: this.maxSize,
      minRuleThickness: this.minRuleThickness
    };
    for (var r in t)
      t.hasOwnProperty(r) && (a[r] = t[r]);
    return new ha(a);
  }
  /**
   * Return an options object with the given style. If `this.style === style`,
   * returns `this`.
   */
  havingStyle(t) {
    return this.style === t ? this : this.extend({
      style: t,
      size: mc(this.textSize, t)
    });
  }
  /**
   * Return an options object with a cramped version of the current style. If
   * the current style is cramped, returns `this`.
   */
  havingCrampedStyle() {
    return this.havingStyle(this.style.cramp());
  }
  /**
   * Return an options object with the given size and in at least `\textstyle`.
   * Returns `this` if appropriate.
   */
  havingSize(t) {
    return this.size === t && this.textSize === t ? this : this.extend({
      style: this.style.text(),
      size: t,
      textSize: t,
      sizeMultiplier: dc[t - 1]
    });
  }
  /**
   * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
   * changes to at least `\textstyle`.
   */
  havingBaseStyle(t) {
    t = t || this.style.text();
    var a = mc(ha.BASESIZE, t);
    return this.size === a && this.textSize === ha.BASESIZE && this.style === t ? this : this.extend({
      style: t,
      size: a
    });
  }
  /**
   * Remove the effect of sizing changes such as \Huge.
   * Keep the effect of the current style, such as \scriptstyle.
   */
  havingBaseSizing() {
    var t;
    switch (this.style.id) {
      case 4:
      case 5:
        t = 3;
        break;
      case 6:
      case 7:
        t = 1;
        break;
      default:
        t = 6;
    }
    return this.extend({
      style: this.style.text(),
      size: t
    });
  }
  /**
   * Create a new options object with the given color.
   */
  withColor(t) {
    return this.extend({
      color: t
    });
  }
  /**
   * Create a new options object with "phantom" set to true.
   */
  withPhantom() {
    return this.extend({
      phantom: !0
    });
  }
  /**
   * Creates a new options object with the given math font or old text font.
   * @type {[type]}
   */
  withFont(t) {
    return this.extend({
      font: t
    });
  }
  /**
   * Create a new options objects with the given fontFamily.
   */
  withTextFontFamily(t) {
    return this.extend({
      fontFamily: t,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontWeight(t) {
    return this.extend({
      fontWeight: t,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontShape(t) {
    return this.extend({
      fontShape: t,
      font: ""
    });
  }
  /**
   * Return the CSS sizing classes required to switch from enclosing options
   * `oldOptions` to `this`. Returns an array of classes.
   */
  sizingClasses(t) {
    return t.size !== this.size ? ["sizing", "reset-size" + t.size, "size" + this.size] : [];
  }
  /**
   * Return the CSS sizing classes required to switch to the base size. Like
   * `this.havingSize(BASESIZE).sizingClasses(this)`.
   */
  baseSizingClasses() {
    return this.size !== ha.BASESIZE ? ["sizing", "reset-size" + this.size, "size" + ha.BASESIZE] : [];
  }
  /**
   * Return the font metrics for this size.
   */
  fontMetrics() {
    return this._fontMetrics || (this._fontMetrics = Py(this.size)), this._fontMetrics;
  }
  /**
   * Gets the CSS color of the current options object
   */
  getColor() {
    return this.phantom ? "transparent" : this.color;
  }
}
ha.BASESIZE = 6;
var ai = {
  // https://en.wikibooks.org/wiki/LaTeX/Lengths and
  // https://tex.stackexchange.com/a/8263
  pt: 1,
  // TeX point
  mm: 7227 / 2540,
  // millimeter
  cm: 7227 / 254,
  // centimeter
  in: 72.27,
  // inch
  bp: 803 / 800,
  // big (PostScript) points
  pc: 12,
  // pica
  dd: 1238 / 1157,
  // didot
  cc: 14856 / 1157,
  // cicero (12 didot)
  nd: 685 / 642,
  // new didot
  nc: 1370 / 107,
  // new cicero (12 new didot)
  sp: 1 / 65536,
  // scaled point (TeX's internal smallest unit)
  // https://tex.stackexchange.com/a/41371
  px: 803 / 800
  // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
}, Uy = {
  ex: !0,
  em: !0,
  mu: !0
}, zu = function(t) {
  return typeof t != "string" && (t = t.unit), t in ai || t in Uy || t === "ex";
}, Ge = function(t, a) {
  var r;
  if (t.unit in ai)
    r = ai[t.unit] / a.fontMetrics().ptPerEm / a.sizeMultiplier;
  else if (t.unit === "mu")
    r = a.fontMetrics().cssEmPerMu;
  else {
    var n;
    if (a.style.isTight() ? n = a.havingStyle(a.style.text()) : n = a, t.unit === "ex")
      r = n.fontMetrics().xHeight;
    else if (t.unit === "em")
      r = n.fontMetrics().quad;
    else
      throw new Q("Invalid unit: '" + t.unit + "'");
    n !== a && (r *= n.sizeMultiplier / a.sizeMultiplier);
  }
  return Math.min(t.number * r, a.maxSize);
}, ee = function(t) {
  return +t.toFixed(4) + "em";
}, Ca = function(t) {
  return t.filter((a) => a).join(" ");
}, Nu = function(t, a, r) {
  if (this.classes = t || [], this.attributes = {}, this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = r || {}, a) {
    a.style.isTight() && this.classes.push("mtight");
    var n = a.getColor();
    n && (this.style.color = n);
  }
}, Iu = function(t) {
  var a = document.createElement(t);
  a.className = Ca(this.classes);
  for (var r in this.style)
    this.style.hasOwnProperty(r) && (a.style[r] = this.style[r]);
  for (var n in this.attributes)
    this.attributes.hasOwnProperty(n) && a.setAttribute(n, this.attributes[n]);
  for (var s = 0; s < this.children.length; s++)
    a.appendChild(this.children[s].toNode());
  return a;
}, Ru = function(t) {
  var a = "<" + t;
  this.classes.length && (a += ' class="' + me.escape(Ca(this.classes)) + '"');
  var r = "";
  for (var n in this.style)
    this.style.hasOwnProperty(n) && (r += me.hyphenate(n) + ":" + this.style[n] + ";");
  r && (a += ' style="' + me.escape(r) + '"');
  for (var s in this.attributes)
    this.attributes.hasOwnProperty(s) && (a += " " + s + '="' + me.escape(this.attributes[s]) + '"');
  a += ">";
  for (var i = 0; i < this.children.length; i++)
    a += this.children[i].toMarkup();
  return a += "</" + t + ">", a;
};
class tn {
  constructor(t, a, r, n) {
    this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.width = void 0, this.maxFontSize = void 0, this.style = void 0, Nu.call(this, t, r, n), this.children = a || [];
  }
  /**
   * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
   * all browsers support attributes the same, and having too many custom
   * attributes is probably bad.
   */
  setAttribute(t, a) {
    this.attributes[t] = a;
  }
  hasClass(t) {
    return me.contains(this.classes, t);
  }
  toNode() {
    return Iu.call(this, "span");
  }
  toMarkup() {
    return Ru.call(this, "span");
  }
}
class Bi {
  constructor(t, a, r, n) {
    this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, Nu.call(this, a, n), this.children = r || [], this.setAttribute("href", t);
  }
  setAttribute(t, a) {
    this.attributes[t] = a;
  }
  hasClass(t) {
    return me.contains(this.classes, t);
  }
  toNode() {
    return Iu.call(this, "a");
  }
  toMarkup() {
    return Ru.call(this, "a");
  }
}
class jy {
  constructor(t, a, r) {
    this.src = void 0, this.alt = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.alt = a, this.src = t, this.classes = ["mord"], this.style = r;
  }
  hasClass(t) {
    return me.contains(this.classes, t);
  }
  toNode() {
    var t = document.createElement("img");
    t.src = this.src, t.alt = this.alt, t.className = "mord";
    for (var a in this.style)
      this.style.hasOwnProperty(a) && (t.style[a] = this.style[a]);
    return t;
  }
  toMarkup() {
    var t = '<img src="' + me.escape(this.src) + '"' + (' alt="' + me.escape(this.alt) + '"'), a = "";
    for (var r in this.style)
      this.style.hasOwnProperty(r) && (a += me.hyphenate(r) + ":" + this.style[r] + ";");
    return a && (t += ' style="' + me.escape(a) + '"'), t += "'/>", t;
  }
}
var qy = {
  : "",
  : "",
  : "",
  // '': '\u0131\u0304', // enable when we add Extended Latin
  : ""
};
class Ht {
  constructor(t, a, r, n, s, i, o, c) {
    this.text = void 0, this.height = void 0, this.depth = void 0, this.italic = void 0, this.skew = void 0, this.width = void 0, this.maxFontSize = void 0, this.classes = void 0, this.style = void 0, this.text = t, this.height = a || 0, this.depth = r || 0, this.italic = n || 0, this.skew = s || 0, this.width = i || 0, this.classes = o || [], this.style = c || {}, this.maxFontSize = 0;
    var u = Dy(this.text.charCodeAt(0));
    u && this.classes.push(u + "_fallback"), /[]/.test(this.text) && (this.text = qy[this.text]);
  }
  hasClass(t) {
    return me.contains(this.classes, t);
  }
  /**
   * Creates a text node or span from a symbol node. Note that a span is only
   * created if it is needed.
   */
  toNode() {
    var t = document.createTextNode(this.text), a = null;
    this.italic > 0 && (a = document.createElement("span"), a.style.marginRight = ee(this.italic)), this.classes.length > 0 && (a = a || document.createElement("span"), a.className = Ca(this.classes));
    for (var r in this.style)
      this.style.hasOwnProperty(r) && (a = a || document.createElement("span"), a.style[r] = this.style[r]);
    return a ? (a.appendChild(t), a) : t;
  }
  /**
   * Creates markup for a symbol node.
   */
  toMarkup() {
    var t = !1, a = "<span";
    this.classes.length && (t = !0, a += ' class="', a += me.escape(Ca(this.classes)), a += '"');
    var r = "";
    this.italic > 0 && (r += "margin-right:" + this.italic + "em;");
    for (var n in this.style)
      this.style.hasOwnProperty(n) && (r += me.hyphenate(n) + ":" + this.style[n] + ";");
    r && (t = !0, a += ' style="' + me.escape(r) + '"');
    var s = me.escape(this.text);
    return t ? (a += ">", a += s, a += "</span>", a) : s;
  }
}
class pa {
  constructor(t, a) {
    this.children = void 0, this.attributes = void 0, this.children = t || [], this.attributes = a || {};
  }
  toNode() {
    var t = "http://www.w3.org/2000/svg", a = document.createElementNS(t, "svg");
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && a.setAttribute(r, this.attributes[r]);
    for (var n = 0; n < this.children.length; n++)
      a.appendChild(this.children[n].toNode());
    return a;
  }
  toMarkup() {
    var t = '<svg xmlns="http://www.w3.org/2000/svg"';
    for (var a in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, a) && (t += " " + a + '="' + me.escape(this.attributes[a]) + '"');
    t += ">";
    for (var r = 0; r < this.children.length; r++)
      t += this.children[r].toMarkup();
    return t += "</svg>", t;
  }
}
class Sa {
  constructor(t, a) {
    this.pathName = void 0, this.alternate = void 0, this.pathName = t, this.alternate = a;
  }
  toNode() {
    var t = "http://www.w3.org/2000/svg", a = document.createElementNS(t, "path");
    return this.alternate ? a.setAttribute("d", this.alternate) : a.setAttribute("d", fc[this.pathName]), a;
  }
  toMarkup() {
    return this.alternate ? '<path d="' + me.escape(this.alternate) + '"/>' : '<path d="' + me.escape(fc[this.pathName]) + '"/>';
  }
}
class ri {
  constructor(t) {
    this.attributes = void 0, this.attributes = t || {};
  }
  toNode() {
    var t = "http://www.w3.org/2000/svg", a = document.createElementNS(t, "line");
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && a.setAttribute(r, this.attributes[r]);
    return a;
  }
  toMarkup() {
    var t = "<line";
    for (var a in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, a) && (t += " " + a + '="' + me.escape(this.attributes[a]) + '"');
    return t += "/>", t;
  }
}
function pc(e) {
  if (e instanceof Ht)
    return e;
  throw new Error("Expected symbolNode but got " + String(e) + ".");
}
function Yy(e) {
  if (e instanceof tn)
    return e;
  throw new Error("Expected span<HtmlDomNode> but got " + String(e) + ".");
}
var Vy = {
  bin: 1,
  close: 1,
  inner: 1,
  open: 1,
  punct: 1,
  rel: 1
}, Gy = {
  "accent-token": 1,
  mathord: 1,
  "op-token": 1,
  spacing: 1,
  textord: 1
}, Pe = {
  math: {},
  text: {}
};
function f(e, t, a, r, n, s) {
  Pe[e][n] = {
    font: t,
    group: a,
    replace: r
  }, s && r && (Pe[e][r] = Pe[e][n]);
}
var g = "math", V = "text", b = "main", x = "ams", Ye = "accent-token", ie = "bin", bt = "close", ur = "inner", pe = "mathord", Ze = "op-token", It = "open", Wn = "punct", A = "rel", ba = "spacing", I = "textord";
f(g, b, A, "", "\\equiv", !0);
f(g, b, A, "", "\\prec", !0);
f(g, b, A, "", "\\succ", !0);
f(g, b, A, "", "\\sim", !0);
f(g, b, A, "", "\\perp");
f(g, b, A, "", "\\preceq", !0);
f(g, b, A, "", "\\succeq", !0);
f(g, b, A, "", "\\simeq", !0);
f(g, b, A, "", "\\mid", !0);
f(g, b, A, "", "\\ll", !0);
f(g, b, A, "", "\\gg", !0);
f(g, b, A, "", "\\asymp", !0);
f(g, b, A, "", "\\parallel");
f(g, b, A, "", "\\bowtie", !0);
f(g, b, A, "", "\\smile", !0);
f(g, b, A, "", "\\sqsubseteq", !0);
f(g, b, A, "", "\\sqsupseteq", !0);
f(g, b, A, "", "\\doteq", !0);
f(g, b, A, "", "\\frown", !0);
f(g, b, A, "", "\\ni", !0);
f(g, b, A, "", "\\propto", !0);
f(g, b, A, "", "\\vdash", !0);
f(g, b, A, "", "\\dashv", !0);
f(g, b, A, "", "\\owns");
f(g, b, Wn, ".", "\\ldotp");
f(g, b, Wn, "", "\\cdotp");
f(g, b, I, "#", "\\#");
f(V, b, I, "#", "\\#");
f(g, b, I, "&", "\\&");
f(V, b, I, "&", "\\&");
f(g, b, I, "", "\\aleph", !0);
f(g, b, I, "", "\\forall", !0);
f(g, b, I, "", "\\hbar", !0);
f(g, b, I, "", "\\exists", !0);
f(g, b, I, "", "\\nabla", !0);
f(g, b, I, "", "\\flat", !0);
f(g, b, I, "", "\\ell", !0);
f(g, b, I, "", "\\natural", !0);
f(g, b, I, "", "\\clubsuit", !0);
f(g, b, I, "", "\\wp", !0);
f(g, b, I, "", "\\sharp", !0);
f(g, b, I, "", "\\diamondsuit", !0);
f(g, b, I, "", "\\Re", !0);
f(g, b, I, "", "\\heartsuit", !0);
f(g, b, I, "", "\\Im", !0);
f(g, b, I, "", "\\spadesuit", !0);
f(g, b, I, "", "\\S", !0);
f(V, b, I, "", "\\S");
f(g, b, I, "", "\\P", !0);
f(V, b, I, "", "\\P");
f(g, b, I, "", "\\dag");
f(V, b, I, "", "\\dag");
f(V, b, I, "", "\\textdagger");
f(g, b, I, "", "\\ddag");
f(V, b, I, "", "\\ddag");
f(V, b, I, "", "\\textdaggerdbl");
f(g, b, bt, "", "\\rmoustache", !0);
f(g, b, It, "", "\\lmoustache", !0);
f(g, b, bt, "", "\\rgroup", !0);
f(g, b, It, "", "\\lgroup", !0);
f(g, b, ie, "", "\\mp", !0);
f(g, b, ie, "", "\\ominus", !0);
f(g, b, ie, "", "\\uplus", !0);
f(g, b, ie, "", "\\sqcap", !0);
f(g, b, ie, "", "\\ast");
f(g, b, ie, "", "\\sqcup", !0);
f(g, b, ie, "", "\\bigcirc", !0);
f(g, b, ie, "", "\\bullet", !0);
f(g, b, ie, "", "\\ddagger");
f(g, b, ie, "", "\\wr", !0);
f(g, b, ie, "", "\\amalg");
f(g, b, ie, "&", "\\And");
f(g, b, A, "", "\\longleftarrow", !0);
f(g, b, A, "", "\\Leftarrow", !0);
f(g, b, A, "", "\\Longleftarrow", !0);
f(g, b, A, "", "\\longrightarrow", !0);
f(g, b, A, "", "\\Rightarrow", !0);
f(g, b, A, "", "\\Longrightarrow", !0);
f(g, b, A, "", "\\leftrightarrow", !0);
f(g, b, A, "", "\\longleftrightarrow", !0);
f(g, b, A, "", "\\Leftrightarrow", !0);
f(g, b, A, "", "\\Longleftrightarrow", !0);
f(g, b, A, "", "\\mapsto", !0);
f(g, b, A, "", "\\longmapsto", !0);
f(g, b, A, "", "\\nearrow", !0);
f(g, b, A, "", "\\hookleftarrow", !0);
f(g, b, A, "", "\\hookrightarrow", !0);
f(g, b, A, "", "\\searrow", !0);
f(g, b, A, "", "\\leftharpoonup", !0);
f(g, b, A, "", "\\rightharpoonup", !0);
f(g, b, A, "", "\\swarrow", !0);
f(g, b, A, "", "\\leftharpoondown", !0);
f(g, b, A, "", "\\rightharpoondown", !0);
f(g, b, A, "", "\\nwarrow", !0);
f(g, b, A, "", "\\rightleftharpoons", !0);
f(g, x, A, "", "\\nless", !0);
f(g, x, A, "", "\\@nleqslant");
f(g, x, A, "", "\\@nleqq");
f(g, x, A, "", "\\lneq", !0);
f(g, x, A, "", "\\lneqq", !0);
f(g, x, A, "", "\\@lvertneqq");
f(g, x, A, "", "\\lnsim", !0);
f(g, x, A, "", "\\lnapprox", !0);
f(g, x, A, "", "\\nprec", !0);
f(g, x, A, "", "\\npreceq", !0);
f(g, x, A, "", "\\precnsim", !0);
f(g, x, A, "", "\\precnapprox", !0);
f(g, x, A, "", "\\nsim", !0);
f(g, x, A, "", "\\@nshortmid");
f(g, x, A, "", "\\nmid", !0);
f(g, x, A, "", "\\nvdash", !0);
f(g, x, A, "", "\\nvDash", !0);
f(g, x, A, "", "\\ntriangleleft");
f(g, x, A, "", "\\ntrianglelefteq", !0);
f(g, x, A, "", "\\subsetneq", !0);
f(g, x, A, "", "\\@varsubsetneq");
f(g, x, A, "", "\\subsetneqq", !0);
f(g, x, A, "", "\\@varsubsetneqq");
f(g, x, A, "", "\\ngtr", !0);
f(g, x, A, "", "\\@ngeqslant");
f(g, x, A, "", "\\@ngeqq");
f(g, x, A, "", "\\gneq", !0);
f(g, x, A, "", "\\gneqq", !0);
f(g, x, A, "", "\\@gvertneqq");
f(g, x, A, "", "\\gnsim", !0);
f(g, x, A, "", "\\gnapprox", !0);
f(g, x, A, "", "\\nsucc", !0);
f(g, x, A, "", "\\nsucceq", !0);
f(g, x, A, "", "\\succnsim", !0);
f(g, x, A, "", "\\succnapprox", !0);
f(g, x, A, "", "\\ncong", !0);
f(g, x, A, "", "\\@nshortparallel");
f(g, x, A, "", "\\nparallel", !0);
f(g, x, A, "", "\\nVDash", !0);
f(g, x, A, "", "\\ntriangleright");
f(g, x, A, "", "\\ntrianglerighteq", !0);
f(g, x, A, "", "\\@nsupseteqq");
f(g, x, A, "", "\\supsetneq", !0);
f(g, x, A, "", "\\@varsupsetneq");
f(g, x, A, "", "\\supsetneqq", !0);
f(g, x, A, "", "\\@varsupsetneqq");
f(g, x, A, "", "\\nVdash", !0);
f(g, x, A, "", "\\precneqq", !0);
f(g, x, A, "", "\\succneqq", !0);
f(g, x, A, "", "\\@nsubseteqq");
f(g, x, ie, "", "\\unlhd");
f(g, x, ie, "", "\\unrhd");
f(g, x, A, "", "\\nleftarrow", !0);
f(g, x, A, "", "\\nrightarrow", !0);
f(g, x, A, "", "\\nLeftarrow", !0);
f(g, x, A, "", "\\nRightarrow", !0);
f(g, x, A, "", "\\nleftrightarrow", !0);
f(g, x, A, "", "\\nLeftrightarrow", !0);
f(g, x, A, "", "\\vartriangle");
f(g, x, I, "", "\\hslash");
f(g, x, I, "", "\\triangledown");
f(g, x, I, "", "\\lozenge");
f(g, x, I, "", "\\circledS");
f(g, x, I, "", "\\circledR");
f(V, x, I, "", "\\circledR");
f(g, x, I, "", "\\measuredangle", !0);
f(g, x, I, "", "\\nexists");
f(g, x, I, "", "\\mho");
f(g, x, I, "", "\\Finv", !0);
f(g, x, I, "", "\\Game", !0);
f(g, x, I, "", "\\backprime");
f(g, x, I, "", "\\blacktriangle");
f(g, x, I, "", "\\blacktriangledown");
f(g, x, I, "", "\\blacksquare");
f(g, x, I, "", "\\blacklozenge");
f(g, x, I, "", "\\bigstar");
f(g, x, I, "", "\\sphericalangle", !0);
f(g, x, I, "", "\\complement", !0);
f(g, x, I, "", "\\eth", !0);
f(V, b, I, "", "");
f(g, x, I, "", "\\diagup");
f(g, x, I, "", "\\diagdown");
f(g, x, I, "", "\\square");
f(g, x, I, "", "\\Box");
f(g, x, I, "", "\\Diamond");
f(g, x, I, "", "\\yen", !0);
f(V, x, I, "", "\\yen", !0);
f(g, x, I, "", "\\checkmark", !0);
f(V, x, I, "", "\\checkmark");
f(g, x, I, "", "\\beth", !0);
f(g, x, I, "", "\\daleth", !0);
f(g, x, I, "", "\\gimel", !0);
f(g, x, I, "", "\\digamma", !0);
f(g, x, I, "", "\\varkappa");
f(g, x, It, "", "\\@ulcorner", !0);
f(g, x, bt, "", "\\@urcorner", !0);
f(g, x, It, "", "\\@llcorner", !0);
f(g, x, bt, "", "\\@lrcorner", !0);
f(g, x, A, "", "\\leqq", !0);
f(g, x, A, "", "\\leqslant", !0);
f(g, x, A, "", "\\eqslantless", !0);
f(g, x, A, "", "\\lesssim", !0);
f(g, x, A, "", "\\lessapprox", !0);
f(g, x, A, "", "\\approxeq", !0);
f(g, x, ie, "", "\\lessdot");
f(g, x, A, "", "\\lll", !0);
f(g, x, A, "", "\\lessgtr", !0);
f(g, x, A, "", "\\lesseqgtr", !0);
f(g, x, A, "", "\\lesseqqgtr", !0);
f(g, x, A, "", "\\doteqdot");
f(g, x, A, "", "\\risingdotseq", !0);
f(g, x, A, "", "\\fallingdotseq", !0);
f(g, x, A, "", "\\backsim", !0);
f(g, x, A, "", "\\backsimeq", !0);
f(g, x, A, "", "\\subseteqq", !0);
f(g, x, A, "", "\\Subset", !0);
f(g, x, A, "", "\\sqsubset", !0);
f(g, x, A, "", "\\preccurlyeq", !0);
f(g, x, A, "", "\\curlyeqprec", !0);
f(g, x, A, "", "\\precsim", !0);
f(g, x, A, "", "\\precapprox", !0);
f(g, x, A, "", "\\vartriangleleft");
f(g, x, A, "", "\\trianglelefteq");
f(g, x, A, "", "\\vDash", !0);
f(g, x, A, "", "\\Vvdash", !0);
f(g, x, A, "", "\\smallsmile");
f(g, x, A, "", "\\smallfrown");
f(g, x, A, "", "\\bumpeq", !0);
f(g, x, A, "", "\\Bumpeq", !0);
f(g, x, A, "", "\\geqq", !0);
f(g, x, A, "", "\\geqslant", !0);
f(g, x, A, "", "\\eqslantgtr", !0);
f(g, x, A, "", "\\gtrsim", !0);
f(g, x, A, "", "\\gtrapprox", !0);
f(g, x, ie, "", "\\gtrdot");
f(g, x, A, "", "\\ggg", !0);
f(g, x, A, "", "\\gtrless", !0);
f(g, x, A, "", "\\gtreqless", !0);
f(g, x, A, "", "\\gtreqqless", !0);
f(g, x, A, "", "\\eqcirc", !0);
f(g, x, A, "", "\\circeq", !0);
f(g, x, A, "", "\\triangleq", !0);
f(g, x, A, "", "\\thicksim");
f(g, x, A, "", "\\thickapprox");
f(g, x, A, "", "\\supseteqq", !0);
f(g, x, A, "", "\\Supset", !0);
f(g, x, A, "", "\\sqsupset", !0);
f(g, x, A, "", "\\succcurlyeq", !0);
f(g, x, A, "", "\\curlyeqsucc", !0);
f(g, x, A, "", "\\succsim", !0);
f(g, x, A, "", "\\succapprox", !0);
f(g, x, A, "", "\\vartriangleright");
f(g, x, A, "", "\\trianglerighteq");
f(g, x, A, "", "\\Vdash", !0);
f(g, x, A, "", "\\shortmid");
f(g, x, A, "", "\\shortparallel");
f(g, x, A, "", "\\between", !0);
f(g, x, A, "", "\\pitchfork", !0);
f(g, x, A, "", "\\varpropto");
f(g, x, A, "", "\\blacktriangleleft");
f(g, x, A, "", "\\therefore", !0);
f(g, x, A, "", "\\backepsilon");
f(g, x, A, "", "\\blacktriangleright");
f(g, x, A, "", "\\because", !0);
f(g, x, A, "", "\\llless");
f(g, x, A, "", "\\gggtr");
f(g, x, ie, "", "\\lhd");
f(g, x, ie, "", "\\rhd");
f(g, x, A, "", "\\eqsim", !0);
f(g, b, A, "", "\\Join");
f(g, x, A, "", "\\Doteq", !0);
f(g, x, ie, "", "\\dotplus", !0);
f(g, x, ie, "", "\\smallsetminus");
f(g, x, ie, "", "\\Cap", !0);
f(g, x, ie, "", "\\Cup", !0);
f(g, x, ie, "", "\\doublebarwedge", !0);
f(g, x, ie, "", "\\boxminus", !0);
f(g, x, ie, "", "\\boxplus", !0);
f(g, x, ie, "", "\\divideontimes", !0);
f(g, x, ie, "", "\\ltimes", !0);
f(g, x, ie, "", "\\rtimes", !0);
f(g, x, ie, "", "\\leftthreetimes", !0);
f(g, x, ie, "", "\\rightthreetimes", !0);
f(g, x, ie, "", "\\curlywedge", !0);
f(g, x, ie, "", "\\curlyvee", !0);
f(g, x, ie, "", "\\circleddash", !0);
f(g, x, ie, "", "\\circledast", !0);
f(g, x, ie, "", "\\centerdot");
f(g, x, ie, "", "\\intercal", !0);
f(g, x, ie, "", "\\doublecap");
f(g, x, ie, "", "\\doublecup");
f(g, x, ie, "", "\\boxtimes", !0);
f(g, x, A, "", "\\dashrightarrow", !0);
f(g, x, A, "", "\\dashleftarrow", !0);
f(g, x, A, "", "\\leftleftarrows", !0);
f(g, x, A, "", "\\leftrightarrows", !0);
f(g, x, A, "", "\\Lleftarrow", !0);
f(g, x, A, "", "\\twoheadleftarrow", !0);
f(g, x, A, "", "\\leftarrowtail", !0);
f(g, x, A, "", "\\looparrowleft", !0);
f(g, x, A, "", "\\leftrightharpoons", !0);
f(g, x, A, "", "\\curvearrowleft", !0);
f(g, x, A, "", "\\circlearrowleft", !0);
f(g, x, A, "", "\\Lsh", !0);
f(g, x, A, "", "\\upuparrows", !0);
f(g, x, A, "", "\\upharpoonleft", !0);
f(g, x, A, "", "\\downharpoonleft", !0);
f(g, b, A, "", "\\origof", !0);
f(g, b, A, "", "\\imageof", !0);
f(g, x, A, "", "\\multimap", !0);
f(g, x, A, "", "\\leftrightsquigarrow", !0);
f(g, x, A, "", "\\rightrightarrows", !0);
f(g, x, A, "", "\\rightleftarrows", !0);
f(g, x, A, "", "\\twoheadrightarrow", !0);
f(g, x, A, "", "\\rightarrowtail", !0);
f(g, x, A, "", "\\looparrowright", !0);
f(g, x, A, "", "\\curvearrowright", !0);
f(g, x, A, "", "\\circlearrowright", !0);
f(g, x, A, "", "\\Rsh", !0);
f(g, x, A, "", "\\downdownarrows", !0);
f(g, x, A, "", "\\upharpoonright", !0);
f(g, x, A, "", "\\downharpoonright", !0);
f(g, x, A, "", "\\rightsquigarrow", !0);
f(g, x, A, "", "\\leadsto");
f(g, x, A, "", "\\Rrightarrow", !0);
f(g, x, A, "", "\\restriction");
f(g, b, I, "", "`");
f(g, b, I, "$", "\\$");
f(V, b, I, "$", "\\$");
f(V, b, I, "$", "\\textdollar");
f(g, b, I, "%", "\\%");
f(V, b, I, "%", "\\%");
f(g, b, I, "_", "\\_");
f(V, b, I, "_", "\\_");
f(V, b, I, "_", "\\textunderscore");
f(g, b, I, "", "\\angle", !0);
f(g, b, I, "", "\\infty", !0);
f(g, b, I, "", "\\prime");
f(g, b, I, "", "\\triangle");
f(g, b, I, "", "\\Gamma", !0);
f(g, b, I, "", "\\Delta", !0);
f(g, b, I, "", "\\Theta", !0);
f(g, b, I, "", "\\Lambda", !0);
f(g, b, I, "", "\\Xi", !0);
f(g, b, I, "", "\\Pi", !0);
f(g, b, I, "", "\\Sigma", !0);
f(g, b, I, "", "\\Upsilon", !0);
f(g, b, I, "", "\\Phi", !0);
f(g, b, I, "", "\\Psi", !0);
f(g, b, I, "", "\\Omega", !0);
f(g, b, I, "A", "");
f(g, b, I, "B", "");
f(g, b, I, "E", "");
f(g, b, I, "Z", "");
f(g, b, I, "H", "");
f(g, b, I, "I", "");
f(g, b, I, "K", "");
f(g, b, I, "M", "");
f(g, b, I, "N", "");
f(g, b, I, "O", "");
f(g, b, I, "P", "");
f(g, b, I, "T", "");
f(g, b, I, "X", "");
f(g, b, I, "", "\\neg", !0);
f(g, b, I, "", "\\lnot");
f(g, b, I, "", "\\top");
f(g, b, I, "", "\\bot");
f(g, b, I, "", "\\emptyset");
f(g, x, I, "", "\\varnothing");
f(g, b, pe, "", "\\alpha", !0);
f(g, b, pe, "", "\\beta", !0);
f(g, b, pe, "", "\\gamma", !0);
f(g, b, pe, "", "\\delta", !0);
f(g, b, pe, "", "\\epsilon", !0);
f(g, b, pe, "", "\\zeta", !0);
f(g, b, pe, "", "\\eta", !0);
f(g, b, pe, "", "\\theta", !0);
f(g, b, pe, "", "\\iota", !0);
f(g, b, pe, "", "\\kappa", !0);
f(g, b, pe, "", "\\lambda", !0);
f(g, b, pe, "", "\\mu", !0);
f(g, b, pe, "", "\\nu", !0);
f(g, b, pe, "", "\\xi", !0);
f(g, b, pe, "", "\\omicron", !0);
f(g, b, pe, "", "\\pi", !0);
f(g, b, pe, "", "\\rho", !0);
f(g, b, pe, "", "\\sigma", !0);
f(g, b, pe, "", "\\tau", !0);
f(g, b, pe, "", "\\upsilon", !0);
f(g, b, pe, "", "\\phi", !0);
f(g, b, pe, "", "\\chi", !0);
f(g, b, pe, "", "\\psi", !0);
f(g, b, pe, "", "\\omega", !0);
f(g, b, pe, "", "\\varepsilon", !0);
f(g, b, pe, "", "\\vartheta", !0);
f(g, b, pe, "", "\\varpi", !0);
f(g, b, pe, "", "\\varrho", !0);
f(g, b, pe, "", "\\varsigma", !0);
f(g, b, pe, "", "\\varphi", !0);
f(g, b, ie, "", "*", !0);
f(g, b, ie, "+", "+");
f(g, b, ie, "", "-", !0);
f(g, b, ie, "", "\\cdot", !0);
f(g, b, ie, "", "\\circ", !0);
f(g, b, ie, "", "\\div", !0);
f(g, b, ie, "", "\\pm", !0);
f(g, b, ie, "", "\\times", !0);
f(g, b, ie, "", "\\cap", !0);
f(g, b, ie, "", "\\cup", !0);
f(g, b, ie, "", "\\setminus", !0);
f(g, b, ie, "", "\\land");
f(g, b, ie, "", "\\lor");
f(g, b, ie, "", "\\wedge", !0);
f(g, b, ie, "", "\\vee", !0);
f(g, b, I, "", "\\surd");
f(g, b, It, "", "\\langle", !0);
f(g, b, It, "", "\\lvert");
f(g, b, It, "", "\\lVert");
f(g, b, bt, "?", "?");
f(g, b, bt, "!", "!");
f(g, b, bt, "", "\\rangle", !0);
f(g, b, bt, "", "\\rvert");
f(g, b, bt, "", "\\rVert");
f(g, b, A, "=", "=");
f(g, b, A, ":", ":");
f(g, b, A, "", "\\approx", !0);
f(g, b, A, "", "\\cong", !0);
f(g, b, A, "", "\\ge");
f(g, b, A, "", "\\geq", !0);
f(g, b, A, "", "\\gets");
f(g, b, A, ">", "\\gt", !0);
f(g, b, A, "", "\\in", !0);
f(g, b, A, "", "\\@not");
f(g, b, A, "", "\\subset", !0);
f(g, b, A, "", "\\supset", !0);
f(g, b, A, "", "\\subseteq", !0);
f(g, b, A, "", "\\supseteq", !0);
f(g, x, A, "", "\\nsubseteq", !0);
f(g, x, A, "", "\\nsupseteq", !0);
f(g, b, A, "", "\\models");
f(g, b, A, "", "\\leftarrow", !0);
f(g, b, A, "", "\\le");
f(g, b, A, "", "\\leq", !0);
f(g, b, A, "<", "\\lt", !0);
f(g, b, A, "", "\\rightarrow", !0);
f(g, b, A, "", "\\to");
f(g, x, A, "", "\\ngeq", !0);
f(g, x, A, "", "\\nleq", !0);
f(g, b, ba, "", "\\ ");
f(g, b, ba, "", "\\space");
f(g, b, ba, "", "\\nobreakspace");
f(V, b, ba, "", "\\ ");
f(V, b, ba, "", " ");
f(V, b, ba, "", "\\space");
f(V, b, ba, "", "\\nobreakspace");
f(g, b, ba, null, "\\nobreak");
f(g, b, ba, null, "\\allowbreak");
f(g, b, Wn, ",", ",");
f(g, b, Wn, ";", ";");
f(g, x, ie, "", "\\barwedge", !0);
f(g, x, ie, "", "\\veebar", !0);
f(g, b, ie, "", "\\odot", !0);
f(g, b, ie, "", "\\oplus", !0);
f(g, b, ie, "", "\\otimes", !0);
f(g, b, I, "", "\\partial", !0);
f(g, b, ie, "", "\\oslash", !0);
f(g, x, ie, "", "\\circledcirc", !0);
f(g, x, ie, "", "\\boxdot", !0);
f(g, b, ie, "", "\\bigtriangleup");
f(g, b, ie, "", "\\bigtriangledown");
f(g, b, ie, "", "\\dagger");
f(g, b, ie, "", "\\diamond");
f(g, b, ie, "", "\\star");
f(g, b, ie, "", "\\triangleleft");
f(g, b, ie, "", "\\triangleright");
f(g, b, It, "{", "\\{");
f(V, b, I, "{", "\\{");
f(V, b, I, "{", "\\textbraceleft");
f(g, b, bt, "}", "\\}");
f(V, b, I, "}", "\\}");
f(V, b, I, "}", "\\textbraceright");
f(g, b, It, "{", "\\lbrace");
f(g, b, bt, "}", "\\rbrace");
f(g, b, It, "[", "\\lbrack", !0);
f(V, b, I, "[", "\\lbrack", !0);
f(g, b, bt, "]", "\\rbrack", !0);
f(V, b, I, "]", "\\rbrack", !0);
f(g, b, It, "(", "\\lparen", !0);
f(g, b, bt, ")", "\\rparen", !0);
f(V, b, I, "<", "\\textless", !0);
f(V, b, I, ">", "\\textgreater", !0);
f(g, b, It, "", "\\lfloor", !0);
f(g, b, bt, "", "\\rfloor", !0);
f(g, b, It, "", "\\lceil", !0);
f(g, b, bt, "", "\\rceil", !0);
f(g, b, I, "\\", "\\backslash");
f(g, b, I, "", "|");
f(g, b, I, "", "\\vert");
f(V, b, I, "|", "\\textbar", !0);
f(g, b, I, "", "\\|");
f(g, b, I, "", "\\Vert");
f(V, b, I, "", "\\textbardbl");
f(V, b, I, "~", "\\textasciitilde");
f(V, b, I, "\\", "\\textbackslash");
f(V, b, I, "^", "\\textasciicircum");
f(g, b, A, "", "\\uparrow", !0);
f(g, b, A, "", "\\Uparrow", !0);
f(g, b, A, "", "\\downarrow", !0);
f(g, b, A, "", "\\Downarrow", !0);
f(g, b, A, "", "\\updownarrow", !0);
f(g, b, A, "", "\\Updownarrow", !0);
f(g, b, Ze, "", "\\coprod");
f(g, b, Ze, "", "\\bigvee");
f(g, b, Ze, "", "\\bigwedge");
f(g, b, Ze, "", "\\biguplus");
f(g, b, Ze, "", "\\bigcap");
f(g, b, Ze, "", "\\bigcup");
f(g, b, Ze, "", "\\int");
f(g, b, Ze, "", "\\intop");
f(g, b, Ze, "", "\\iint");
f(g, b, Ze, "", "\\iiint");
f(g, b, Ze, "", "\\prod");
f(g, b, Ze, "", "\\sum");
f(g, b, Ze, "", "\\bigotimes");
f(g, b, Ze, "", "\\bigoplus");
f(g, b, Ze, "", "\\bigodot");
f(g, b, Ze, "", "\\oint");
f(g, b, Ze, "", "\\oiint");
f(g, b, Ze, "", "\\oiiint");
f(g, b, Ze, "", "\\bigsqcup");
f(g, b, Ze, "", "\\smallint");
f(V, b, ur, "", "\\textellipsis");
f(g, b, ur, "", "\\mathellipsis");
f(V, b, ur, "", "\\ldots", !0);
f(g, b, ur, "", "\\ldots", !0);
f(g, b, ur, "", "\\@cdots", !0);
f(g, b, ur, "", "\\ddots", !0);
f(g, b, I, "", "\\varvdots");
f(g, b, Ye, "", "\\acute");
f(g, b, Ye, "", "\\grave");
f(g, b, Ye, "", "\\ddot");
f(g, b, Ye, "~", "\\tilde");
f(g, b, Ye, "", "\\bar");
f(g, b, Ye, "", "\\breve");
f(g, b, Ye, "", "\\check");
f(g, b, Ye, "^", "\\hat");
f(g, b, Ye, "", "\\vec");
f(g, b, Ye, "", "\\dot");
f(g, b, Ye, "", "\\mathring");
f(g, b, pe, "", "\\@imath");
f(g, b, pe, "", "\\@jmath");
f(g, b, I, "", "");
f(g, b, I, "", "");
f(V, b, I, "", "\\i", !0);
f(V, b, I, "", "\\j", !0);
f(V, b, I, "", "\\ss", !0);
f(V, b, I, "", "\\ae", !0);
f(V, b, I, "", "\\oe", !0);
f(V, b, I, "", "\\o", !0);
f(V, b, I, "", "\\AE", !0);
f(V, b, I, "", "\\OE", !0);
f(V, b, I, "", "\\O", !0);
f(V, b, Ye, "", "\\'");
f(V, b, Ye, "", "\\`");
f(V, b, Ye, "", "\\^");
f(V, b, Ye, "", "\\~");
f(V, b, Ye, "", "\\=");
f(V, b, Ye, "", "\\u");
f(V, b, Ye, "", "\\.");
f(V, b, Ye, "", "\\c");
f(V, b, Ye, "", "\\r");
f(V, b, Ye, "", "\\v");
f(V, b, Ye, "", '\\"');
f(V, b, Ye, "", "\\H");
f(V, b, Ye, "", "\\textcircled");
var Fu = {
  "--": !0,
  "---": !0,
  "``": !0,
  "''": !0
};
f(V, b, I, "", "--", !0);
f(V, b, I, "", "\\textendash");
f(V, b, I, "", "---", !0);
f(V, b, I, "", "\\textemdash");
f(V, b, I, "", "`", !0);
f(V, b, I, "", "\\textquoteleft");
f(V, b, I, "", "'", !0);
f(V, b, I, "", "\\textquoteright");
f(V, b, I, "", "``", !0);
f(V, b, I, "", "\\textquotedblleft");
f(V, b, I, "", "''", !0);
f(V, b, I, "", "\\textquotedblright");
f(g, b, I, "", "\\degree", !0);
f(V, b, I, "", "\\degree");
f(V, b, I, "", "\\textdegree", !0);
f(g, b, I, "", "\\pounds");
f(g, b, I, "", "\\mathsterling", !0);
f(V, b, I, "", "\\pounds");
f(V, b, I, "", "\\textsterling", !0);
f(g, x, I, "", "\\maltese");
f(V, x, I, "", "\\maltese");
var gc = '0123456789/@."';
for (var Ss = 0; Ss < gc.length; Ss++) {
  var yc = gc.charAt(Ss);
  f(g, b, I, yc, yc);
}
var _c = '0123456789!@*()-=+";:?/.,';
for (var zs = 0; zs < _c.length; zs++) {
  var bc = _c.charAt(zs);
  f(V, b, I, bc, bc);
}
var Rn = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
for (var Ns = 0; Ns < Rn.length; Ns++) {
  var fn = Rn.charAt(Ns);
  f(g, b, pe, fn, fn), f(V, b, I, fn, fn);
}
f(g, x, I, "C", "");
f(V, x, I, "C", "");
f(g, x, I, "H", "");
f(V, x, I, "H", "");
f(g, x, I, "N", "");
f(V, x, I, "N", "");
f(g, x, I, "P", "");
f(V, x, I, "P", "");
f(g, x, I, "Q", "");
f(V, x, I, "Q", "");
f(g, x, I, "R", "");
f(V, x, I, "R", "");
f(g, x, I, "Z", "");
f(V, x, I, "Z", "");
f(g, b, pe, "h", "");
f(V, b, pe, "h", "");
var ye = "";
for (var gt = 0; gt < Rn.length; gt++) {
  var We = Rn.charAt(gt);
  ye = String.fromCharCode(55349, 56320 + gt), f(g, b, pe, We, ye), f(V, b, I, We, ye), ye = String.fromCharCode(55349, 56372 + gt), f(g, b, pe, We, ye), f(V, b, I, We, ye), ye = String.fromCharCode(55349, 56424 + gt), f(g, b, pe, We, ye), f(V, b, I, We, ye), ye = String.fromCharCode(55349, 56580 + gt), f(g, b, pe, We, ye), f(V, b, I, We, ye), ye = String.fromCharCode(55349, 56684 + gt), f(g, b, pe, We, ye), f(V, b, I, We, ye), ye = String.fromCharCode(55349, 56736 + gt), f(g, b, pe, We, ye), f(V, b, I, We, ye), ye = String.fromCharCode(55349, 56788 + gt), f(g, b, pe, We, ye), f(V, b, I, We, ye), ye = String.fromCharCode(55349, 56840 + gt), f(g, b, pe, We, ye), f(V, b, I, We, ye), ye = String.fromCharCode(55349, 56944 + gt), f(g, b, pe, We, ye), f(V, b, I, We, ye), gt < 26 && (ye = String.fromCharCode(55349, 56632 + gt), f(g, b, pe, We, ye), f(V, b, I, We, ye), ye = String.fromCharCode(55349, 56476 + gt), f(g, b, pe, We, ye), f(V, b, I, We, ye));
}
ye = "";
f(g, b, pe, "k", ye);
f(V, b, I, "k", ye);
for (var Ua = 0; Ua < 10; Ua++) {
  var Ea = Ua.toString();
  ye = String.fromCharCode(55349, 57294 + Ua), f(g, b, pe, Ea, ye), f(V, b, I, Ea, ye), ye = String.fromCharCode(55349, 57314 + Ua), f(g, b, pe, Ea, ye), f(V, b, I, Ea, ye), ye = String.fromCharCode(55349, 57324 + Ua), f(g, b, pe, Ea, ye), f(V, b, I, Ea, ye), ye = String.fromCharCode(55349, 57334 + Ua), f(g, b, pe, Ea, ye), f(V, b, I, Ea, ye);
}
var ni = "";
for (var Is = 0; Is < ni.length; Is++) {
  var hn = ni.charAt(Is);
  f(g, b, pe, hn, hn), f(V, b, I, hn, hn);
}
var dn = [
  ["mathbf", "textbf", "Main-Bold"],
  // A-Z bold upright
  ["mathbf", "textbf", "Main-Bold"],
  // a-z bold upright
  ["mathnormal", "textit", "Math-Italic"],
  // A-Z italic
  ["mathnormal", "textit", "Math-Italic"],
  // a-z italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // A-Z bold italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // a-z bold italic
  // Map fancy A-Z letters to script, not calligraphic.
  // This aligns with unicode-math and math fonts (except Cambria Math).
  ["mathscr", "textscr", "Script-Regular"],
  // A-Z script
  ["", "", ""],
  // a-z script.  No font
  ["", "", ""],
  // A-Z bold script. No font
  ["", "", ""],
  // a-z bold script. No font
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // A-Z Fraktur
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // a-z Fraktur
  ["mathbb", "textbb", "AMS-Regular"],
  // A-Z double-struck
  ["mathbb", "textbb", "AMS-Regular"],
  // k double-struck
  // Note that we are using a bold font, but font metrics for regular Fraktur.
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // A-Z bold Fraktur
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // a-z bold Fraktur
  ["mathsf", "textsf", "SansSerif-Regular"],
  // A-Z sans-serif
  ["mathsf", "textsf", "SansSerif-Regular"],
  // a-z sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // A-Z bold sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // a-z bold sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // A-Z italic sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // a-z italic sans-serif
  ["", "", ""],
  // A-Z bold italic sans. No font
  ["", "", ""],
  // a-z bold italic sans. No font
  ["mathtt", "texttt", "Typewriter-Regular"],
  // A-Z monospace
  ["mathtt", "texttt", "Typewriter-Regular"]
  // a-z monospace
], kc = [
  ["mathbf", "textbf", "Main-Bold"],
  // 0-9 bold
  ["", "", ""],
  // 0-9 double-struck. No KaTeX font.
  ["mathsf", "textsf", "SansSerif-Regular"],
  // 0-9 sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // 0-9 bold sans-serif
  ["mathtt", "texttt", "Typewriter-Regular"]
  // 0-9 monospace
], Wy = function(t, a) {
  var r = t.charCodeAt(0), n = t.charCodeAt(1), s = (r - 55296) * 1024 + (n - 56320) + 65536, i = a === "math" ? 0 : 1;
  if (119808 <= s && s < 120484) {
    var o = Math.floor((s - 119808) / 26);
    return [dn[o][2], dn[o][i]];
  } else if (120782 <= s && s <= 120831) {
    var c = Math.floor((s - 120782) / 10);
    return [kc[c][2], kc[c][i]];
  } else {
    if (s === 120485 || s === 120486)
      return [dn[0][2], dn[0][i]];
    if (120486 < s && s < 120782)
      return ["", ""];
    throw new Q("Unsupported character: " + t);
  }
}, $n = function(t, a, r) {
  return Pe[r][t] && Pe[r][t].replace && (t = Pe[r][t].replace), {
    value: t,
    metrics: Mi(t, a, r)
  };
}, Yt = function(t, a, r, n, s) {
  var i = $n(t, a, r), o = i.metrics;
  t = i.value;
  var c;
  if (o) {
    var u = o.italic;
    (r === "text" || n && n.font === "mathit") && (u = 0), c = new Ht(t, o.height, o.depth, u, o.skew, o.width, s);
  } else
    typeof console < "u" && console.warn("No character metrics " + ("for '" + t + "' in style '" + a + "' and mode '" + r + "'")), c = new Ht(t, 0, 0, 0, 0, 0, s);
  if (n) {
    c.maxFontSize = n.sizeMultiplier, n.style.isTight() && c.classes.push("mtight");
    var d = n.getColor();
    d && (c.style.color = d);
  }
  return c;
}, $y = function(t, a, r, n) {
  return n === void 0 && (n = []), r.font === "boldsymbol" && $n(t, "Main-Bold", a).metrics ? Yt(t, "Main-Bold", a, r, n.concat(["mathbf"])) : t === "\\" || Pe[a][t].font === "main" ? Yt(t, "Main-Regular", a, r, n) : Yt(t, "AMS-Regular", a, r, n.concat(["amsrm"]));
}, Xy = function(t, a, r, n, s) {
  return s !== "textord" && $n(t, "Math-BoldItalic", a).metrics ? {
    fontName: "Math-BoldItalic",
    fontClass: "boldsymbol"
  } : {
    fontName: "Main-Bold",
    fontClass: "mathbf"
  };
}, Qy = function(t, a, r) {
  var n = t.mode, s = t.text, i = ["mord"], o = n === "math" || n === "text" && a.font, c = o ? a.font : a.fontFamily, u = "", d = "";
  if (s.charCodeAt(0) === 55349 && ([u, d] = Wy(s, n)), u.length > 0)
    return Yt(s, u, n, a, i.concat(d));
  if (c) {
    var m, h;
    if (c === "boldsymbol") {
      var y = Xy(s, n, a, i, r);
      m = y.fontName, h = [y.fontClass];
    } else o ? (m = Mu[c].fontName, h = [c]) : (m = mn(c, a.fontWeight, a.fontShape), h = [c, a.fontWeight, a.fontShape]);
    if ($n(s, m, n).metrics)
      return Yt(s, m, n, a, i.concat(h));
    if (Fu.hasOwnProperty(s) && m.slice(0, 10) === "Typewriter") {
      for (var w = [], v = 0; v < s.length; v++)
        w.push(Yt(s[v], m, n, a, i.concat(h)));
      return Lu(w);
    }
  }
  if (r === "mathord")
    return Yt(s, "Math-Italic", n, a, i.concat(["mathnormal"]));
  if (r === "textord") {
    var F = Pe[n][s] && Pe[n][s].font;
    if (F === "ams") {
      var z = mn("amsrm", a.fontWeight, a.fontShape);
      return Yt(s, z, n, a, i.concat("amsrm", a.fontWeight, a.fontShape));
    } else if (F === "main" || !F) {
      var C = mn("textrm", a.fontWeight, a.fontShape);
      return Yt(s, C, n, a, i.concat(a.fontWeight, a.fontShape));
    } else {
      var U = mn(F, a.fontWeight, a.fontShape);
      return Yt(s, U, n, a, i.concat(U, a.fontWeight, a.fontShape));
    }
  } else
    throw new Error("unexpected type: " + r + " in makeOrd");
}, Ky = (e, t) => {
  if (Ca(e.classes) !== Ca(t.classes) || e.skew !== t.skew || e.maxFontSize !== t.maxFontSize)
    return !1;
  if (e.classes.length === 1) {
    var a = e.classes[0];
    if (a === "mbin" || a === "mord")
      return !1;
  }
  for (var r in e.style)
    if (e.style.hasOwnProperty(r) && e.style[r] !== t.style[r])
      return !1;
  for (var n in t.style)
    if (t.style.hasOwnProperty(n) && e.style[n] !== t.style[n])
      return !1;
  return !0;
}, Jy = (e) => {
  for (var t = 0; t < e.length - 1; t++) {
    var a = e[t], r = e[t + 1];
    a instanceof Ht && r instanceof Ht && Ky(a, r) && (a.text += r.text, a.height = Math.max(a.height, r.height), a.depth = Math.max(a.depth, r.depth), a.italic = r.italic, e.splice(t + 1, 1), t--);
  }
  return e;
}, Pi = function(t) {
  for (var a = 0, r = 0, n = 0, s = 0; s < t.children.length; s++) {
    var i = t.children[s];
    i.height > a && (a = i.height), i.depth > r && (r = i.depth), i.maxFontSize > n && (n = i.maxFontSize);
  }
  t.height = a, t.depth = r, t.maxFontSize = n;
}, Et = function(t, a, r, n) {
  var s = new tn(t, a, r, n);
  return Pi(s), s;
}, Ou = (e, t, a, r) => new tn(e, t, a, r), Zy = function(t, a, r) {
  var n = Et([t], [], a);
  return n.height = Math.max(r || a.fontMetrics().defaultRuleThickness, a.minRuleThickness), n.style.borderBottomWidth = ee(n.height), n.maxFontSize = 1, n;
}, e_ = function(t, a, r, n) {
  var s = new Bi(t, a, r, n);
  return Pi(s), s;
}, Lu = function(t) {
  var a = new en(t);
  return Pi(a), a;
}, t_ = function(t, a) {
  return t instanceof en ? Et([], [t], a) : t;
}, a_ = function(t) {
  if (t.positionType === "individualShift") {
    for (var a = t.children, r = [a[0]], n = -a[0].shift - a[0].elem.depth, s = n, i = 1; i < a.length; i++) {
      var o = -a[i].shift - s - a[i].elem.depth, c = o - (a[i - 1].elem.height + a[i - 1].elem.depth);
      s = s + o, r.push({
        type: "kern",
        size: c
      }), r.push(a[i]);
    }
    return {
      children: r,
      depth: n
    };
  }
  var u;
  if (t.positionType === "top") {
    for (var d = t.positionData, m = 0; m < t.children.length; m++) {
      var h = t.children[m];
      d -= h.type === "kern" ? h.size : h.elem.height + h.elem.depth;
    }
    u = d;
  } else if (t.positionType === "bottom")
    u = -t.positionData;
  else {
    var y = t.children[0];
    if (y.type !== "elem")
      throw new Error('First child must have type "elem".');
    if (t.positionType === "shift")
      u = -y.elem.depth - t.positionData;
    else if (t.positionType === "firstBaseline")
      u = -y.elem.depth;
    else
      throw new Error("Invalid positionType " + t.positionType + ".");
  }
  return {
    children: t.children,
    depth: u
  };
}, r_ = function(t, a) {
  for (var {
    children: r,
    depth: n
  } = a_(t), s = 0, i = 0; i < r.length; i++) {
    var o = r[i];
    if (o.type === "elem") {
      var c = o.elem;
      s = Math.max(s, c.maxFontSize, c.height);
    }
  }
  s += 2;
  var u = Et(["pstrut"], []);
  u.style.height = ee(s);
  for (var d = [], m = n, h = n, y = n, w = 0; w < r.length; w++) {
    var v = r[w];
    if (v.type === "kern")
      y += v.size;
    else {
      var F = v.elem, z = v.wrapperClasses || [], C = v.wrapperStyle || {}, U = Et(z, [u, F], void 0, C);
      U.style.top = ee(-s - y - F.depth), v.marginLeft && (U.style.marginLeft = v.marginLeft), v.marginRight && (U.style.marginRight = v.marginRight), d.push(U), y += F.height + F.depth;
    }
    m = Math.min(m, y), h = Math.max(h, y);
  }
  var $ = Et(["vlist"], d);
  $.style.height = ee(h);
  var O;
  if (m < 0) {
    var p = Et([], []), M = Et(["vlist"], [p]);
    M.style.height = ee(-m);
    var te = Et(["vlist-s"], [new Ht("")]);
    O = [Et(["vlist-r"], [$, te]), Et(["vlist-r"], [M])];
  } else
    O = [Et(["vlist-r"], [$])];
  var Z = Et(["vlist-t"], O);
  return O.length === 2 && Z.classes.push("vlist-t2"), Z.height = h, Z.depth = -m, Z;
}, n_ = (e, t) => {
  var a = Et(["mspace"], [], t), r = Ge(e, t);
  return a.style.marginRight = ee(r), a;
}, mn = function(t, a, r) {
  var n = "";
  switch (t) {
    case "amsrm":
      n = "AMS";
      break;
    case "textrm":
      n = "Main";
      break;
    case "textsf":
      n = "SansSerif";
      break;
    case "texttt":
      n = "Typewriter";
      break;
    default:
      n = t;
  }
  var s;
  return a === "textbf" && r === "textit" ? s = "BoldItalic" : a === "textbf" ? s = "Bold" : a === "textit" ? s = "Italic" : s = "Regular", n + "-" + s;
}, Mu = {
  // styles
  mathbf: {
    variant: "bold",
    fontName: "Main-Bold"
  },
  mathrm: {
    variant: "normal",
    fontName: "Main-Regular"
  },
  textit: {
    variant: "italic",
    fontName: "Main-Italic"
  },
  mathit: {
    variant: "italic",
    fontName: "Main-Italic"
  },
  mathnormal: {
    variant: "italic",
    fontName: "Math-Italic"
  },
  // "boldsymbol" is missing because they require the use of multiple fonts:
  // Math-BoldItalic and Main-Bold.  This is handled by a special case in
  // makeOrd which ends up calling boldsymbol.
  // families
  mathbb: {
    variant: "double-struck",
    fontName: "AMS-Regular"
  },
  mathcal: {
    variant: "script",
    fontName: "Caligraphic-Regular"
  },
  mathfrak: {
    variant: "fraktur",
    fontName: "Fraktur-Regular"
  },
  mathscr: {
    variant: "script",
    fontName: "Script-Regular"
  },
  mathsf: {
    variant: "sans-serif",
    fontName: "SansSerif-Regular"
  },
  mathtt: {
    variant: "monospace",
    fontName: "Typewriter-Regular"
  }
}, Bu = {
  //   path, width, height
  vec: ["vec", 0.471, 0.714],
  // values from the font glyph
  oiintSize1: ["oiintSize1", 0.957, 0.499],
  // oval to overlay the integrand
  oiintSize2: ["oiintSize2", 1.472, 0.659],
  oiiintSize1: ["oiiintSize1", 1.304, 0.499],
  oiiintSize2: ["oiiintSize2", 1.98, 0.659]
}, s_ = function(t, a) {
  var [r, n, s] = Bu[t], i = new Sa(r), o = new pa([i], {
    width: ee(n),
    height: ee(s),
    // Override CSS rule `.katex svg { width: 100% }`
    style: "width:" + ee(n),
    viewBox: "0 0 " + 1e3 * n + " " + 1e3 * s,
    preserveAspectRatio: "xMinYMin"
  }), c = Ou(["overlay"], [o], a);
  return c.height = s, c.style.height = ee(s), c.style.width = ee(n), c;
}, B = {
  fontMap: Mu,
  makeSymbol: Yt,
  mathsym: $y,
  makeSpan: Et,
  makeSvgSpan: Ou,
  makeLineSpan: Zy,
  makeAnchor: e_,
  makeFragment: Lu,
  wrapFragment: t_,
  makeVList: r_,
  makeOrd: Qy,
  makeGlue: n_,
  staticSvg: s_,
  svgData: Bu,
  tryCombineChars: Jy
}, Ve = {
  number: 3,
  unit: "mu"
}, ja = {
  number: 4,
  unit: "mu"
}, fa = {
  number: 5,
  unit: "mu"
}, i_ = {
  mord: {
    mop: Ve,
    mbin: ja,
    mrel: fa,
    minner: Ve
  },
  mop: {
    mord: Ve,
    mop: Ve,
    mrel: fa,
    minner: Ve
  },
  mbin: {
    mord: ja,
    mop: ja,
    mopen: ja,
    minner: ja
  },
  mrel: {
    mord: fa,
    mop: fa,
    mopen: fa,
    minner: fa
  },
  mopen: {},
  mclose: {
    mop: Ve,
    mbin: ja,
    mrel: fa,
    minner: Ve
  },
  mpunct: {
    mord: Ve,
    mop: Ve,
    mrel: fa,
    mopen: Ve,
    mclose: Ve,
    mpunct: Ve,
    minner: Ve
  },
  minner: {
    mord: Ve,
    mop: Ve,
    mbin: ja,
    mrel: fa,
    mopen: Ve,
    mpunct: Ve,
    minner: Ve
  }
}, o_ = {
  mord: {
    mop: Ve
  },
  mop: {
    mord: Ve,
    mop: Ve
  },
  mbin: {},
  mrel: {},
  mopen: {},
  mclose: {
    mop: Ve
  },
  mpunct: {},
  minner: {
    mop: Ve
  }
}, Pu = {}, Fn = {}, On = {};
function ne(e) {
  for (var {
    type: t,
    names: a,
    props: r,
    handler: n,
    htmlBuilder: s,
    mathmlBuilder: i
  } = e, o = {
    type: t,
    numArgs: r.numArgs,
    argTypes: r.argTypes,
    allowedInArgument: !!r.allowedInArgument,
    allowedInText: !!r.allowedInText,
    allowedInMath: r.allowedInMath === void 0 ? !0 : r.allowedInMath,
    numOptionalArgs: r.numOptionalArgs || 0,
    infix: !!r.infix,
    primitive: !!r.primitive,
    handler: n
  }, c = 0; c < a.length; ++c)
    Pu[a[c]] = o;
  t && (s && (Fn[t] = s), i && (On[t] = i));
}
function Wa(e) {
  var {
    type: t,
    htmlBuilder: a,
    mathmlBuilder: r
  } = e;
  ne({
    type: t,
    names: [],
    props: {
      numArgs: 0
    },
    handler() {
      throw new Error("Should never be called.");
    },
    htmlBuilder: a,
    mathmlBuilder: r
  });
}
var Ln = function(t) {
  return t.type === "ordgroup" && t.body.length === 1 ? t.body[0] : t;
}, Qe = function(t) {
  return t.type === "ordgroup" ? t.body : [t];
}, ga = B.makeSpan, c_ = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"], l_ = ["rightmost", "mrel", "mclose", "mpunct"], u_ = {
  display: ge.DISPLAY,
  text: ge.TEXT,
  script: ge.SCRIPT,
  scriptscript: ge.SCRIPTSCRIPT
}, f_ = {
  mord: "mord",
  mop: "mop",
  mbin: "mbin",
  mrel: "mrel",
  mopen: "mopen",
  mclose: "mclose",
  mpunct: "mpunct",
  minner: "minner"
}, nt = function(t, a, r, n) {
  n === void 0 && (n = [null, null]);
  for (var s = [], i = 0; i < t.length; i++) {
    var o = Ce(t[i], a);
    if (o instanceof en) {
      var c = o.children;
      s.push(...c);
    } else
      s.push(o);
  }
  if (B.tryCombineChars(s), !r)
    return s;
  var u = a;
  if (t.length === 1) {
    var d = t[0];
    d.type === "sizing" ? u = a.havingSize(d.size) : d.type === "styling" && (u = a.havingStyle(u_[d.style]));
  }
  var m = ga([n[0] || "leftmost"], [], a), h = ga([n[1] || "rightmost"], [], a), y = r === "root";
  return wc(s, (w, v) => {
    var F = v.classes[0], z = w.classes[0];
    F === "mbin" && me.contains(l_, z) ? v.classes[0] = "mord" : z === "mbin" && me.contains(c_, F) && (w.classes[0] = "mord");
  }, {
    node: m
  }, h, y), wc(s, (w, v) => {
    var F = si(v), z = si(w), C = F && z ? w.hasClass("mtight") ? o_[F][z] : i_[F][z] : null;
    if (C)
      return B.makeGlue(C, u);
  }, {
    node: m
  }, h, y), s;
}, wc = function e(t, a, r, n, s) {
  n && t.push(n);
  for (var i = 0; i < t.length; i++) {
    var o = t[i], c = Hu(o);
    if (c) {
      e(c.children, a, r, null, s);
      continue;
    }
    var u = !o.hasClass("mspace");
    if (u) {
      var d = a(o, r.node);
      d && (r.insertAfter ? r.insertAfter(d) : (t.unshift(d), i++));
    }
    u ? r.node = o : s && o.hasClass("newline") && (r.node = ga(["leftmost"])), r.insertAfter = /* @__PURE__ */ ((m) => (h) => {
      t.splice(m + 1, 0, h), i++;
    })(i);
  }
  n && t.pop();
}, Hu = function(t) {
  return t instanceof en || t instanceof Bi || t instanceof tn && t.hasClass("enclosing") ? t : null;
}, h_ = function e(t, a) {
  var r = Hu(t);
  if (r) {
    var n = r.children;
    if (n.length) {
      if (a === "right")
        return e(n[n.length - 1], "right");
      if (a === "left")
        return e(n[0], "left");
    }
  }
  return t;
}, si = function(t, a) {
  return t ? (a && (t = h_(t, a)), f_[t.classes[0]] || null) : null;
}, $r = function(t, a) {
  var r = ["nulldelimiter"].concat(t.baseSizingClasses());
  return ga(a.concat(r));
}, Ce = function(t, a, r) {
  if (!t)
    return ga();
  if (Fn[t.type]) {
    var n = Fn[t.type](t, a);
    if (r && a.size !== r.size) {
      n = ga(a.sizingClasses(r), [n], a);
      var s = a.sizeMultiplier / r.sizeMultiplier;
      n.height *= s, n.depth *= s;
    }
    return n;
  } else
    throw new Q("Got group of unknown type: '" + t.type + "'");
};
function pn(e, t) {
  var a = ga(["base"], e, t), r = ga(["strut"]);
  return r.style.height = ee(a.height + a.depth), a.depth && (r.style.verticalAlign = ee(-a.depth)), a.children.unshift(r), a;
}
function ii(e, t) {
  var a = null;
  e.length === 1 && e[0].type === "tag" && (a = e[0].tag, e = e[0].body);
  var r = nt(e, t, "root"), n;
  r.length === 2 && r[1].hasClass("tag") && (n = r.pop());
  for (var s = [], i = [], o = 0; o < r.length; o++)
    if (i.push(r[o]), r[o].hasClass("mbin") || r[o].hasClass("mrel") || r[o].hasClass("allowbreak")) {
      for (var c = !1; o < r.length - 1 && r[o + 1].hasClass("mspace") && !r[o + 1].hasClass("newline"); )
        o++, i.push(r[o]), r[o].hasClass("nobreak") && (c = !0);
      c || (s.push(pn(i, t)), i = []);
    } else r[o].hasClass("newline") && (i.pop(), i.length > 0 && (s.push(pn(i, t)), i = []), s.push(r[o]));
  i.length > 0 && s.push(pn(i, t));
  var u;
  a ? (u = pn(nt(a, t, !0)), u.classes = ["tag"], s.push(u)) : n && s.push(n);
  var d = ga(["katex-html"], s);
  if (d.setAttribute("aria-hidden", "true"), u) {
    var m = u.children[0];
    m.style.height = ee(d.height + d.depth), d.depth && (m.style.verticalAlign = ee(-d.depth));
  }
  return d;
}
function Uu(e) {
  return new en(e);
}
class Lt {
  constructor(t, a, r) {
    this.type = void 0, this.attributes = void 0, this.children = void 0, this.classes = void 0, this.type = t, this.attributes = {}, this.children = a || [], this.classes = r || [];
  }
  /**
   * Sets an attribute on a MathML node. MathML depends on attributes to convey a
   * semantic content, so this is used heavily.
   */
  setAttribute(t, a) {
    this.attributes[t] = a;
  }
  /**
   * Gets an attribute on a MathML node.
   */
  getAttribute(t) {
    return this.attributes[t];
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    var t = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
    for (var a in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, a) && t.setAttribute(a, this.attributes[a]);
    this.classes.length > 0 && (t.className = Ca(this.classes));
    for (var r = 0; r < this.children.length; r++)
      t.appendChild(this.children[r].toNode());
    return t;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    var t = "<" + this.type;
    for (var a in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, a) && (t += " " + a + '="', t += me.escape(this.attributes[a]), t += '"');
    this.classes.length > 0 && (t += ' class ="' + me.escape(Ca(this.classes)) + '"'), t += ">";
    for (var r = 0; r < this.children.length; r++)
      t += this.children[r].toMarkup();
    return t += "</" + this.type + ">", t;
  }
  /**
   * Converts the math node into a string, similar to innerText, but escaped.
   */
  toText() {
    return this.children.map((t) => t.toText()).join("");
  }
}
class Mr {
  constructor(t) {
    this.text = void 0, this.text = t;
  }
  /**
   * Converts the text node into a DOM text node.
   */
  toNode() {
    return document.createTextNode(this.text);
  }
  /**
   * Converts the text node into escaped HTML markup
   * (representing the text itself).
   */
  toMarkup() {
    return me.escape(this.toText());
  }
  /**
   * Converts the text node into a string
   * (representing the text itself).
   */
  toText() {
    return this.text;
  }
}
class d_ {
  /**
   * Create a Space node with width given in CSS ems.
   */
  constructor(t) {
    this.width = void 0, this.character = void 0, this.width = t, t >= 0.05555 && t <= 0.05556 ? this.character = "" : t >= 0.1666 && t <= 0.1667 ? this.character = "" : t >= 0.2222 && t <= 0.2223 ? this.character = "" : t >= 0.2777 && t <= 0.2778 ? this.character = "" : t >= -0.05556 && t <= -0.05555 ? this.character = "" : t >= -0.1667 && t <= -0.1666 ? this.character = "" : t >= -0.2223 && t <= -0.2222 ? this.character = "" : t >= -0.2778 && t <= -0.2777 ? this.character = "" : this.character = null;
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    if (this.character)
      return document.createTextNode(this.character);
    var t = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
    return t.setAttribute("width", ee(this.width)), t;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    return this.character ? "<mtext>" + this.character + "</mtext>" : '<mspace width="' + ee(this.width) + '"/>';
  }
  /**
   * Converts the math node into a string, similar to innerText.
   */
  toText() {
    return this.character ? this.character : " ";
  }
}
var W = {
  MathNode: Lt,
  TextNode: Mr,
  SpaceNode: d_,
  newDocumentFragment: Uu
}, Ut = function(t, a, r) {
  return Pe[a][t] && Pe[a][t].replace && t.charCodeAt(0) !== 55349 && !(Fu.hasOwnProperty(t) && r && (r.fontFamily && r.fontFamily.slice(4, 6) === "tt" || r.font && r.font.slice(4, 6) === "tt")) && (t = Pe[a][t].replace), new W.TextNode(t);
}, Hi = function(t) {
  return t.length === 1 ? t[0] : new W.MathNode("mrow", t);
}, Ui = function(t, a) {
  if (a.fontFamily === "texttt")
    return "monospace";
  if (a.fontFamily === "textsf")
    return a.fontShape === "textit" && a.fontWeight === "textbf" ? "sans-serif-bold-italic" : a.fontShape === "textit" ? "sans-serif-italic" : a.fontWeight === "textbf" ? "bold-sans-serif" : "sans-serif";
  if (a.fontShape === "textit" && a.fontWeight === "textbf")
    return "bold-italic";
  if (a.fontShape === "textit")
    return "italic";
  if (a.fontWeight === "textbf")
    return "bold";
  var r = a.font;
  if (!r || r === "mathnormal")
    return null;
  var n = t.mode;
  if (r === "mathit")
    return "italic";
  if (r === "boldsymbol")
    return t.type === "textord" ? "bold" : "bold-italic";
  if (r === "mathbf")
    return "bold";
  if (r === "mathbb")
    return "double-struck";
  if (r === "mathfrak")
    return "fraktur";
  if (r === "mathscr" || r === "mathcal")
    return "script";
  if (r === "mathsf")
    return "sans-serif";
  if (r === "mathtt")
    return "monospace";
  var s = t.text;
  if (me.contains(["\\imath", "\\jmath"], s))
    return null;
  Pe[n][s] && Pe[n][s].replace && (s = Pe[n][s].replace);
  var i = B.fontMap[r].fontName;
  return Mi(s, i, n) ? B.fontMap[r].variant : null;
}, Tt = function(t, a, r) {
  if (t.length === 1) {
    var n = Le(t[0], a);
    return r && n instanceof Lt && n.type === "mo" && (n.setAttribute("lspace", "0em"), n.setAttribute("rspace", "0em")), [n];
  }
  for (var s = [], i, o = 0; o < t.length; o++) {
    var c = Le(t[o], a);
    if (c instanceof Lt && i instanceof Lt) {
      if (c.type === "mtext" && i.type === "mtext" && c.getAttribute("mathvariant") === i.getAttribute("mathvariant")) {
        i.children.push(...c.children);
        continue;
      } else if (c.type === "mn" && i.type === "mn") {
        i.children.push(...c.children);
        continue;
      } else if (c.type === "mi" && c.children.length === 1 && i.type === "mn") {
        var u = c.children[0];
        if (u instanceof Mr && u.text === ".") {
          i.children.push(...c.children);
          continue;
        }
      } else if (i.type === "mi" && i.children.length === 1) {
        var d = i.children[0];
        if (d instanceof Mr && d.text === "" && (c.type === "mo" || c.type === "mi" || c.type === "mn")) {
          var m = c.children[0];
          m instanceof Mr && m.text.length > 0 && (m.text = m.text.slice(0, 1) + "" + m.text.slice(1), s.pop());
        }
      }
    }
    s.push(c), i = c;
  }
  return s;
}, za = function(t, a, r) {
  return Hi(Tt(t, a, r));
}, Le = function(t, a) {
  if (!t)
    return new W.MathNode("mrow");
  if (On[t.type]) {
    var r = On[t.type](t, a);
    return r;
  } else
    throw new Q("Got group of unknown type: '" + t.type + "'");
};
function Ec(e, t, a, r, n) {
  var s = Tt(e, a), i;
  s.length === 1 && s[0] instanceof Lt && me.contains(["mrow", "mtable"], s[0].type) ? i = s[0] : i = new W.MathNode("mrow", s);
  var o = new W.MathNode("annotation", [new W.TextNode(t)]);
  o.setAttribute("encoding", "application/x-tex");
  var c = new W.MathNode("semantics", [i, o]), u = new W.MathNode("math", [c]);
  u.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML"), r && u.setAttribute("display", "block");
  var d = n ? "katex" : "katex-mathml";
  return B.makeSpan([d], [u]);
}
var ju = function(t) {
  return new ha({
    style: t.displayMode ? ge.DISPLAY : ge.TEXT,
    maxSize: t.maxSize,
    minRuleThickness: t.minRuleThickness
  });
}, qu = function(t, a) {
  if (a.displayMode) {
    var r = ["katex-display"];
    a.leqno && r.push("leqno"), a.fleqn && r.push("fleqn"), t = B.makeSpan(r, [t]);
  }
  return t;
}, m_ = function(t, a, r) {
  var n = ju(r), s;
  if (r.output === "mathml")
    return Ec(t, a, n, r.displayMode, !0);
  if (r.output === "html") {
    var i = ii(t, n);
    s = B.makeSpan(["katex"], [i]);
  } else {
    var o = Ec(t, a, n, r.displayMode, !1), c = ii(t, n);
    s = B.makeSpan(["katex"], [o, c]);
  }
  return qu(s, r);
}, p_ = function(t, a, r) {
  var n = ju(r), s = ii(t, n), i = B.makeSpan(["katex"], [s]);
  return qu(i, r);
}, g_ = {
  widehat: "^",
  widecheck: "",
  widetilde: "~",
  utilde: "~",
  overleftarrow: "",
  underleftarrow: "",
  xleftarrow: "",
  overrightarrow: "",
  underrightarrow: "",
  xrightarrow: "",
  underbrace: "",
  overbrace: "",
  overgroup: "",
  undergroup: "",
  overleftrightarrow: "",
  underleftrightarrow: "",
  xleftrightarrow: "",
  Overrightarrow: "",
  xRightarrow: "",
  overleftharpoon: "",
  xleftharpoonup: "",
  overrightharpoon: "",
  xrightharpoonup: "",
  xLeftarrow: "",
  xLeftrightarrow: "",
  xhookleftarrow: "",
  xhookrightarrow: "",
  xmapsto: "",
  xrightharpoondown: "",
  xleftharpoondown: "",
  xrightleftharpoons: "",
  xleftrightharpoons: "",
  xtwoheadleftarrow: "",
  xtwoheadrightarrow: "",
  xlongequal: "=",
  xtofrom: "",
  xrightleftarrows: "",
  xrightequilibrium: "",
  // Not a perfect match.
  xleftequilibrium: "",
  // None better available.
  "\\cdrightarrow": "",
  "\\cdleftarrow": "",
  "\\cdlongequal": "="
}, y_ = function(t) {
  var a = new W.MathNode("mo", [new W.TextNode(g_[t.replace(/^\\/, "")])]);
  return a.setAttribute("stretchy", "true"), a;
}, __ = {
  //   path(s), minWidth, height, align
  overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
  "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
  // CD minwwidth2.5pc
  xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
  "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
  Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
  xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
  xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
  overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
  overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
  xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
  "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
  xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
  xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
  overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
  underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
  underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
  xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
  xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
  xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
  xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
  xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
  overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
  undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
  xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
  xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
  // The next three arrows are from the mhchem package.
  // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
  // document as \xrightarrow or \xrightleftharpoons. Those have
  // min-length = 1.75em, so we set min-length on these next three to match.
  xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
  xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
  xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
}, b_ = function(t) {
  return t.type === "ordgroup" ? t.body.length : 1;
}, k_ = function(t, a) {
  function r() {
    var o = 4e5, c = t.label.slice(1);
    if (me.contains(["widehat", "widecheck", "widetilde", "utilde"], c)) {
      var u = t, d = b_(u.base), m, h, y;
      if (d > 5)
        c === "widehat" || c === "widecheck" ? (m = 420, o = 2364, y = 0.42, h = c + "4") : (m = 312, o = 2340, y = 0.34, h = "tilde4");
      else {
        var w = [1, 1, 2, 2, 3, 3][d];
        c === "widehat" || c === "widecheck" ? (o = [0, 1062, 2364, 2364, 2364][w], m = [0, 239, 300, 360, 420][w], y = [0, 0.24, 0.3, 0.3, 0.36, 0.42][w], h = c + w) : (o = [0, 600, 1033, 2339, 2340][w], m = [0, 260, 286, 306, 312][w], y = [0, 0.26, 0.286, 0.3, 0.306, 0.34][w], h = "tilde" + w);
      }
      var v = new Sa(h), F = new pa([v], {
        width: "100%",
        height: ee(y),
        viewBox: "0 0 " + o + " " + m,
        preserveAspectRatio: "none"
      });
      return {
        span: B.makeSvgSpan([], [F], a),
        minWidth: 0,
        height: y
      };
    } else {
      var z = [], C = __[c], [U, $, O] = C, p = O / 1e3, M = U.length, te, Z;
      if (M === 1) {
        var P = C[3];
        te = ["hide-tail"], Z = [P];
      } else if (M === 2)
        te = ["halfarrow-left", "halfarrow-right"], Z = ["xMinYMin", "xMaxYMin"];
      else if (M === 3)
        te = ["brace-left", "brace-center", "brace-right"], Z = ["xMinYMin", "xMidYMin", "xMaxYMin"];
      else
        throw new Error(`Correct katexImagesData or update code here to support
                    ` + M + " children.");
      for (var re = 0; re < M; re++) {
        var ae = new Sa(U[re]), ue = new pa([ae], {
          width: "400em",
          height: ee(p),
          viewBox: "0 0 " + o + " " + O,
          preserveAspectRatio: Z[re] + " slice"
        }), de = B.makeSvgSpan([te[re]], [ue], a);
        if (M === 1)
          return {
            span: de,
            minWidth: $,
            height: p
          };
        de.style.height = ee(p), z.push(de);
      }
      return {
        span: B.makeSpan(["stretchy"], z, a),
        minWidth: $,
        height: p
      };
    }
  }
  var {
    span: n,
    minWidth: s,
    height: i
  } = r();
  return n.height = i, n.style.height = ee(i), s > 0 && (n.style.minWidth = ee(s)), n;
}, w_ = function(t, a, r, n, s) {
  var i, o = t.height + t.depth + r + n;
  if (/fbox|color|angl/.test(a)) {
    if (i = B.makeSpan(["stretchy", a], [], s), a === "fbox") {
      var c = s.color && s.getColor();
      c && (i.style.borderColor = c);
    }
  } else {
    var u = [];
    /^[bx]cancel$/.test(a) && u.push(new ri({
      x1: "0",
      y1: "0",
      x2: "100%",
      y2: "100%",
      "stroke-width": "0.046em"
    })), /^x?cancel$/.test(a) && u.push(new ri({
      x1: "0",
      y1: "100%",
      x2: "100%",
      y2: "0",
      "stroke-width": "0.046em"
    }));
    var d = new pa(u, {
      width: "100%",
      height: ee(o)
    });
    i = B.makeSvgSpan([], [d], s);
  }
  return i.height = o, i.style.height = ee(o), i;
}, ya = {
  encloseSpan: w_,
  mathMLnode: y_,
  svgSpan: k_
};
function Te(e, t) {
  if (!e || e.type !== t)
    throw new Error("Expected node of type " + t + ", but got " + (e ? "node of type " + e.type : String(e)));
  return e;
}
function ji(e) {
  var t = Xn(e);
  if (!t)
    throw new Error("Expected node of symbol group type, but got " + (e ? "node of type " + e.type : String(e)));
  return t;
}
function Xn(e) {
  return e && (e.type === "atom" || Gy.hasOwnProperty(e.type)) ? e : null;
}
var qi = (e, t) => {
  var a, r, n;
  e && e.type === "supsub" ? (r = Te(e.base, "accent"), a = r.base, e.base = a, n = Yy(Ce(e, t)), e.base = r) : (r = Te(e, "accent"), a = r.base);
  var s = Ce(a, t.havingCrampedStyle()), i = r.isShifty && me.isCharacterBox(a), o = 0;
  if (i) {
    var c = me.getBaseElem(a), u = Ce(c, t.havingCrampedStyle());
    o = pc(u).skew;
  }
  var d = r.label === "\\c", m = d ? s.height + s.depth : Math.min(s.height, t.fontMetrics().xHeight), h;
  if (r.isStretchy)
    h = ya.svgSpan(r, t), h = B.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: s
      }, {
        type: "elem",
        elem: h,
        wrapperClasses: ["svg-align"],
        wrapperStyle: o > 0 ? {
          width: "calc(100% - " + ee(2 * o) + ")",
          marginLeft: ee(2 * o)
        } : void 0
      }]
    }, t);
  else {
    var y, w;
    r.label === "\\vec" ? (y = B.staticSvg("vec", t), w = B.svgData.vec[1]) : (y = B.makeOrd({
      mode: r.mode,
      text: r.label
    }, t, "textord"), y = pc(y), y.italic = 0, w = y.width, d && (m += y.depth)), h = B.makeSpan(["accent-body"], [y]);
    var v = r.label === "\\textcircled";
    v && (h.classes.push("accent-full"), m = s.height);
    var F = o;
    v || (F -= w / 2), h.style.left = ee(F), r.label === "\\textcircled" && (h.style.top = ".2em"), h = B.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: s
      }, {
        type: "kern",
        size: -m
      }, {
        type: "elem",
        elem: h
      }]
    }, t);
  }
  var z = B.makeSpan(["mord", "accent"], [h], t);
  return n ? (n.children[0] = z, n.height = Math.max(z.height, n.height), n.classes[0] = "mord", n) : z;
}, Yu = (e, t) => {
  var a = e.isStretchy ? ya.mathMLnode(e.label) : new W.MathNode("mo", [Ut(e.label, e.mode)]), r = new W.MathNode("mover", [Le(e.base, t), a]);
  return r.setAttribute("accent", "true"), r;
}, E_ = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map((e) => "\\" + e).join("|"));
ne({
  type: "accent",
  names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
  props: {
    numArgs: 1
  },
  handler: (e, t) => {
    var a = Ln(t[0]), r = !E_.test(e.funcName), n = !r || e.funcName === "\\widehat" || e.funcName === "\\widetilde" || e.funcName === "\\widecheck";
    return {
      type: "accent",
      mode: e.parser.mode,
      label: e.funcName,
      isStretchy: r,
      isShifty: n,
      base: a
    };
  },
  htmlBuilder: qi,
  mathmlBuilder: Yu
});
ne({
  type: "accent",
  names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
  props: {
    numArgs: 1,
    allowedInText: !0,
    allowedInMath: !0,
    // unless in strict mode
    argTypes: ["primitive"]
  },
  handler: (e, t) => {
    var a = t[0], r = e.parser.mode;
    return r === "math" && (e.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + e.funcName + " works only in text mode"), r = "text"), {
      type: "accent",
      mode: r,
      label: e.funcName,
      isStretchy: !1,
      isShifty: !0,
      base: a
    };
  },
  htmlBuilder: qi,
  mathmlBuilder: Yu
});
ne({
  type: "accentUnder",
  names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
  props: {
    numArgs: 1
  },
  handler: (e, t) => {
    var {
      parser: a,
      funcName: r
    } = e, n = t[0];
    return {
      type: "accentUnder",
      mode: a.mode,
      label: r,
      base: n
    };
  },
  htmlBuilder: (e, t) => {
    var a = Ce(e.base, t), r = ya.svgSpan(e, t), n = e.label === "\\utilde" ? 0.12 : 0, s = B.makeVList({
      positionType: "top",
      positionData: a.height,
      children: [{
        type: "elem",
        elem: r,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: n
      }, {
        type: "elem",
        elem: a
      }]
    }, t);
    return B.makeSpan(["mord", "accentunder"], [s], t);
  },
  mathmlBuilder: (e, t) => {
    var a = ya.mathMLnode(e.label), r = new W.MathNode("munder", [Le(e.base, t), a]);
    return r.setAttribute("accentunder", "true"), r;
  }
});
var gn = (e) => {
  var t = new W.MathNode("mpadded", e ? [e] : []);
  return t.setAttribute("width", "+0.6em"), t.setAttribute("lspace", "0.3em"), t;
};
ne({
  type: "xArrow",
  names: [
    "\\xleftarrow",
    "\\xrightarrow",
    "\\xLeftarrow",
    "\\xRightarrow",
    "\\xleftrightarrow",
    "\\xLeftrightarrow",
    "\\xhookleftarrow",
    "\\xhookrightarrow",
    "\\xmapsto",
    "\\xrightharpoondown",
    "\\xrightharpoonup",
    "\\xleftharpoondown",
    "\\xleftharpoonup",
    "\\xrightleftharpoons",
    "\\xleftrightharpoons",
    "\\xlongequal",
    "\\xtwoheadrightarrow",
    "\\xtwoheadleftarrow",
    "\\xtofrom",
    // The next 3 functions are here to support the mhchem extension.
    // Direct use of these functions is discouraged and may break someday.
    "\\xrightleftarrows",
    "\\xrightequilibrium",
    "\\xleftequilibrium",
    // The next 3 functions are here only to support the {CD} environment.
    "\\\\cdrightarrow",
    "\\\\cdleftarrow",
    "\\\\cdlongequal"
  ],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(e, t, a) {
    var {
      parser: r,
      funcName: n
    } = e;
    return {
      type: "xArrow",
      mode: r.mode,
      label: n,
      body: t[0],
      below: a[0]
    };
  },
  // Flow is unable to correctly infer the type of `group`, even though it's
  // unambiguously determined from the passed-in `type` above.
  htmlBuilder(e, t) {
    var a = t.style, r = t.havingStyle(a.sup()), n = B.wrapFragment(Ce(e.body, r, t), t), s = e.label.slice(0, 2) === "\\x" ? "x" : "cd";
    n.classes.push(s + "-arrow-pad");
    var i;
    e.below && (r = t.havingStyle(a.sub()), i = B.wrapFragment(Ce(e.below, r, t), t), i.classes.push(s + "-arrow-pad"));
    var o = ya.svgSpan(e, t), c = -t.fontMetrics().axisHeight + 0.5 * o.height, u = -t.fontMetrics().axisHeight - 0.5 * o.height - 0.111;
    (n.depth > 0.25 || e.label === "\\xleftequilibrium") && (u -= n.depth);
    var d;
    if (i) {
      var m = -t.fontMetrics().axisHeight + i.height + 0.5 * o.height + 0.111;
      d = B.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: n,
          shift: u
        }, {
          type: "elem",
          elem: o,
          shift: c
        }, {
          type: "elem",
          elem: i,
          shift: m
        }]
      }, t);
    } else
      d = B.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: n,
          shift: u
        }, {
          type: "elem",
          elem: o,
          shift: c
        }]
      }, t);
    return d.children[0].children[0].children[1].classes.push("svg-align"), B.makeSpan(["mrel", "x-arrow"], [d], t);
  },
  mathmlBuilder(e, t) {
    var a = ya.mathMLnode(e.label);
    a.setAttribute("minsize", e.label.charAt(0) === "x" ? "1.75em" : "3.0em");
    var r;
    if (e.body) {
      var n = gn(Le(e.body, t));
      if (e.below) {
        var s = gn(Le(e.below, t));
        r = new W.MathNode("munderover", [a, s, n]);
      } else
        r = new W.MathNode("mover", [a, n]);
    } else if (e.below) {
      var i = gn(Le(e.below, t));
      r = new W.MathNode("munder", [a, i]);
    } else
      r = gn(), r = new W.MathNode("mover", [a, r]);
    return r;
  }
});
var T_ = B.makeSpan;
function Vu(e, t) {
  var a = nt(e.body, t, !0);
  return T_([e.mclass], a, t);
}
function Gu(e, t) {
  var a, r = Tt(e.body, t);
  return e.mclass === "minner" ? a = new W.MathNode("mpadded", r) : e.mclass === "mord" ? e.isCharacterBox ? (a = r[0], a.type = "mi") : a = new W.MathNode("mi", r) : (e.isCharacterBox ? (a = r[0], a.type = "mo") : a = new W.MathNode("mo", r), e.mclass === "mbin" ? (a.attributes.lspace = "0.22em", a.attributes.rspace = "0.22em") : e.mclass === "mpunct" ? (a.attributes.lspace = "0em", a.attributes.rspace = "0.17em") : e.mclass === "mopen" || e.mclass === "mclose" ? (a.attributes.lspace = "0em", a.attributes.rspace = "0em") : e.mclass === "minner" && (a.attributes.lspace = "0.0556em", a.attributes.width = "+0.1111em")), a;
}
ne({
  type: "mclass",
  names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler(e, t) {
    var {
      parser: a,
      funcName: r
    } = e, n = t[0];
    return {
      type: "mclass",
      mode: a.mode,
      mclass: "m" + r.slice(5),
      // TODO(kevinb): don't prefix with 'm'
      body: Qe(n),
      isCharacterBox: me.isCharacterBox(n)
    };
  },
  htmlBuilder: Vu,
  mathmlBuilder: Gu
});
var Qn = (e) => {
  var t = e.type === "ordgroup" && e.body.length ? e.body[0] : e;
  return t.type === "atom" && (t.family === "bin" || t.family === "rel") ? "m" + t.family : "mord";
};
ne({
  type: "mclass",
  names: ["\\@binrel"],
  props: {
    numArgs: 2
  },
  handler(e, t) {
    var {
      parser: a
    } = e;
    return {
      type: "mclass",
      mode: a.mode,
      mclass: Qn(t[0]),
      body: Qe(t[1]),
      isCharacterBox: me.isCharacterBox(t[1])
    };
  }
});
ne({
  type: "mclass",
  names: ["\\stackrel", "\\overset", "\\underset"],
  props: {
    numArgs: 2
  },
  handler(e, t) {
    var {
      parser: a,
      funcName: r
    } = e, n = t[1], s = t[0], i;
    r !== "\\stackrel" ? i = Qn(n) : i = "mrel";
    var o = {
      type: "op",
      mode: n.mode,
      limits: !0,
      alwaysHandleSupSub: !0,
      parentIsSupSub: !1,
      symbol: !1,
      suppressBaseShift: r !== "\\stackrel",
      body: Qe(n)
    }, c = {
      type: "supsub",
      mode: s.mode,
      base: o,
      sup: r === "\\underset" ? null : s,
      sub: r === "\\underset" ? s : null
    };
    return {
      type: "mclass",
      mode: a.mode,
      mclass: i,
      body: [c],
      isCharacterBox: me.isCharacterBox(c)
    };
  },
  htmlBuilder: Vu,
  mathmlBuilder: Gu
});
ne({
  type: "pmb",
  names: ["\\pmb"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(e, t) {
    var {
      parser: a
    } = e;
    return {
      type: "pmb",
      mode: a.mode,
      mclass: Qn(t[0]),
      body: Qe(t[0])
    };
  },
  htmlBuilder(e, t) {
    var a = nt(e.body, t, !0), r = B.makeSpan([e.mclass], a, t);
    return r.style.textShadow = "0.02em 0.01em 0.04px", r;
  },
  mathmlBuilder(e, t) {
    var a = Tt(e.body, t), r = new W.MathNode("mstyle", a);
    return r.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px"), r;
  }
});
var v_ = {
  ">": "\\\\cdrightarrow",
  "<": "\\\\cdleftarrow",
  "=": "\\\\cdlongequal",
  A: "\\uparrow",
  V: "\\downarrow",
  "|": "\\Vert",
  ".": "no arrow"
}, Tc = () => ({
  type: "styling",
  body: [],
  mode: "math",
  style: "display"
}), vc = (e) => e.type === "textord" && e.text === "@", x_ = (e, t) => (e.type === "mathord" || e.type === "atom") && e.text === t;
function A_(e, t, a) {
  var r = v_[e];
  switch (r) {
    case "\\\\cdrightarrow":
    case "\\\\cdleftarrow":
      return a.callFunction(r, [t[0]], [t[1]]);
    case "\\uparrow":
    case "\\downarrow": {
      var n = a.callFunction("\\\\cdleft", [t[0]], []), s = {
        type: "atom",
        text: r,
        mode: "math",
        family: "rel"
      }, i = a.callFunction("\\Big", [s], []), o = a.callFunction("\\\\cdright", [t[1]], []), c = {
        type: "ordgroup",
        mode: "math",
        body: [n, i, o]
      };
      return a.callFunction("\\\\cdparent", [c], []);
    }
    case "\\\\cdlongequal":
      return a.callFunction("\\\\cdlongequal", [], []);
    case "\\Vert": {
      var u = {
        type: "textord",
        text: "\\Vert",
        mode: "math"
      };
      return a.callFunction("\\Big", [u], []);
    }
    default:
      return {
        type: "textord",
        text: " ",
        mode: "math"
      };
  }
}
function D_(e) {
  var t = [];
  for (e.gullet.beginGroup(), e.gullet.macros.set("\\cr", "\\\\\\relax"), e.gullet.beginGroup(); ; ) {
    t.push(e.parseExpression(!1, "\\\\")), e.gullet.endGroup(), e.gullet.beginGroup();
    var a = e.fetch().text;
    if (a === "&" || a === "\\\\")
      e.consume();
    else if (a === "\\end") {
      t[t.length - 1].length === 0 && t.pop();
      break;
    } else
      throw new Q("Expected \\\\ or \\cr or \\end", e.nextToken);
  }
  for (var r = [], n = [r], s = 0; s < t.length; s++) {
    for (var i = t[s], o = Tc(), c = 0; c < i.length; c++)
      if (!vc(i[c]))
        o.body.push(i[c]);
      else {
        r.push(o), c += 1;
        var u = ji(i[c]).text, d = new Array(2);
        if (d[0] = {
          type: "ordgroup",
          mode: "math",
          body: []
        }, d[1] = {
          type: "ordgroup",
          mode: "math",
          body: []
        }, !("=|.".indexOf(u) > -1)) if ("<>AV".indexOf(u) > -1)
          for (var m = 0; m < 2; m++) {
            for (var h = !0, y = c + 1; y < i.length; y++) {
              if (x_(i[y], u)) {
                h = !1, c = y;
                break;
              }
              if (vc(i[y]))
                throw new Q("Missing a " + u + " character to complete a CD arrow.", i[y]);
              d[m].body.push(i[y]);
            }
            if (h)
              throw new Q("Missing a " + u + " character to complete a CD arrow.", i[c]);
          }
        else
          throw new Q('Expected one of "<>AV=|." after @', i[c]);
        var w = A_(u, d, e), v = {
          type: "styling",
          body: [w],
          mode: "math",
          style: "display"
          // CD is always displaystyle.
        };
        r.push(v), o = Tc();
      }
    s % 2 === 0 ? r.push(o) : r.shift(), r = [], n.push(r);
  }
  e.gullet.endGroup(), e.gullet.endGroup();
  var F = new Array(n[0].length).fill({
    type: "align",
    align: "c",
    pregap: 0.25,
    // CD package sets \enskip between columns.
    postgap: 0.25
    // So pre and post each get half an \enskip, i.e. 0.25em.
  });
  return {
    type: "array",
    mode: "math",
    body: n,
    arraystretch: 1,
    addJot: !0,
    rowGaps: [null],
    cols: F,
    colSeparationType: "CD",
    hLinesBeforeRow: new Array(n.length + 1).fill([])
  };
}
ne({
  type: "cdlabel",
  names: ["\\\\cdleft", "\\\\cdright"],
  props: {
    numArgs: 1
  },
  handler(e, t) {
    var {
      parser: a,
      funcName: r
    } = e;
    return {
      type: "cdlabel",
      mode: a.mode,
      side: r.slice(4),
      label: t[0]
    };
  },
  htmlBuilder(e, t) {
    var a = t.havingStyle(t.style.sup()), r = B.wrapFragment(Ce(e.label, a, t), t);
    return r.classes.push("cd-label-" + e.side), r.style.bottom = ee(0.8 - r.depth), r.height = 0, r.depth = 0, r;
  },
  mathmlBuilder(e, t) {
    var a = new W.MathNode("mrow", [Le(e.label, t)]);
    return a = new W.MathNode("mpadded", [a]), a.setAttribute("width", "0"), e.side === "left" && a.setAttribute("lspace", "-1width"), a.setAttribute("voffset", "0.7em"), a = new W.MathNode("mstyle", [a]), a.setAttribute("displaystyle", "false"), a.setAttribute("scriptlevel", "1"), a;
  }
});
ne({
  type: "cdlabelparent",
  names: ["\\\\cdparent"],
  props: {
    numArgs: 1
  },
  handler(e, t) {
    var {
      parser: a
    } = e;
    return {
      type: "cdlabelparent",
      mode: a.mode,
      fragment: t[0]
    };
  },
  htmlBuilder(e, t) {
    var a = B.wrapFragment(Ce(e.fragment, t), t);
    return a.classes.push("cd-vert-arrow"), a;
  },
  mathmlBuilder(e, t) {
    return new W.MathNode("mrow", [Le(e.fragment, t)]);
  }
});
ne({
  type: "textord",
  names: ["\\@char"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(e, t) {
    for (var {
      parser: a
    } = e, r = Te(t[0], "ordgroup"), n = r.body, s = "", i = 0; i < n.length; i++) {
      var o = Te(n[i], "textord");
      s += o.text;
    }
    var c = parseInt(s), u;
    if (isNaN(c))
      throw new Q("\\@char has non-numeric argument " + s);
    if (c < 0 || c >= 1114111)
      throw new Q("\\@char with invalid code point " + s);
    return c <= 65535 ? u = String.fromCharCode(c) : (c -= 65536, u = String.fromCharCode((c >> 10) + 55296, (c & 1023) + 56320)), {
      type: "textord",
      mode: a.mode,
      text: u
    };
  }
});
var Wu = (e, t) => {
  var a = nt(e.body, t.withColor(e.color), !1);
  return B.makeFragment(a);
}, $u = (e, t) => {
  var a = Tt(e.body, t.withColor(e.color)), r = new W.MathNode("mstyle", a);
  return r.setAttribute("mathcolor", e.color), r;
};
ne({
  type: "color",
  names: ["\\textcolor"],
  props: {
    numArgs: 2,
    allowedInText: !0,
    argTypes: ["color", "original"]
  },
  handler(e, t) {
    var {
      parser: a
    } = e, r = Te(t[0], "color-token").color, n = t[1];
    return {
      type: "color",
      mode: a.mode,
      color: r,
      body: Qe(n)
    };
  },
  htmlBuilder: Wu,
  mathmlBuilder: $u
});
ne({
  type: "color",
  names: ["\\color"],
  props: {
    numArgs: 1,
    allowedInText: !0,
    argTypes: ["color"]
  },
  handler(e, t) {
    var {
      parser: a,
      breakOnTokenText: r
    } = e, n = Te(t[0], "color-token").color;
    a.gullet.macros.set("\\current@color", n);
    var s = a.parseExpression(!0, r);
    return {
      type: "color",
      mode: a.mode,
      color: n,
      body: s
    };
  },
  htmlBuilder: Wu,
  mathmlBuilder: $u
});
ne({
  type: "cr",
  names: ["\\\\"],
  props: {
    numArgs: 0,
    numOptionalArgs: 0,
    allowedInText: !0
  },
  handler(e, t, a) {
    var {
      parser: r
    } = e, n = r.gullet.future().text === "[" ? r.parseSizeGroup(!0) : null, s = !r.settings.displayMode || !r.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
    return {
      type: "cr",
      mode: r.mode,
      newLine: s,
      size: n && Te(n, "size").value
    };
  },
  // The following builders are called only at the top level,
  // not within tabular/array environments.
  htmlBuilder(e, t) {
    var a = B.makeSpan(["mspace"], [], t);
    return e.newLine && (a.classes.push("newline"), e.size && (a.style.marginTop = ee(Ge(e.size, t)))), a;
  },
  mathmlBuilder(e, t) {
    var a = new W.MathNode("mspace");
    return e.newLine && (a.setAttribute("linebreak", "newline"), e.size && a.setAttribute("height", ee(Ge(e.size, t)))), a;
  }
});
var oi = {
  "\\global": "\\global",
  "\\long": "\\\\globallong",
  "\\\\globallong": "\\\\globallong",
  "\\def": "\\gdef",
  "\\gdef": "\\gdef",
  "\\edef": "\\xdef",
  "\\xdef": "\\xdef",
  "\\let": "\\\\globallet",
  "\\futurelet": "\\\\globalfuture"
}, Xu = (e) => {
  var t = e.text;
  if (/^(?:[\\{}$&#^_]|EOF)$/.test(t))
    throw new Q("Expected a control sequence", e);
  return t;
}, C_ = (e) => {
  var t = e.gullet.popToken();
  return t.text === "=" && (t = e.gullet.popToken(), t.text === " " && (t = e.gullet.popToken())), t;
}, Qu = (e, t, a, r) => {
  var n = e.gullet.macros.get(a.text);
  n == null && (a.noexpand = !0, n = {
    tokens: [a],
    numArgs: 0,
    // reproduce the same behavior in expansion
    unexpandable: !e.gullet.isExpandable(a.text)
  }), e.gullet.macros.set(t, n, r);
};
ne({
  type: "internal",
  names: [
    "\\global",
    "\\long",
    "\\\\globallong"
    // cant be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler(e) {
    var {
      parser: t,
      funcName: a
    } = e;
    t.consumeSpaces();
    var r = t.fetch();
    if (oi[r.text])
      return (a === "\\global" || a === "\\\\globallong") && (r.text = oi[r.text]), Te(t.parseFunction(), "internal");
    throw new Q("Invalid token after macro prefix", r);
  }
});
ne({
  type: "internal",
  names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(e) {
    var {
      parser: t,
      funcName: a
    } = e, r = t.gullet.popToken(), n = r.text;
    if (/^(?:[\\{}$&#^_]|EOF)$/.test(n))
      throw new Q("Expected a control sequence", r);
    for (var s = 0, i, o = [[]]; t.gullet.future().text !== "{"; )
      if (r = t.gullet.popToken(), r.text === "#") {
        if (t.gullet.future().text === "{") {
          i = t.gullet.future(), o[s].push("{");
          break;
        }
        if (r = t.gullet.popToken(), !/^[1-9]$/.test(r.text))
          throw new Q('Invalid argument number "' + r.text + '"');
        if (parseInt(r.text) !== s + 1)
          throw new Q('Argument number "' + r.text + '" out of order');
        s++, o.push([]);
      } else {
        if (r.text === "EOF")
          throw new Q("Expected a macro definition");
        o[s].push(r.text);
      }
    var {
      tokens: c
    } = t.gullet.consumeArg();
    return i && c.unshift(i), (a === "\\edef" || a === "\\xdef") && (c = t.gullet.expandTokens(c), c.reverse()), t.gullet.macros.set(n, {
      tokens: c,
      numArgs: s,
      delimiters: o
    }, a === oi[a]), {
      type: "internal",
      mode: t.mode
    };
  }
});
ne({
  type: "internal",
  names: [
    "\\let",
    "\\\\globallet"
    // cant be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(e) {
    var {
      parser: t,
      funcName: a
    } = e, r = Xu(t.gullet.popToken());
    t.gullet.consumeSpaces();
    var n = C_(t);
    return Qu(t, r, n, a === "\\\\globallet"), {
      type: "internal",
      mode: t.mode
    };
  }
});
ne({
  type: "internal",
  names: [
    "\\futurelet",
    "\\\\globalfuture"
    // cant be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(e) {
    var {
      parser: t,
      funcName: a
    } = e, r = Xu(t.gullet.popToken()), n = t.gullet.popToken(), s = t.gullet.popToken();
    return Qu(t, r, s, a === "\\\\globalfuture"), t.gullet.pushToken(s), t.gullet.pushToken(n), {
      type: "internal",
      mode: t.mode
    };
  }
});
var Ir = function(t, a, r) {
  var n = Pe.math[t] && Pe.math[t].replace, s = Mi(n || t, a, r);
  if (!s)
    throw new Error("Unsupported symbol " + t + " and font size " + a + ".");
  return s;
}, Yi = function(t, a, r, n) {
  var s = r.havingBaseStyle(a), i = B.makeSpan(n.concat(s.sizingClasses(r)), [t], r), o = s.sizeMultiplier / r.sizeMultiplier;
  return i.height *= o, i.depth *= o, i.maxFontSize = s.sizeMultiplier, i;
}, Ku = function(t, a, r) {
  var n = a.havingBaseStyle(r), s = (1 - a.sizeMultiplier / n.sizeMultiplier) * a.fontMetrics().axisHeight;
  t.classes.push("delimcenter"), t.style.top = ee(s), t.height -= s, t.depth += s;
}, S_ = function(t, a, r, n, s, i) {
  var o = B.makeSymbol(t, "Main-Regular", s, n), c = Yi(o, a, n, i);
  return r && Ku(c, n, a), c;
}, z_ = function(t, a, r, n) {
  return B.makeSymbol(t, "Size" + a + "-Regular", r, n);
}, Ju = function(t, a, r, n, s, i) {
  var o = z_(t, a, s, n), c = Yi(B.makeSpan(["delimsizing", "size" + a], [o], n), ge.TEXT, n, i);
  return r && Ku(c, n, ge.TEXT), c;
}, Rs = function(t, a, r) {
  var n;
  a === "Size1-Regular" ? n = "delim-size1" : n = "delim-size4";
  var s = B.makeSpan(["delimsizinginner", n], [B.makeSpan([], [B.makeSymbol(t, a, r)])]);
  return {
    type: "elem",
    elem: s
  };
}, Fs = function(t, a, r) {
  var n = Jt["Size4-Regular"][t.charCodeAt(0)] ? Jt["Size4-Regular"][t.charCodeAt(0)][4] : Jt["Size1-Regular"][t.charCodeAt(0)][4], s = new Sa("inner", Ly(t, Math.round(1e3 * a))), i = new pa([s], {
    width: ee(n),
    height: ee(a),
    // Override CSS rule `.katex svg { width: 100% }`
    style: "width:" + ee(n),
    viewBox: "0 0 " + 1e3 * n + " " + Math.round(1e3 * a),
    preserveAspectRatio: "xMinYMin"
  }), o = B.makeSvgSpan([], [i], r);
  return o.height = a, o.style.height = ee(a), o.style.width = ee(n), {
    type: "elem",
    elem: o
  };
}, ci = 8e-3, yn = {
  type: "kern",
  size: -1 * ci
}, N_ = ["|", "\\lvert", "\\rvert", "\\vert"], I_ = ["\\|", "\\lVert", "\\rVert", "\\Vert"], Zu = function(t, a, r, n, s, i) {
  var o, c, u, d, m = "", h = 0;
  o = u = d = t, c = null;
  var y = "Size1-Regular";
  t === "\\uparrow" ? u = d = "" : t === "\\Uparrow" ? u = d = "" : t === "\\downarrow" ? o = u = "" : t === "\\Downarrow" ? o = u = "" : t === "\\updownarrow" ? (o = "\\uparrow", u = "", d = "\\downarrow") : t === "\\Updownarrow" ? (o = "\\Uparrow", u = "", d = "\\Downarrow") : me.contains(N_, t) ? (u = "", m = "vert", h = 333) : me.contains(I_, t) ? (u = "", m = "doublevert", h = 556) : t === "[" || t === "\\lbrack" ? (o = "", u = "", d = "", y = "Size4-Regular", m = "lbrack", h = 667) : t === "]" || t === "\\rbrack" ? (o = "", u = "", d = "", y = "Size4-Regular", m = "rbrack", h = 667) : t === "\\lfloor" || t === "" ? (u = o = "", d = "", y = "Size4-Regular", m = "lfloor", h = 667) : t === "\\lceil" || t === "" ? (o = "", u = d = "", y = "Size4-Regular", m = "lceil", h = 667) : t === "\\rfloor" || t === "" ? (u = o = "", d = "", y = "Size4-Regular", m = "rfloor", h = 667) : t === "\\rceil" || t === "" ? (o = "", u = d = "", y = "Size4-Regular", m = "rceil", h = 667) : t === "(" || t === "\\lparen" ? (o = "", u = "", d = "", y = "Size4-Regular", m = "lparen", h = 875) : t === ")" || t === "\\rparen" ? (o = "", u = "", d = "", y = "Size4-Regular", m = "rparen", h = 875) : t === "\\{" || t === "\\lbrace" ? (o = "", c = "", d = "", u = "", y = "Size4-Regular") : t === "\\}" || t === "\\rbrace" ? (o = "", c = "", d = "", u = "", y = "Size4-Regular") : t === "\\lgroup" || t === "" ? (o = "", d = "", u = "", y = "Size4-Regular") : t === "\\rgroup" || t === "" ? (o = "", d = "", u = "", y = "Size4-Regular") : t === "\\lmoustache" || t === "" ? (o = "", d = "", u = "", y = "Size4-Regular") : (t === "\\rmoustache" || t === "") && (o = "", d = "", u = "", y = "Size4-Regular");
  var w = Ir(o, y, s), v = w.height + w.depth, F = Ir(u, y, s), z = F.height + F.depth, C = Ir(d, y, s), U = C.height + C.depth, $ = 0, O = 1;
  if (c !== null) {
    var p = Ir(c, y, s);
    $ = p.height + p.depth, O = 2;
  }
  var M = v + U + $, te = Math.max(0, Math.ceil((a - M) / (O * z))), Z = M + te * O * z, P = n.fontMetrics().axisHeight;
  r && (P *= n.sizeMultiplier);
  var re = Z / 2 - P, ae = [];
  if (m.length > 0) {
    var ue = Z - v - U, de = Math.round(Z * 1e3), fe = My(m, Math.round(ue * 1e3)), Se = new Sa(m, fe), Ne = (h / 1e3).toFixed(3) + "em", je = (de / 1e3).toFixed(3) + "em", et = new pa([Se], {
      width: Ne,
      height: je,
      viewBox: "0 0 " + h + " " + de
    }), S = B.makeSvgSpan([], [et], n);
    S.height = de / 1e3, S.style.width = Ne, S.style.height = je, ae.push({
      type: "elem",
      elem: S
    });
  } else {
    if (ae.push(Rs(d, y, s)), ae.push(yn), c === null) {
      var Me = Z - v - U + 2 * ci;
      ae.push(Fs(u, Me, n));
    } else {
      var Re = (Z - v - U - $) / 2 + 2 * ci;
      ae.push(Fs(u, Re, n)), ae.push(yn), ae.push(Rs(c, y, s)), ae.push(yn), ae.push(Fs(u, Re, n));
    }
    ae.push(yn), ae.push(Rs(o, y, s));
  }
  var N = n.havingBaseStyle(ge.TEXT), tt = B.makeVList({
    positionType: "bottom",
    positionData: re,
    children: ae
  }, N);
  return Yi(B.makeSpan(["delimsizing", "mult"], [tt], N), ge.TEXT, n, i);
}, Os = 80, Ls = 0.08, Ms = function(t, a, r, n, s) {
  var i = Oy(t, n, r), o = new Sa(t, i), c = new pa([o], {
    // Note: 1000:1 ratio of viewBox to document em width.
    width: "400em",
    height: ee(a),
    viewBox: "0 0 400000 " + r,
    preserveAspectRatio: "xMinYMin slice"
  });
  return B.makeSvgSpan(["hide-tail"], [c], s);
}, R_ = function(t, a) {
  var r = a.havingBaseSizing(), n = r0("\\surd", t * r.sizeMultiplier, a0, r), s = r.sizeMultiplier, i = Math.max(0, a.minRuleThickness - a.fontMetrics().sqrtRuleThickness), o, c = 0, u = 0, d = 0, m;
  return n.type === "small" ? (d = 1e3 + 1e3 * i + Os, t < 1 ? s = 1 : t < 1.4 && (s = 0.7), c = (1 + i + Ls) / s, u = (1 + i) / s, o = Ms("sqrtMain", c, d, i, a), o.style.minWidth = "0.853em", m = 0.833 / s) : n.type === "large" ? (d = (1e3 + Os) * Br[n.size], u = (Br[n.size] + i) / s, c = (Br[n.size] + i + Ls) / s, o = Ms("sqrtSize" + n.size, c, d, i, a), o.style.minWidth = "1.02em", m = 1 / s) : (c = t + i + Ls, u = t + i, d = Math.floor(1e3 * t + i) + Os, o = Ms("sqrtTall", c, d, i, a), o.style.minWidth = "0.742em", m = 1.056), o.height = u, o.style.height = ee(c), {
    span: o,
    advanceWidth: m,
    // Calculate the actual line width.
    // This actually should depend on the chosen font -- e.g. \boldmath
    // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
    // have thicker rules.
    ruleWidth: (a.fontMetrics().sqrtRuleThickness + i) * s
  };
}, e0 = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "", "", "\\lceil", "\\rceil", "", "", "\\surd"], F_ = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "", "", "\\lmoustache", "\\rmoustache", "", ""], t0 = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"], Br = [0, 1.2, 1.8, 2.4, 3], O_ = function(t, a, r, n, s) {
  if (t === "<" || t === "\\lt" || t === "" ? t = "\\langle" : (t === ">" || t === "\\gt" || t === "") && (t = "\\rangle"), me.contains(e0, t) || me.contains(t0, t))
    return Ju(t, a, !1, r, n, s);
  if (me.contains(F_, t))
    return Zu(t, Br[a], !1, r, n, s);
  throw new Q("Illegal delimiter: '" + t + "'");
}, L_ = [{
  type: "small",
  style: ge.SCRIPTSCRIPT
}, {
  type: "small",
  style: ge.SCRIPT
}, {
  type: "small",
  style: ge.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}], M_ = [{
  type: "small",
  style: ge.SCRIPTSCRIPT
}, {
  type: "small",
  style: ge.SCRIPT
}, {
  type: "small",
  style: ge.TEXT
}, {
  type: "stack"
}], a0 = [{
  type: "small",
  style: ge.SCRIPTSCRIPT
}, {
  type: "small",
  style: ge.SCRIPT
}, {
  type: "small",
  style: ge.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}, {
  type: "stack"
}], B_ = function(t) {
  if (t.type === "small")
    return "Main-Regular";
  if (t.type === "large")
    return "Size" + t.size + "-Regular";
  if (t.type === "stack")
    return "Size4-Regular";
  throw new Error("Add support for delim type '" + t.type + "' here.");
}, r0 = function(t, a, r, n) {
  for (var s = Math.min(2, 3 - n.style.size), i = s; i < r.length && r[i].type !== "stack"; i++) {
    var o = Ir(t, B_(r[i]), "math"), c = o.height + o.depth;
    if (r[i].type === "small") {
      var u = n.havingBaseStyle(r[i].style);
      c *= u.sizeMultiplier;
    }
    if (c > a)
      return r[i];
  }
  return r[r.length - 1];
}, n0 = function(t, a, r, n, s, i) {
  t === "<" || t === "\\lt" || t === "" ? t = "\\langle" : (t === ">" || t === "\\gt" || t === "") && (t = "\\rangle");
  var o;
  me.contains(t0, t) ? o = L_ : me.contains(e0, t) ? o = a0 : o = M_;
  var c = r0(t, a, o, n);
  return c.type === "small" ? S_(t, c.style, r, n, s, i) : c.type === "large" ? Ju(t, c.size, r, n, s, i) : Zu(t, a, r, n, s, i);
}, P_ = function(t, a, r, n, s, i) {
  var o = n.fontMetrics().axisHeight * n.sizeMultiplier, c = 901, u = 5 / n.fontMetrics().ptPerEm, d = Math.max(a - o, r + o), m = Math.max(
    // In real TeX, calculations are done using integral values which are
    // 65536 per pt, or 655360 per em. So, the division here truncates in
    // TeX but doesn't here, producing different results. If we wanted to
    // exactly match TeX's calculation, we could do
    //   Math.floor(655360 * maxDistFromAxis / 500) *
    //    delimiterFactor / 655360
    // (To see the difference, compare
    //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
    // in TeX and KaTeX)
    d / 500 * c,
    2 * d - u
  );
  return n0(t, m, !0, n, s, i);
}, ma = {
  sqrtImage: R_,
  sizedDelim: O_,
  sizeToMaxHeight: Br,
  customSizedDelim: n0,
  leftRightDelim: P_
}, xc = {
  "\\bigl": {
    mclass: "mopen",
    size: 1
  },
  "\\Bigl": {
    mclass: "mopen",
    size: 2
  },
  "\\biggl": {
    mclass: "mopen",
    size: 3
  },
  "\\Biggl": {
    mclass: "mopen",
    size: 4
  },
  "\\bigr": {
    mclass: "mclose",
    size: 1
  },
  "\\Bigr": {
    mclass: "mclose",
    size: 2
  },
  "\\biggr": {
    mclass: "mclose",
    size: 3
  },
  "\\Biggr": {
    mclass: "mclose",
    size: 4
  },
  "\\bigm": {
    mclass: "mrel",
    size: 1
  },
  "\\Bigm": {
    mclass: "mrel",
    size: 2
  },
  "\\biggm": {
    mclass: "mrel",
    size: 3
  },
  "\\Biggm": {
    mclass: "mrel",
    size: 4
  },
  "\\big": {
    mclass: "mord",
    size: 1
  },
  "\\Big": {
    mclass: "mord",
    size: 2
  },
  "\\bigg": {
    mclass: "mord",
    size: 3
  },
  "\\Bigg": {
    mclass: "mord",
    size: 4
  }
}, H_ = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "", "", "\\lceil", "\\rceil", "", "", "<", ">", "\\langle", "", "\\rangle", "", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "", "", "\\lmoustache", "\\rmoustache", "", "", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
function Kn(e, t) {
  var a = Xn(e);
  if (a && me.contains(H_, a.text))
    return a;
  throw a ? new Q("Invalid delimiter '" + a.text + "' after '" + t.funcName + "'", e) : new Q("Invalid delimiter type '" + e.type + "'", e);
}
ne({
  type: "delimsizing",
  names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (e, t) => {
    var a = Kn(t[0], e);
    return {
      type: "delimsizing",
      mode: e.parser.mode,
      size: xc[e.funcName].size,
      mclass: xc[e.funcName].mclass,
      delim: a.text
    };
  },
  htmlBuilder: (e, t) => e.delim === "." ? B.makeSpan([e.mclass]) : ma.sizedDelim(e.delim, e.size, t, e.mode, [e.mclass]),
  mathmlBuilder: (e) => {
    var t = [];
    e.delim !== "." && t.push(Ut(e.delim, e.mode));
    var a = new W.MathNode("mo", t);
    e.mclass === "mopen" || e.mclass === "mclose" ? a.setAttribute("fence", "true") : a.setAttribute("fence", "false"), a.setAttribute("stretchy", "true");
    var r = ee(ma.sizeToMaxHeight[e.size]);
    return a.setAttribute("minsize", r), a.setAttribute("maxsize", r), a;
  }
});
function Ac(e) {
  if (!e.body)
    throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
}
ne({
  type: "leftright-right",
  names: ["\\right"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (e, t) => {
    var a = e.parser.gullet.macros.get("\\current@color");
    if (a && typeof a != "string")
      throw new Q("\\current@color set to non-string in \\right");
    return {
      type: "leftright-right",
      mode: e.parser.mode,
      delim: Kn(t[0], e).text,
      color: a
      // undefined if not set via \color
    };
  }
});
ne({
  type: "leftright",
  names: ["\\left"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (e, t) => {
    var a = Kn(t[0], e), r = e.parser;
    ++r.leftrightDepth;
    var n = r.parseExpression(!1);
    --r.leftrightDepth, r.expect("\\right", !1);
    var s = Te(r.parseFunction(), "leftright-right");
    return {
      type: "leftright",
      mode: r.mode,
      body: n,
      left: a.text,
      right: s.delim,
      rightColor: s.color
    };
  },
  htmlBuilder: (e, t) => {
    Ac(e);
    for (var a = nt(e.body, t, !0, ["mopen", "mclose"]), r = 0, n = 0, s = !1, i = 0; i < a.length; i++)
      a[i].isMiddle ? s = !0 : (r = Math.max(a[i].height, r), n = Math.max(a[i].depth, n));
    r *= t.sizeMultiplier, n *= t.sizeMultiplier;
    var o;
    if (e.left === "." ? o = $r(t, ["mopen"]) : o = ma.leftRightDelim(e.left, r, n, t, e.mode, ["mopen"]), a.unshift(o), s)
      for (var c = 1; c < a.length; c++) {
        var u = a[c], d = u.isMiddle;
        d && (a[c] = ma.leftRightDelim(d.delim, r, n, d.options, e.mode, []));
      }
    var m;
    if (e.right === ".")
      m = $r(t, ["mclose"]);
    else {
      var h = e.rightColor ? t.withColor(e.rightColor) : t;
      m = ma.leftRightDelim(e.right, r, n, h, e.mode, ["mclose"]);
    }
    return a.push(m), B.makeSpan(["minner"], a, t);
  },
  mathmlBuilder: (e, t) => {
    Ac(e);
    var a = Tt(e.body, t);
    if (e.left !== ".") {
      var r = new W.MathNode("mo", [Ut(e.left, e.mode)]);
      r.setAttribute("fence", "true"), a.unshift(r);
    }
    if (e.right !== ".") {
      var n = new W.MathNode("mo", [Ut(e.right, e.mode)]);
      n.setAttribute("fence", "true"), e.rightColor && n.setAttribute("mathcolor", e.rightColor), a.push(n);
    }
    return Hi(a);
  }
});
ne({
  type: "middle",
  names: ["\\middle"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (e, t) => {
    var a = Kn(t[0], e);
    if (!e.parser.leftrightDepth)
      throw new Q("\\middle without preceding \\left", a);
    return {
      type: "middle",
      mode: e.parser.mode,
      delim: a.text
    };
  },
  htmlBuilder: (e, t) => {
    var a;
    if (e.delim === ".")
      a = $r(t, []);
    else {
      a = ma.sizedDelim(e.delim, 1, t, e.mode, []);
      var r = {
        delim: e.delim,
        options: t
      };
      a.isMiddle = r;
    }
    return a;
  },
  mathmlBuilder: (e, t) => {
    var a = e.delim === "\\vert" || e.delim === "|" ? Ut("|", "text") : Ut(e.delim, e.mode), r = new W.MathNode("mo", [a]);
    return r.setAttribute("fence", "true"), r.setAttribute("lspace", "0.05em"), r.setAttribute("rspace", "0.05em"), r;
  }
});
var Vi = (e, t) => {
  var a = B.wrapFragment(Ce(e.body, t), t), r = e.label.slice(1), n = t.sizeMultiplier, s, i = 0, o = me.isCharacterBox(e.body);
  if (r === "sout")
    s = B.makeSpan(["stretchy", "sout"]), s.height = t.fontMetrics().defaultRuleThickness / n, i = -0.5 * t.fontMetrics().xHeight;
  else if (r === "phase") {
    var c = Ge({
      number: 0.6,
      unit: "pt"
    }, t), u = Ge({
      number: 0.35,
      unit: "ex"
    }, t), d = t.havingBaseSizing();
    n = n / d.sizeMultiplier;
    var m = a.height + a.depth + c + u;
    a.style.paddingLeft = ee(m / 2 + c);
    var h = Math.floor(1e3 * m * n), y = Ry(h), w = new pa([new Sa("phase", y)], {
      width: "400em",
      height: ee(h / 1e3),
      viewBox: "0 0 400000 " + h,
      preserveAspectRatio: "xMinYMin slice"
    });
    s = B.makeSvgSpan(["hide-tail"], [w], t), s.style.height = ee(m), i = a.depth + c + u;
  } else {
    /cancel/.test(r) ? o || a.classes.push("cancel-pad") : r === "angl" ? a.classes.push("anglpad") : a.classes.push("boxpad");
    var v = 0, F = 0, z = 0;
    /box/.test(r) ? (z = Math.max(
      t.fontMetrics().fboxrule,
      // default
      t.minRuleThickness
      // User override.
    ), v = t.fontMetrics().fboxsep + (r === "colorbox" ? 0 : z), F = v) : r === "angl" ? (z = Math.max(t.fontMetrics().defaultRuleThickness, t.minRuleThickness), v = 4 * z, F = Math.max(0, 0.25 - a.depth)) : (v = o ? 0.2 : 0, F = v), s = ya.encloseSpan(a, r, v, F, t), /fbox|boxed|fcolorbox/.test(r) ? (s.style.borderStyle = "solid", s.style.borderWidth = ee(z)) : r === "angl" && z !== 0.049 && (s.style.borderTopWidth = ee(z), s.style.borderRightWidth = ee(z)), i = a.depth + F, e.backgroundColor && (s.style.backgroundColor = e.backgroundColor, e.borderColor && (s.style.borderColor = e.borderColor));
  }
  var C;
  if (e.backgroundColor)
    C = B.makeVList({
      positionType: "individualShift",
      children: [
        // Put the color background behind inner;
        {
          type: "elem",
          elem: s,
          shift: i
        },
        {
          type: "elem",
          elem: a,
          shift: 0
        }
      ]
    }, t);
  else {
    var U = /cancel|phase/.test(r) ? ["svg-align"] : [];
    C = B.makeVList({
      positionType: "individualShift",
      children: [
        // Write the \cancel stroke on top of inner.
        {
          type: "elem",
          elem: a,
          shift: 0
        },
        {
          type: "elem",
          elem: s,
          shift: i,
          wrapperClasses: U
        }
      ]
    }, t);
  }
  return /cancel/.test(r) && (C.height = a.height, C.depth = a.depth), /cancel/.test(r) && !o ? B.makeSpan(["mord", "cancel-lap"], [C], t) : B.makeSpan(["mord"], [C], t);
}, Gi = (e, t) => {
  var a = 0, r = new W.MathNode(e.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [Le(e.body, t)]);
  switch (e.label) {
    case "\\cancel":
      r.setAttribute("notation", "updiagonalstrike");
      break;
    case "\\bcancel":
      r.setAttribute("notation", "downdiagonalstrike");
      break;
    case "\\phase":
      r.setAttribute("notation", "phasorangle");
      break;
    case "\\sout":
      r.setAttribute("notation", "horizontalstrike");
      break;
    case "\\fbox":
      r.setAttribute("notation", "box");
      break;
    case "\\angl":
      r.setAttribute("notation", "actuarial");
      break;
    case "\\fcolorbox":
    case "\\colorbox":
      if (a = t.fontMetrics().fboxsep * t.fontMetrics().ptPerEm, r.setAttribute("width", "+" + 2 * a + "pt"), r.setAttribute("height", "+" + 2 * a + "pt"), r.setAttribute("lspace", a + "pt"), r.setAttribute("voffset", a + "pt"), e.label === "\\fcolorbox") {
        var n = Math.max(
          t.fontMetrics().fboxrule,
          // default
          t.minRuleThickness
          // user override
        );
        r.setAttribute("style", "border: " + n + "em solid " + String(e.borderColor));
      }
      break;
    case "\\xcancel":
      r.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
      break;
  }
  return e.backgroundColor && r.setAttribute("mathbackground", e.backgroundColor), r;
};
ne({
  type: "enclose",
  names: ["\\colorbox"],
  props: {
    numArgs: 2,
    allowedInText: !0,
    argTypes: ["color", "text"]
  },
  handler(e, t, a) {
    var {
      parser: r,
      funcName: n
    } = e, s = Te(t[0], "color-token").color, i = t[1];
    return {
      type: "enclose",
      mode: r.mode,
      label: n,
      backgroundColor: s,
      body: i
    };
  },
  htmlBuilder: Vi,
  mathmlBuilder: Gi
});
ne({
  type: "enclose",
  names: ["\\fcolorbox"],
  props: {
    numArgs: 3,
    allowedInText: !0,
    argTypes: ["color", "color", "text"]
  },
  handler(e, t, a) {
    var {
      parser: r,
      funcName: n
    } = e, s = Te(t[0], "color-token").color, i = Te(t[1], "color-token").color, o = t[2];
    return {
      type: "enclose",
      mode: r.mode,
      label: n,
      backgroundColor: i,
      borderColor: s,
      body: o
    };
  },
  htmlBuilder: Vi,
  mathmlBuilder: Gi
});
ne({
  type: "enclose",
  names: ["\\fbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: !0
  },
  handler(e, t) {
    var {
      parser: a
    } = e;
    return {
      type: "enclose",
      mode: a.mode,
      label: "\\fbox",
      body: t[0]
    };
  }
});
ne({
  type: "enclose",
  names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
  props: {
    numArgs: 1
  },
  handler(e, t) {
    var {
      parser: a,
      funcName: r
    } = e, n = t[0];
    return {
      type: "enclose",
      mode: a.mode,
      label: r,
      body: n
    };
  },
  htmlBuilder: Vi,
  mathmlBuilder: Gi
});
ne({
  type: "enclose",
  names: ["\\angl"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: !1
  },
  handler(e, t) {
    var {
      parser: a
    } = e;
    return {
      type: "enclose",
      mode: a.mode,
      label: "\\angl",
      body: t[0]
    };
  }
});
var s0 = {};
function ra(e) {
  for (var {
    type: t,
    names: a,
    props: r,
    handler: n,
    htmlBuilder: s,
    mathmlBuilder: i
  } = e, o = {
    type: t,
    numArgs: r.numArgs || 0,
    allowedInText: !1,
    numOptionalArgs: 0,
    handler: n
  }, c = 0; c < a.length; ++c)
    s0[a[c]] = o;
  s && (Fn[t] = s), i && (On[t] = i);
}
var i0 = {};
function k(e, t) {
  i0[e] = t;
}
function Dc(e) {
  var t = [];
  e.consumeSpaces();
  var a = e.fetch().text;
  for (a === "\\relax" && (e.consume(), e.consumeSpaces(), a = e.fetch().text); a === "\\hline" || a === "\\hdashline"; )
    e.consume(), t.push(a === "\\hdashline"), e.consumeSpaces(), a = e.fetch().text;
  return t;
}
var Jn = (e) => {
  var t = e.parser.settings;
  if (!t.displayMode)
    throw new Q("{" + e.envName + "} can be used only in display mode.");
};
function Wi(e) {
  if (e.indexOf("ed") === -1)
    return e.indexOf("*") === -1;
}
function Ra(e, t, a) {
  var {
    hskipBeforeAndAfter: r,
    addJot: n,
    cols: s,
    arraystretch: i,
    colSeparationType: o,
    autoTag: c,
    singleRow: u,
    emptySingleRow: d,
    maxNumCols: m,
    leqno: h
  } = t;
  if (e.gullet.beginGroup(), u || e.gullet.macros.set("\\cr", "\\\\\\relax"), !i) {
    var y = e.gullet.expandMacroAsText("\\arraystretch");
    if (y == null)
      i = 1;
    else if (i = parseFloat(y), !i || i < 0)
      throw new Q("Invalid \\arraystretch: " + y);
  }
  e.gullet.beginGroup();
  var w = [], v = [w], F = [], z = [], C = c != null ? [] : void 0;
  function U() {
    c && e.gullet.macros.set("\\@eqnsw", "1", !0);
  }
  function $() {
    C && (e.gullet.macros.get("\\df@tag") ? (C.push(e.subparse([new Pt("\\df@tag")])), e.gullet.macros.set("\\df@tag", void 0, !0)) : C.push(!!c && e.gullet.macros.get("\\@eqnsw") === "1"));
  }
  for (U(), z.push(Dc(e)); ; ) {
    var O = e.parseExpression(!1, u ? "\\end" : "\\\\");
    e.gullet.endGroup(), e.gullet.beginGroup(), O = {
      type: "ordgroup",
      mode: e.mode,
      body: O
    }, a && (O = {
      type: "styling",
      mode: e.mode,
      style: a,
      body: [O]
    }), w.push(O);
    var p = e.fetch().text;
    if (p === "&") {
      if (m && w.length === m) {
        if (u || o)
          throw new Q("Too many tab characters: &", e.nextToken);
        e.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
      }
      e.consume();
    } else if (p === "\\end") {
      $(), w.length === 1 && O.type === "styling" && O.body[0].body.length === 0 && (v.length > 1 || !d) && v.pop(), z.length < v.length + 1 && z.push([]);
      break;
    } else if (p === "\\\\") {
      e.consume();
      var M = void 0;
      e.gullet.future().text !== " " && (M = e.parseSizeGroup(!0)), F.push(M ? M.value : null), $(), z.push(Dc(e)), w = [], v.push(w), U();
    } else
      throw new Q("Expected & or \\\\ or \\cr or \\end", e.nextToken);
  }
  return e.gullet.endGroup(), e.gullet.endGroup(), {
    type: "array",
    mode: e.mode,
    addJot: n,
    arraystretch: i,
    body: v,
    cols: s,
    rowGaps: F,
    hskipBeforeAndAfter: r,
    hLinesBeforeRow: z,
    colSeparationType: o,
    tags: C,
    leqno: h
  };
}
function $i(e) {
  return e.slice(0, 1) === "d" ? "display" : "text";
}
var na = function(t, a) {
  var r, n, s = t.body.length, i = t.hLinesBeforeRow, o = 0, c = new Array(s), u = [], d = Math.max(
    // From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
    a.fontMetrics().arrayRuleWidth,
    a.minRuleThickness
    // User override.
  ), m = 1 / a.fontMetrics().ptPerEm, h = 5 * m;
  if (t.colSeparationType && t.colSeparationType === "small") {
    var y = a.havingStyle(ge.SCRIPT).sizeMultiplier;
    h = 0.2778 * (y / a.sizeMultiplier);
  }
  var w = t.colSeparationType === "CD" ? Ge({
    number: 3,
    unit: "ex"
  }, a) : 12 * m, v = 3 * m, F = t.arraystretch * w, z = 0.7 * F, C = 0.3 * F, U = 0;
  function $(Ft) {
    for (var lt = 0; lt < Ft.length; ++lt)
      lt > 0 && (U += 0.25), u.push({
        pos: U,
        isDashed: Ft[lt]
      });
  }
  for ($(i[0]), r = 0; r < t.body.length; ++r) {
    var O = t.body[r], p = z, M = C;
    o < O.length && (o = O.length);
    var te = new Array(O.length);
    for (n = 0; n < O.length; ++n) {
      var Z = Ce(O[n], a);
      M < Z.depth && (M = Z.depth), p < Z.height && (p = Z.height), te[n] = Z;
    }
    var P = t.rowGaps[r], re = 0;
    P && (re = Ge(P, a), re > 0 && (re += C, M < re && (M = re), re = 0)), t.addJot && (M += v), te.height = p, te.depth = M, U += p, te.pos = U, U += M + re, c[r] = te, $(i[r + 1]);
  }
  var ae = U / 2 + a.fontMetrics().axisHeight, ue = t.cols || [], de = [], fe, Se, Ne = [];
  if (t.tags && t.tags.some((Ft) => Ft))
    for (r = 0; r < s; ++r) {
      var je = c[r], et = je.pos - ae, S = t.tags[r], Me = void 0;
      S === !0 ? Me = B.makeSpan(["eqn-num"], [], a) : S === !1 ? Me = B.makeSpan([], [], a) : Me = B.makeSpan([], nt(S, a, !0), a), Me.depth = je.depth, Me.height = je.height, Ne.push({
        type: "elem",
        elem: Me,
        shift: et
      });
    }
  for (
    n = 0, Se = 0;
    // Continue while either there are more columns or more column
    // descriptions, so trailing separators don't get lost.
    n < o || Se < ue.length;
    ++n, ++Se
  ) {
    for (var Re = ue[Se] || {}, N = !0; Re.type === "separator"; ) {
      if (N || (fe = B.makeSpan(["arraycolsep"], []), fe.style.width = ee(a.fontMetrics().doubleRuleSep), de.push(fe)), Re.separator === "|" || Re.separator === ":") {
        var tt = Re.separator === "|" ? "solid" : "dashed", st = B.makeSpan(["vertical-separator"], [], a);
        st.style.height = ee(U), st.style.borderRightWidth = ee(d), st.style.borderRightStyle = tt, st.style.margin = "0 " + ee(-d / 2);
        var Fe = U - ae;
        Fe && (st.style.verticalAlign = ee(-Fe)), de.push(st);
      } else
        throw new Q("Invalid separator type: " + Re.separator);
      Se++, Re = ue[Se] || {}, N = !1;
    }
    if (!(n >= o)) {
      var Ke = void 0;
      (n > 0 || t.hskipBeforeAndAfter) && (Ke = me.deflt(Re.pregap, h), Ke !== 0 && (fe = B.makeSpan(["arraycolsep"], []), fe.style.width = ee(Ke), de.push(fe)));
      var He = [];
      for (r = 0; r < s; ++r) {
        var at = c[r], $e = at[n];
        if ($e) {
          var $t = at.pos - ae;
          $e.depth = at.depth, $e.height = at.height, He.push({
            type: "elem",
            elem: $e,
            shift: $t
          });
        }
      }
      He = B.makeVList({
        positionType: "individualShift",
        children: He
      }, a), He = B.makeSpan(["col-align-" + (Re.align || "c")], [He]), de.push(He), (n < o - 1 || t.hskipBeforeAndAfter) && (Ke = me.deflt(Re.postgap, h), Ke !== 0 && (fe = B.makeSpan(["arraycolsep"], []), fe.style.width = ee(Ke), de.push(fe)));
    }
  }
  if (c = B.makeSpan(["mtable"], de), u.length > 0) {
    for (var ia = B.makeLineSpan("hline", a, d), Fa = B.makeLineSpan("hdashline", a, d), oa = [{
      type: "elem",
      elem: c,
      shift: 0
    }]; u.length > 0; ) {
      var mt = u.pop(), ct = mt.pos - ae;
      mt.isDashed ? oa.push({
        type: "elem",
        elem: Fa,
        shift: ct
      }) : oa.push({
        type: "elem",
        elem: ia,
        shift: ct
      });
    }
    c = B.makeVList({
      positionType: "individualShift",
      children: oa
    }, a);
  }
  if (Ne.length === 0)
    return B.makeSpan(["mord"], [c], a);
  var Rt = B.makeVList({
    positionType: "individualShift",
    children: Ne
  }, a);
  return Rt = B.makeSpan(["tag"], [Rt], a), B.makeFragment([c, Rt]);
}, U_ = {
  c: "center ",
  l: "left ",
  r: "right "
}, sa = function(t, a) {
  for (var r = [], n = new W.MathNode("mtd", [], ["mtr-glue"]), s = new W.MathNode("mtd", [], ["mml-eqn-num"]), i = 0; i < t.body.length; i++) {
    for (var o = t.body[i], c = [], u = 0; u < o.length; u++)
      c.push(new W.MathNode("mtd", [Le(o[u], a)]));
    t.tags && t.tags[i] && (c.unshift(n), c.push(n), t.leqno ? c.unshift(s) : c.push(s)), r.push(new W.MathNode("mtr", c));
  }
  var d = new W.MathNode("mtable", r), m = t.arraystretch === 0.5 ? 0.1 : 0.16 + t.arraystretch - 1 + (t.addJot ? 0.09 : 0);
  d.setAttribute("rowspacing", ee(m));
  var h = "", y = "";
  if (t.cols && t.cols.length > 0) {
    var w = t.cols, v = "", F = !1, z = 0, C = w.length;
    w[0].type === "separator" && (h += "top ", z = 1), w[w.length - 1].type === "separator" && (h += "bottom ", C -= 1);
    for (var U = z; U < C; U++)
      w[U].type === "align" ? (y += U_[w[U].align], F && (v += "none "), F = !0) : w[U].type === "separator" && F && (v += w[U].separator === "|" ? "solid " : "dashed ", F = !1);
    d.setAttribute("columnalign", y.trim()), /[sd]/.test(v) && d.setAttribute("columnlines", v.trim());
  }
  if (t.colSeparationType === "align") {
    for (var $ = t.cols || [], O = "", p = 1; p < $.length; p++)
      O += p % 2 ? "0em " : "1em ";
    d.setAttribute("columnspacing", O.trim());
  } else t.colSeparationType === "alignat" || t.colSeparationType === "gather" ? d.setAttribute("columnspacing", "0em") : t.colSeparationType === "small" ? d.setAttribute("columnspacing", "0.2778em") : t.colSeparationType === "CD" ? d.setAttribute("columnspacing", "0.5em") : d.setAttribute("columnspacing", "1em");
  var M = "", te = t.hLinesBeforeRow;
  h += te[0].length > 0 ? "left " : "", h += te[te.length - 1].length > 0 ? "right " : "";
  for (var Z = 1; Z < te.length - 1; Z++)
    M += te[Z].length === 0 ? "none " : te[Z][0] ? "dashed " : "solid ";
  return /[sd]/.test(M) && d.setAttribute("rowlines", M.trim()), h !== "" && (d = new W.MathNode("menclose", [d]), d.setAttribute("notation", h.trim())), t.arraystretch && t.arraystretch < 1 && (d = new W.MathNode("mstyle", [d]), d.setAttribute("scriptlevel", "1")), d;
}, o0 = function(t, a) {
  t.envName.indexOf("ed") === -1 && Jn(t);
  var r = [], n = t.envName.indexOf("at") > -1 ? "alignat" : "align", s = t.envName === "split", i = Ra(t.parser, {
    cols: r,
    addJot: !0,
    autoTag: s ? void 0 : Wi(t.envName),
    emptySingleRow: !0,
    colSeparationType: n,
    maxNumCols: s ? 2 : void 0,
    leqno: t.parser.settings.leqno
  }, "display"), o, c = 0, u = {
    type: "ordgroup",
    mode: t.mode,
    body: []
  };
  if (a[0] && a[0].type === "ordgroup") {
    for (var d = "", m = 0; m < a[0].body.length; m++) {
      var h = Te(a[0].body[m], "textord");
      d += h.text;
    }
    o = Number(d), c = o * 2;
  }
  var y = !c;
  i.body.forEach(function(z) {
    for (var C = 1; C < z.length; C += 2) {
      var U = Te(z[C], "styling"), $ = Te(U.body[0], "ordgroup");
      $.body.unshift(u);
    }
    if (y)
      c < z.length && (c = z.length);
    else {
      var O = z.length / 2;
      if (o < O)
        throw new Q("Too many math in a row: " + ("expected " + o + ", but got " + O), z[0]);
    }
  });
  for (var w = 0; w < c; ++w) {
    var v = "r", F = 0;
    w % 2 === 1 ? v = "l" : w > 0 && y && (F = 1), r[w] = {
      type: "align",
      align: v,
      pregap: F,
      postgap: 0
    };
  }
  return i.colSeparationType = y ? "align" : "alignat", i;
};
ra({
  type: "array",
  names: ["array", "darray"],
  props: {
    numArgs: 1
  },
  handler(e, t) {
    var a = Xn(t[0]), r = a ? [t[0]] : Te(t[0], "ordgroup").body, n = r.map(function(i) {
      var o = ji(i), c = o.text;
      if ("lcr".indexOf(c) !== -1)
        return {
          type: "align",
          align: c
        };
      if (c === "|")
        return {
          type: "separator",
          separator: "|"
        };
      if (c === ":")
        return {
          type: "separator",
          separator: ":"
        };
      throw new Q("Unknown column alignment: " + c, i);
    }), s = {
      cols: n,
      hskipBeforeAndAfter: !0,
      // \@preamble in lttab.dtx
      maxNumCols: n.length
    };
    return Ra(e.parser, s, $i(e.envName));
  },
  htmlBuilder: na,
  mathmlBuilder: sa
});
ra({
  type: "array",
  names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
  props: {
    numArgs: 0
  },
  handler(e) {
    var t = {
      matrix: null,
      pmatrix: ["(", ")"],
      bmatrix: ["[", "]"],
      Bmatrix: ["\\{", "\\}"],
      vmatrix: ["|", "|"],
      Vmatrix: ["\\Vert", "\\Vert"]
    }[e.envName.replace("*", "")], a = "c", r = {
      hskipBeforeAndAfter: !1,
      cols: [{
        type: "align",
        align: a
      }]
    };
    if (e.envName.charAt(e.envName.length - 1) === "*") {
      var n = e.parser;
      if (n.consumeSpaces(), n.fetch().text === "[") {
        if (n.consume(), n.consumeSpaces(), a = n.fetch().text, "lcr".indexOf(a) === -1)
          throw new Q("Expected l or c or r", n.nextToken);
        n.consume(), n.consumeSpaces(), n.expect("]"), n.consume(), r.cols = [{
          type: "align",
          align: a
        }];
      }
    }
    var s = Ra(e.parser, r, $i(e.envName)), i = Math.max(0, ...s.body.map((o) => o.length));
    return s.cols = new Array(i).fill({
      type: "align",
      align: a
    }), t ? {
      type: "leftright",
      mode: e.mode,
      body: [s],
      left: t[0],
      right: t[1],
      rightColor: void 0
      // \right uninfluenced by \color in array
    } : s;
  },
  htmlBuilder: na,
  mathmlBuilder: sa
});
ra({
  type: "array",
  names: ["smallmatrix"],
  props: {
    numArgs: 0
  },
  handler(e) {
    var t = {
      arraystretch: 0.5
    }, a = Ra(e.parser, t, "script");
    return a.colSeparationType = "small", a;
  },
  htmlBuilder: na,
  mathmlBuilder: sa
});
ra({
  type: "array",
  names: ["subarray"],
  props: {
    numArgs: 1
  },
  handler(e, t) {
    var a = Xn(t[0]), r = a ? [t[0]] : Te(t[0], "ordgroup").body, n = r.map(function(i) {
      var o = ji(i), c = o.text;
      if ("lc".indexOf(c) !== -1)
        return {
          type: "align",
          align: c
        };
      throw new Q("Unknown column alignment: " + c, i);
    });
    if (n.length > 1)
      throw new Q("{subarray} can contain only one column");
    var s = {
      cols: n,
      hskipBeforeAndAfter: !1,
      arraystretch: 0.5
    };
    if (s = Ra(e.parser, s, "script"), s.body.length > 0 && s.body[0].length > 1)
      throw new Q("{subarray} can contain only one column");
    return s;
  },
  htmlBuilder: na,
  mathmlBuilder: sa
});
ra({
  type: "array",
  names: ["cases", "dcases", "rcases", "drcases"],
  props: {
    numArgs: 0
  },
  handler(e) {
    var t = {
      arraystretch: 1.2,
      cols: [{
        type: "align",
        align: "l",
        pregap: 0,
        // TODO(kevinb) get the current style.
        // For now we use the metrics for TEXT style which is what we were
        // doing before.  Before attempting to get the current style we
        // should look at TeX's behavior especially for \over and matrices.
        postgap: 1
        /* 1em quad */
      }, {
        type: "align",
        align: "l",
        pregap: 0,
        postgap: 0
      }]
    }, a = Ra(e.parser, t, $i(e.envName));
    return {
      type: "leftright",
      mode: e.mode,
      body: [a],
      left: e.envName.indexOf("r") > -1 ? "." : "\\{",
      right: e.envName.indexOf("r") > -1 ? "\\}" : ".",
      rightColor: void 0
    };
  },
  htmlBuilder: na,
  mathmlBuilder: sa
});
ra({
  type: "array",
  names: ["align", "align*", "aligned", "split"],
  props: {
    numArgs: 0
  },
  handler: o0,
  htmlBuilder: na,
  mathmlBuilder: sa
});
ra({
  type: "array",
  names: ["gathered", "gather", "gather*"],
  props: {
    numArgs: 0
  },
  handler(e) {
    me.contains(["gather", "gather*"], e.envName) && Jn(e);
    var t = {
      cols: [{
        type: "align",
        align: "c"
      }],
      addJot: !0,
      colSeparationType: "gather",
      autoTag: Wi(e.envName),
      emptySingleRow: !0,
      leqno: e.parser.settings.leqno
    };
    return Ra(e.parser, t, "display");
  },
  htmlBuilder: na,
  mathmlBuilder: sa
});
ra({
  type: "array",
  names: ["alignat", "alignat*", "alignedat"],
  props: {
    numArgs: 1
  },
  handler: o0,
  htmlBuilder: na,
  mathmlBuilder: sa
});
ra({
  type: "array",
  names: ["equation", "equation*"],
  props: {
    numArgs: 0
  },
  handler(e) {
    Jn(e);
    var t = {
      autoTag: Wi(e.envName),
      emptySingleRow: !0,
      singleRow: !0,
      maxNumCols: 1,
      leqno: e.parser.settings.leqno
    };
    return Ra(e.parser, t, "display");
  },
  htmlBuilder: na,
  mathmlBuilder: sa
});
ra({
  type: "array",
  names: ["CD"],
  props: {
    numArgs: 0
  },
  handler(e) {
    return Jn(e), D_(e.parser);
  },
  htmlBuilder: na,
  mathmlBuilder: sa
});
k("\\nonumber", "\\gdef\\@eqnsw{0}");
k("\\notag", "\\nonumber");
ne({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\hline", "\\hdashline"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !0
  },
  handler(e, t) {
    throw new Q(e.funcName + " valid only within array environment");
  }
});
var Cc = s0;
ne({
  type: "environment",
  names: ["\\begin", "\\end"],
  props: {
    numArgs: 1,
    argTypes: ["text"]
  },
  handler(e, t) {
    var {
      parser: a,
      funcName: r
    } = e, n = t[0];
    if (n.type !== "ordgroup")
      throw new Q("Invalid environment name", n);
    for (var s = "", i = 0; i < n.body.length; ++i)
      s += Te(n.body[i], "textord").text;
    if (r === "\\begin") {
      if (!Cc.hasOwnProperty(s))
        throw new Q("No such environment: " + s, n);
      var o = Cc[s], {
        args: c,
        optArgs: u
      } = a.parseArguments("\\begin{" + s + "}", o), d = {
        mode: a.mode,
        envName: s,
        parser: a
      }, m = o.handler(d, c, u);
      a.expect("\\end", !1);
      var h = a.nextToken, y = Te(a.parseFunction(), "environment");
      if (y.name !== s)
        throw new Q("Mismatch: \\begin{" + s + "} matched by \\end{" + y.name + "}", h);
      return m;
    }
    return {
      type: "environment",
      mode: a.mode,
      name: s,
      nameGroup: n
    };
  }
});
var c0 = (e, t) => {
  var a = e.font, r = t.withFont(a);
  return Ce(e.body, r);
}, l0 = (e, t) => {
  var a = e.font, r = t.withFont(a);
  return Le(e.body, r);
}, Sc = {
  "\\Bbb": "\\mathbb",
  "\\bold": "\\mathbf",
  "\\frak": "\\mathfrak",
  "\\bm": "\\boldsymbol"
};
ne({
  type: "font",
  names: [
    // styles, except \boldsymbol defined below
    "\\mathrm",
    "\\mathit",
    "\\mathbf",
    "\\mathnormal",
    // families
    "\\mathbb",
    "\\mathcal",
    "\\mathfrak",
    "\\mathscr",
    "\\mathsf",
    "\\mathtt",
    // aliases, except \bm defined below
    "\\Bbb",
    "\\bold",
    "\\frak"
  ],
  props: {
    numArgs: 1,
    allowedInArgument: !0
  },
  handler: (e, t) => {
    var {
      parser: a,
      funcName: r
    } = e, n = Ln(t[0]), s = r;
    return s in Sc && (s = Sc[s]), {
      type: "font",
      mode: a.mode,
      font: s.slice(1),
      body: n
    };
  },
  htmlBuilder: c0,
  mathmlBuilder: l0
});
ne({
  type: "mclass",
  names: ["\\boldsymbol", "\\bm"],
  props: {
    numArgs: 1
  },
  handler: (e, t) => {
    var {
      parser: a
    } = e, r = t[0], n = me.isCharacterBox(r);
    return {
      type: "mclass",
      mode: a.mode,
      mclass: Qn(r),
      body: [{
        type: "font",
        mode: a.mode,
        font: "boldsymbol",
        body: r
      }],
      isCharacterBox: n
    };
  }
});
ne({
  type: "font",
  names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: a,
      funcName: r,
      breakOnTokenText: n
    } = e, {
      mode: s
    } = a, i = a.parseExpression(!0, n), o = "math" + r.slice(1);
    return {
      type: "font",
      mode: s,
      font: o,
      body: {
        type: "ordgroup",
        mode: a.mode,
        body: i
      }
    };
  },
  htmlBuilder: c0,
  mathmlBuilder: l0
});
var u0 = (e, t) => {
  var a = t;
  return e === "display" ? a = a.id >= ge.SCRIPT.id ? a.text() : ge.DISPLAY : e === "text" && a.size === ge.DISPLAY.size ? a = ge.TEXT : e === "script" ? a = ge.SCRIPT : e === "scriptscript" && (a = ge.SCRIPTSCRIPT), a;
}, Xi = (e, t) => {
  var a = u0(e.size, t.style), r = a.fracNum(), n = a.fracDen(), s;
  s = t.havingStyle(r);
  var i = Ce(e.numer, s, t);
  if (e.continued) {
    var o = 8.5 / t.fontMetrics().ptPerEm, c = 3.5 / t.fontMetrics().ptPerEm;
    i.height = i.height < o ? o : i.height, i.depth = i.depth < c ? c : i.depth;
  }
  s = t.havingStyle(n);
  var u = Ce(e.denom, s, t), d, m, h;
  e.hasBarLine ? (e.barSize ? (m = Ge(e.barSize, t), d = B.makeLineSpan("frac-line", t, m)) : d = B.makeLineSpan("frac-line", t), m = d.height, h = d.height) : (d = null, m = 0, h = t.fontMetrics().defaultRuleThickness);
  var y, w, v;
  a.size === ge.DISPLAY.size || e.size === "display" ? (y = t.fontMetrics().num1, m > 0 ? w = 3 * h : w = 7 * h, v = t.fontMetrics().denom1) : (m > 0 ? (y = t.fontMetrics().num2, w = h) : (y = t.fontMetrics().num3, w = 3 * h), v = t.fontMetrics().denom2);
  var F;
  if (d) {
    var C = t.fontMetrics().axisHeight;
    y - i.depth - (C + 0.5 * m) < w && (y += w - (y - i.depth - (C + 0.5 * m))), C - 0.5 * m - (u.height - v) < w && (v += w - (C - 0.5 * m - (u.height - v)));
    var U = -(C - 0.5 * m);
    F = B.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: u,
        shift: v
      }, {
        type: "elem",
        elem: d,
        shift: U
      }, {
        type: "elem",
        elem: i,
        shift: -y
      }]
    }, t);
  } else {
    var z = y - i.depth - (u.height - v);
    z < w && (y += 0.5 * (w - z), v += 0.5 * (w - z)), F = B.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: u,
        shift: v
      }, {
        type: "elem",
        elem: i,
        shift: -y
      }]
    }, t);
  }
  s = t.havingStyle(a), F.height *= s.sizeMultiplier / t.sizeMultiplier, F.depth *= s.sizeMultiplier / t.sizeMultiplier;
  var $;
  a.size === ge.DISPLAY.size ? $ = t.fontMetrics().delim1 : a.size === ge.SCRIPTSCRIPT.size ? $ = t.havingStyle(ge.SCRIPT).fontMetrics().delim2 : $ = t.fontMetrics().delim2;
  var O, p;
  return e.leftDelim == null ? O = $r(t, ["mopen"]) : O = ma.customSizedDelim(e.leftDelim, $, !0, t.havingStyle(a), e.mode, ["mopen"]), e.continued ? p = B.makeSpan([]) : e.rightDelim == null ? p = $r(t, ["mclose"]) : p = ma.customSizedDelim(e.rightDelim, $, !0, t.havingStyle(a), e.mode, ["mclose"]), B.makeSpan(["mord"].concat(s.sizingClasses(t)), [O, B.makeSpan(["mfrac"], [F]), p], t);
}, Qi = (e, t) => {
  var a = new W.MathNode("mfrac", [Le(e.numer, t), Le(e.denom, t)]);
  if (!e.hasBarLine)
    a.setAttribute("linethickness", "0px");
  else if (e.barSize) {
    var r = Ge(e.barSize, t);
    a.setAttribute("linethickness", ee(r));
  }
  var n = u0(e.size, t.style);
  if (n.size !== t.style.size) {
    a = new W.MathNode("mstyle", [a]);
    var s = n.size === ge.DISPLAY.size ? "true" : "false";
    a.setAttribute("displaystyle", s), a.setAttribute("scriptlevel", "0");
  }
  if (e.leftDelim != null || e.rightDelim != null) {
    var i = [];
    if (e.leftDelim != null) {
      var o = new W.MathNode("mo", [new W.TextNode(e.leftDelim.replace("\\", ""))]);
      o.setAttribute("fence", "true"), i.push(o);
    }
    if (i.push(a), e.rightDelim != null) {
      var c = new W.MathNode("mo", [new W.TextNode(e.rightDelim.replace("\\", ""))]);
      c.setAttribute("fence", "true"), i.push(c);
    }
    return Hi(i);
  }
  return a;
};
ne({
  type: "genfrac",
  names: [
    "\\dfrac",
    "\\frac",
    "\\tfrac",
    "\\dbinom",
    "\\binom",
    "\\tbinom",
    "\\\\atopfrac",
    // cant be entered directly
    "\\\\bracefrac",
    "\\\\brackfrac"
    // ditto
  ],
  props: {
    numArgs: 2,
    allowedInArgument: !0
  },
  handler: (e, t) => {
    var {
      parser: a,
      funcName: r
    } = e, n = t[0], s = t[1], i, o = null, c = null, u = "auto";
    switch (r) {
      case "\\dfrac":
      case "\\frac":
      case "\\tfrac":
        i = !0;
        break;
      case "\\\\atopfrac":
        i = !1;
        break;
      case "\\dbinom":
      case "\\binom":
      case "\\tbinom":
        i = !1, o = "(", c = ")";
        break;
      case "\\\\bracefrac":
        i = !1, o = "\\{", c = "\\}";
        break;
      case "\\\\brackfrac":
        i = !1, o = "[", c = "]";
        break;
      default:
        throw new Error("Unrecognized genfrac command");
    }
    switch (r) {
      case "\\dfrac":
      case "\\dbinom":
        u = "display";
        break;
      case "\\tfrac":
      case "\\tbinom":
        u = "text";
        break;
    }
    return {
      type: "genfrac",
      mode: a.mode,
      continued: !1,
      numer: n,
      denom: s,
      hasBarLine: i,
      leftDelim: o,
      rightDelim: c,
      size: u,
      barSize: null
    };
  },
  htmlBuilder: Xi,
  mathmlBuilder: Qi
});
ne({
  type: "genfrac",
  names: ["\\cfrac"],
  props: {
    numArgs: 2
  },
  handler: (e, t) => {
    var {
      parser: a,
      funcName: r
    } = e, n = t[0], s = t[1];
    return {
      type: "genfrac",
      mode: a.mode,
      continued: !0,
      numer: n,
      denom: s,
      hasBarLine: !0,
      leftDelim: null,
      rightDelim: null,
      size: "display",
      barSize: null
    };
  }
});
ne({
  type: "infix",
  names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
  props: {
    numArgs: 0,
    infix: !0
  },
  handler(e) {
    var {
      parser: t,
      funcName: a,
      token: r
    } = e, n;
    switch (a) {
      case "\\over":
        n = "\\frac";
        break;
      case "\\choose":
        n = "\\binom";
        break;
      case "\\atop":
        n = "\\\\atopfrac";
        break;
      case "\\brace":
        n = "\\\\bracefrac";
        break;
      case "\\brack":
        n = "\\\\brackfrac";
        break;
      default:
        throw new Error("Unrecognized infix genfrac command");
    }
    return {
      type: "infix",
      mode: t.mode,
      replaceWith: n,
      token: r
    };
  }
});
var zc = ["display", "text", "script", "scriptscript"], Nc = function(t) {
  var a = null;
  return t.length > 0 && (a = t, a = a === "." ? null : a), a;
};
ne({
  type: "genfrac",
  names: ["\\genfrac"],
  props: {
    numArgs: 6,
    allowedInArgument: !0,
    argTypes: ["math", "math", "size", "text", "math", "math"]
  },
  handler(e, t) {
    var {
      parser: a
    } = e, r = t[4], n = t[5], s = Ln(t[0]), i = s.type === "atom" && s.family === "open" ? Nc(s.text) : null, o = Ln(t[1]), c = o.type === "atom" && o.family === "close" ? Nc(o.text) : null, u = Te(t[2], "size"), d, m = null;
    u.isBlank ? d = !0 : (m = u.value, d = m.number > 0);
    var h = "auto", y = t[3];
    if (y.type === "ordgroup") {
      if (y.body.length > 0) {
        var w = Te(y.body[0], "textord");
        h = zc[Number(w.text)];
      }
    } else
      y = Te(y, "textord"), h = zc[Number(y.text)];
    return {
      type: "genfrac",
      mode: a.mode,
      numer: r,
      denom: n,
      continued: !1,
      hasBarLine: d,
      barSize: m,
      leftDelim: i,
      rightDelim: c,
      size: h
    };
  },
  htmlBuilder: Xi,
  mathmlBuilder: Qi
});
ne({
  type: "infix",
  names: ["\\above"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    infix: !0
  },
  handler(e, t) {
    var {
      parser: a,
      funcName: r,
      token: n
    } = e;
    return {
      type: "infix",
      mode: a.mode,
      replaceWith: "\\\\abovefrac",
      size: Te(t[0], "size").value,
      token: n
    };
  }
});
ne({
  type: "genfrac",
  names: ["\\\\abovefrac"],
  props: {
    numArgs: 3,
    argTypes: ["math", "size", "math"]
  },
  handler: (e, t) => {
    var {
      parser: a,
      funcName: r
    } = e, n = t[0], s = _y(Te(t[1], "infix").size), i = t[2], o = s.number > 0;
    return {
      type: "genfrac",
      mode: a.mode,
      numer: n,
      denom: i,
      continued: !1,
      hasBarLine: o,
      barSize: s,
      leftDelim: null,
      rightDelim: null,
      size: "auto"
    };
  },
  htmlBuilder: Xi,
  mathmlBuilder: Qi
});
var f0 = (e, t) => {
  var a = t.style, r, n;
  e.type === "supsub" ? (r = e.sup ? Ce(e.sup, t.havingStyle(a.sup()), t) : Ce(e.sub, t.havingStyle(a.sub()), t), n = Te(e.base, "horizBrace")) : n = Te(e, "horizBrace");
  var s = Ce(n.base, t.havingBaseStyle(ge.DISPLAY)), i = ya.svgSpan(n, t), o;
  if (n.isOver ? (o = B.makeVList({
    positionType: "firstBaseline",
    children: [{
      type: "elem",
      elem: s
    }, {
      type: "kern",
      size: 0.1
    }, {
      type: "elem",
      elem: i
    }]
  }, t), o.children[0].children[0].children[1].classes.push("svg-align")) : (o = B.makeVList({
    positionType: "bottom",
    positionData: s.depth + 0.1 + i.height,
    children: [{
      type: "elem",
      elem: i
    }, {
      type: "kern",
      size: 0.1
    }, {
      type: "elem",
      elem: s
    }]
  }, t), o.children[0].children[0].children[0].classes.push("svg-align")), r) {
    var c = B.makeSpan(["mord", n.isOver ? "mover" : "munder"], [o], t);
    n.isOver ? o = B.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: c
      }, {
        type: "kern",
        size: 0.2
      }, {
        type: "elem",
        elem: r
      }]
    }, t) : o = B.makeVList({
      positionType: "bottom",
      positionData: c.depth + 0.2 + r.height + r.depth,
      children: [{
        type: "elem",
        elem: r
      }, {
        type: "kern",
        size: 0.2
      }, {
        type: "elem",
        elem: c
      }]
    }, t);
  }
  return B.makeSpan(["mord", n.isOver ? "mover" : "munder"], [o], t);
}, j_ = (e, t) => {
  var a = ya.mathMLnode(e.label);
  return new W.MathNode(e.isOver ? "mover" : "munder", [Le(e.base, t), a]);
};
ne({
  type: "horizBrace",
  names: ["\\overbrace", "\\underbrace"],
  props: {
    numArgs: 1
  },
  handler(e, t) {
    var {
      parser: a,
      funcName: r
    } = e;
    return {
      type: "horizBrace",
      mode: a.mode,
      label: r,
      isOver: /^\\over/.test(r),
      base: t[0]
    };
  },
  htmlBuilder: f0,
  mathmlBuilder: j_
});
ne({
  type: "href",
  names: ["\\href"],
  props: {
    numArgs: 2,
    argTypes: ["url", "original"],
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: a
    } = e, r = t[1], n = Te(t[0], "url").url;
    return a.settings.isTrusted({
      command: "\\href",
      url: n
    }) ? {
      type: "href",
      mode: a.mode,
      href: n,
      body: Qe(r)
    } : a.formatUnsupportedCmd("\\href");
  },
  htmlBuilder: (e, t) => {
    var a = nt(e.body, t, !1);
    return B.makeAnchor(e.href, [], a, t);
  },
  mathmlBuilder: (e, t) => {
    var a = za(e.body, t);
    return a instanceof Lt || (a = new Lt("mrow", [a])), a.setAttribute("href", e.href), a;
  }
});
ne({
  type: "href",
  names: ["\\url"],
  props: {
    numArgs: 1,
    argTypes: ["url"],
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: a
    } = e, r = Te(t[0], "url").url;
    if (!a.settings.isTrusted({
      command: "\\url",
      url: r
    }))
      return a.formatUnsupportedCmd("\\url");
    for (var n = [], s = 0; s < r.length; s++) {
      var i = r[s];
      i === "~" && (i = "\\textasciitilde"), n.push({
        type: "textord",
        mode: "text",
        text: i
      });
    }
    var o = {
      type: "text",
      mode: a.mode,
      font: "\\texttt",
      body: n
    };
    return {
      type: "href",
      mode: a.mode,
      href: r,
      body: Qe(o)
    };
  }
});
ne({
  type: "hbox",
  names: ["\\hbox"],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInText: !0,
    primitive: !0
  },
  handler(e, t) {
    var {
      parser: a
    } = e;
    return {
      type: "hbox",
      mode: a.mode,
      body: Qe(t[0])
    };
  },
  htmlBuilder(e, t) {
    var a = nt(e.body, t, !1);
    return B.makeFragment(a);
  },
  mathmlBuilder(e, t) {
    return new W.MathNode("mrow", Tt(e.body, t));
  }
});
ne({
  type: "html",
  names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
  props: {
    numArgs: 2,
    argTypes: ["raw", "original"],
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: a,
      funcName: r,
      token: n
    } = e, s = Te(t[0], "raw").string, i = t[1];
    a.settings.strict && a.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
    var o, c = {};
    switch (r) {
      case "\\htmlClass":
        c.class = s, o = {
          command: "\\htmlClass",
          class: s
        };
        break;
      case "\\htmlId":
        c.id = s, o = {
          command: "\\htmlId",
          id: s
        };
        break;
      case "\\htmlStyle":
        c.style = s, o = {
          command: "\\htmlStyle",
          style: s
        };
        break;
      case "\\htmlData": {
        for (var u = s.split(","), d = 0; d < u.length; d++) {
          var m = u[d].split("=");
          if (m.length !== 2)
            throw new Q("Error parsing key-value for \\htmlData");
          c["data-" + m[0].trim()] = m[1].trim();
        }
        o = {
          command: "\\htmlData",
          attributes: c
        };
        break;
      }
      default:
        throw new Error("Unrecognized html command");
    }
    return a.settings.isTrusted(o) ? {
      type: "html",
      mode: a.mode,
      attributes: c,
      body: Qe(i)
    } : a.formatUnsupportedCmd(r);
  },
  htmlBuilder: (e, t) => {
    var a = nt(e.body, t, !1), r = ["enclosing"];
    e.attributes.class && r.push(...e.attributes.class.trim().split(/\s+/));
    var n = B.makeSpan(r, a, t);
    for (var s in e.attributes)
      s !== "class" && e.attributes.hasOwnProperty(s) && n.setAttribute(s, e.attributes[s]);
    return n;
  },
  mathmlBuilder: (e, t) => za(e.body, t)
});
ne({
  type: "htmlmathml",
  names: ["\\html@mathml"],
  props: {
    numArgs: 2,
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: a
    } = e;
    return {
      type: "htmlmathml",
      mode: a.mode,
      html: Qe(t[0]),
      mathml: Qe(t[1])
    };
  },
  htmlBuilder: (e, t) => {
    var a = nt(e.html, t, !1);
    return B.makeFragment(a);
  },
  mathmlBuilder: (e, t) => za(e.mathml, t)
});
var Bs = function(t) {
  if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(t))
    return {
      number: +t,
      unit: "bp"
    };
  var a = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(t);
  if (!a)
    throw new Q("Invalid size: '" + t + "' in \\includegraphics");
  var r = {
    number: +(a[1] + a[2]),
    // sign + magnitude, cast to number
    unit: a[3]
  };
  if (!zu(r))
    throw new Q("Invalid unit: '" + r.unit + "' in \\includegraphics.");
  return r;
};
ne({
  type: "includegraphics",
  names: ["\\includegraphics"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    argTypes: ["raw", "url"],
    allowedInText: !1
  },
  handler: (e, t, a) => {
    var {
      parser: r
    } = e, n = {
      number: 0,
      unit: "em"
    }, s = {
      number: 0.9,
      unit: "em"
    }, i = {
      number: 0,
      unit: "em"
    }, o = "";
    if (a[0])
      for (var c = Te(a[0], "raw").string, u = c.split(","), d = 0; d < u.length; d++) {
        var m = u[d].split("=");
        if (m.length === 2) {
          var h = m[1].trim();
          switch (m[0].trim()) {
            case "alt":
              o = h;
              break;
            case "width":
              n = Bs(h);
              break;
            case "height":
              s = Bs(h);
              break;
            case "totalheight":
              i = Bs(h);
              break;
            default:
              throw new Q("Invalid key: '" + m[0] + "' in \\includegraphics.");
          }
        }
      }
    var y = Te(t[0], "url").url;
    return o === "" && (o = y, o = o.replace(/^.*[\\/]/, ""), o = o.substring(0, o.lastIndexOf("."))), r.settings.isTrusted({
      command: "\\includegraphics",
      url: y
    }) ? {
      type: "includegraphics",
      mode: r.mode,
      alt: o,
      width: n,
      height: s,
      totalheight: i,
      src: y
    } : r.formatUnsupportedCmd("\\includegraphics");
  },
  htmlBuilder: (e, t) => {
    var a = Ge(e.height, t), r = 0;
    e.totalheight.number > 0 && (r = Ge(e.totalheight, t) - a);
    var n = 0;
    e.width.number > 0 && (n = Ge(e.width, t));
    var s = {
      height: ee(a + r)
    };
    n > 0 && (s.width = ee(n)), r > 0 && (s.verticalAlign = ee(-r));
    var i = new jy(e.src, e.alt, s);
    return i.height = a, i.depth = r, i;
  },
  mathmlBuilder: (e, t) => {
    var a = new W.MathNode("mglyph", []);
    a.setAttribute("alt", e.alt);
    var r = Ge(e.height, t), n = 0;
    if (e.totalheight.number > 0 && (n = Ge(e.totalheight, t) - r, a.setAttribute("valign", ee(-n))), a.setAttribute("height", ee(r + n)), e.width.number > 0) {
      var s = Ge(e.width, t);
      a.setAttribute("width", ee(s));
    }
    return a.setAttribute("src", e.src), a;
  }
});
ne({
  type: "kern",
  names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    primitive: !0,
    allowedInText: !0
  },
  handler(e, t) {
    var {
      parser: a,
      funcName: r
    } = e, n = Te(t[0], "size");
    if (a.settings.strict) {
      var s = r[1] === "m", i = n.value.unit === "mu";
      s ? (i || a.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + r + " supports only mu units, " + ("not " + n.value.unit + " units")), a.mode !== "math" && a.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + r + " works only in math mode")) : i && a.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + r + " doesn't support mu units");
    }
    return {
      type: "kern",
      mode: a.mode,
      dimension: n.value
    };
  },
  htmlBuilder(e, t) {
    return B.makeGlue(e.dimension, t);
  },
  mathmlBuilder(e, t) {
    var a = Ge(e.dimension, t);
    return new W.SpaceNode(a);
  }
});
ne({
  type: "lap",
  names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: a,
      funcName: r
    } = e, n = t[0];
    return {
      type: "lap",
      mode: a.mode,
      alignment: r.slice(5),
      body: n
    };
  },
  htmlBuilder: (e, t) => {
    var a;
    e.alignment === "clap" ? (a = B.makeSpan([], [Ce(e.body, t)]), a = B.makeSpan(["inner"], [a], t)) : a = B.makeSpan(["inner"], [Ce(e.body, t)]);
    var r = B.makeSpan(["fix"], []), n = B.makeSpan([e.alignment], [a, r], t), s = B.makeSpan(["strut"]);
    return s.style.height = ee(n.height + n.depth), n.depth && (s.style.verticalAlign = ee(-n.depth)), n.children.unshift(s), n = B.makeSpan(["thinbox"], [n], t), B.makeSpan(["mord", "vbox"], [n], t);
  },
  mathmlBuilder: (e, t) => {
    var a = new W.MathNode("mpadded", [Le(e.body, t)]);
    if (e.alignment !== "rlap") {
      var r = e.alignment === "llap" ? "-1" : "-0.5";
      a.setAttribute("lspace", r + "width");
    }
    return a.setAttribute("width", "0px"), a;
  }
});
ne({
  type: "styling",
  names: ["\\(", "$"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !1
  },
  handler(e, t) {
    var {
      funcName: a,
      parser: r
    } = e, n = r.mode;
    r.switchMode("math");
    var s = a === "\\(" ? "\\)" : "$", i = r.parseExpression(!1, s);
    return r.expect(s), r.switchMode(n), {
      type: "styling",
      mode: r.mode,
      style: "text",
      body: i
    };
  }
});
ne({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\)", "\\]"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !1
  },
  handler(e, t) {
    throw new Q("Mismatched " + e.funcName);
  }
});
var Ic = (e, t) => {
  switch (t.style.size) {
    case ge.DISPLAY.size:
      return e.display;
    case ge.TEXT.size:
      return e.text;
    case ge.SCRIPT.size:
      return e.script;
    case ge.SCRIPTSCRIPT.size:
      return e.scriptscript;
    default:
      return e.text;
  }
};
ne({
  type: "mathchoice",
  names: ["\\mathchoice"],
  props: {
    numArgs: 4,
    primitive: !0
  },
  handler: (e, t) => {
    var {
      parser: a
    } = e;
    return {
      type: "mathchoice",
      mode: a.mode,
      display: Qe(t[0]),
      text: Qe(t[1]),
      script: Qe(t[2]),
      scriptscript: Qe(t[3])
    };
  },
  htmlBuilder: (e, t) => {
    var a = Ic(e, t), r = nt(a, t, !1);
    return B.makeFragment(r);
  },
  mathmlBuilder: (e, t) => {
    var a = Ic(e, t);
    return za(a, t);
  }
});
var h0 = (e, t, a, r, n, s, i) => {
  e = B.makeSpan([], [e]);
  var o = a && me.isCharacterBox(a), c, u;
  if (t) {
    var d = Ce(t, r.havingStyle(n.sup()), r);
    u = {
      elem: d,
      kern: Math.max(r.fontMetrics().bigOpSpacing1, r.fontMetrics().bigOpSpacing3 - d.depth)
    };
  }
  if (a) {
    var m = Ce(a, r.havingStyle(n.sub()), r);
    c = {
      elem: m,
      kern: Math.max(r.fontMetrics().bigOpSpacing2, r.fontMetrics().bigOpSpacing4 - m.height)
    };
  }
  var h;
  if (u && c) {
    var y = r.fontMetrics().bigOpSpacing5 + c.elem.height + c.elem.depth + c.kern + e.depth + i;
    h = B.makeVList({
      positionType: "bottom",
      positionData: y,
      children: [{
        type: "kern",
        size: r.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: c.elem,
        marginLeft: ee(-s)
      }, {
        type: "kern",
        size: c.kern
      }, {
        type: "elem",
        elem: e
      }, {
        type: "kern",
        size: u.kern
      }, {
        type: "elem",
        elem: u.elem,
        marginLeft: ee(s)
      }, {
        type: "kern",
        size: r.fontMetrics().bigOpSpacing5
      }]
    }, r);
  } else if (c) {
    var w = e.height - i;
    h = B.makeVList({
      positionType: "top",
      positionData: w,
      children: [{
        type: "kern",
        size: r.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: c.elem,
        marginLeft: ee(-s)
      }, {
        type: "kern",
        size: c.kern
      }, {
        type: "elem",
        elem: e
      }]
    }, r);
  } else if (u) {
    var v = e.depth + i;
    h = B.makeVList({
      positionType: "bottom",
      positionData: v,
      children: [{
        type: "elem",
        elem: e
      }, {
        type: "kern",
        size: u.kern
      }, {
        type: "elem",
        elem: u.elem,
        marginLeft: ee(s)
      }, {
        type: "kern",
        size: r.fontMetrics().bigOpSpacing5
      }]
    }, r);
  } else
    return e;
  var F = [h];
  if (c && s !== 0 && !o) {
    var z = B.makeSpan(["mspace"], [], r);
    z.style.marginRight = ee(s), F.unshift(z);
  }
  return B.makeSpan(["mop", "op-limits"], F, r);
}, d0 = ["\\smallint"], fr = (e, t) => {
  var a, r, n = !1, s;
  e.type === "supsub" ? (a = e.sup, r = e.sub, s = Te(e.base, "op"), n = !0) : s = Te(e, "op");
  var i = t.style, o = !1;
  i.size === ge.DISPLAY.size && s.symbol && !me.contains(d0, s.name) && (o = !0);
  var c;
  if (s.symbol) {
    var u = o ? "Size2-Regular" : "Size1-Regular", d = "";
    if ((s.name === "\\oiint" || s.name === "\\oiiint") && (d = s.name.slice(1), s.name = d === "oiint" ? "\\iint" : "\\iiint"), c = B.makeSymbol(s.name, u, "math", t, ["mop", "op-symbol", o ? "large-op" : "small-op"]), d.length > 0) {
      var m = c.italic, h = B.staticSvg(d + "Size" + (o ? "2" : "1"), t);
      c = B.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: c,
          shift: 0
        }, {
          type: "elem",
          elem: h,
          shift: o ? 0.08 : 0
        }]
      }, t), s.name = "\\" + d, c.classes.unshift("mop"), c.italic = m;
    }
  } else if (s.body) {
    var y = nt(s.body, t, !0);
    y.length === 1 && y[0] instanceof Ht ? (c = y[0], c.classes[0] = "mop") : c = B.makeSpan(["mop"], y, t);
  } else {
    for (var w = [], v = 1; v < s.name.length; v++)
      w.push(B.mathsym(s.name[v], s.mode, t));
    c = B.makeSpan(["mop"], w, t);
  }
  var F = 0, z = 0;
  return (c instanceof Ht || s.name === "\\oiint" || s.name === "\\oiiint") && !s.suppressBaseShift && (F = (c.height - c.depth) / 2 - t.fontMetrics().axisHeight, z = c.italic), n ? h0(c, a, r, t, i, z, F) : (F && (c.style.position = "relative", c.style.top = ee(F)), c);
}, an = (e, t) => {
  var a;
  if (e.symbol)
    a = new Lt("mo", [Ut(e.name, e.mode)]), me.contains(d0, e.name) && a.setAttribute("largeop", "false");
  else if (e.body)
    a = new Lt("mo", Tt(e.body, t));
  else {
    a = new Lt("mi", [new Mr(e.name.slice(1))]);
    var r = new Lt("mo", [Ut("", "text")]);
    e.parentIsSupSub ? a = new Lt("mrow", [a, r]) : a = Uu([a, r]);
  }
  return a;
}, q_ = {
  "": "\\prod",
  "": "\\coprod",
  "": "\\sum",
  "": "\\bigwedge",
  "": "\\bigvee",
  "": "\\bigcap",
  "": "\\bigcup",
  "": "\\bigodot",
  "": "\\bigoplus",
  "": "\\bigotimes",
  "": "\\biguplus",
  "": "\\bigsqcup"
};
ne({
  type: "op",
  names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "", "", "", "", "", "", "", "", "", "", "", ""],
  props: {
    numArgs: 0
  },
  handler: (e, t) => {
    var {
      parser: a,
      funcName: r
    } = e, n = r;
    return n.length === 1 && (n = q_[n]), {
      type: "op",
      mode: a.mode,
      limits: !0,
      parentIsSupSub: !1,
      symbol: !0,
      name: n
    };
  },
  htmlBuilder: fr,
  mathmlBuilder: an
});
ne({
  type: "op",
  names: ["\\mathop"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (e, t) => {
    var {
      parser: a
    } = e, r = t[0];
    return {
      type: "op",
      mode: a.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !1,
      body: Qe(r)
    };
  },
  htmlBuilder: fr,
  mathmlBuilder: an
});
var Y_ = {
  "": "\\int",
  "": "\\iint",
  "": "\\iiint",
  "": "\\oint",
  "": "\\oiint",
  "": "\\oiiint"
};
ne({
  type: "op",
  names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
  props: {
    numArgs: 0
  },
  handler(e) {
    var {
      parser: t,
      funcName: a
    } = e;
    return {
      type: "op",
      mode: t.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !1,
      name: a
    };
  },
  htmlBuilder: fr,
  mathmlBuilder: an
});
ne({
  type: "op",
  names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
  props: {
    numArgs: 0
  },
  handler(e) {
    var {
      parser: t,
      funcName: a
    } = e;
    return {
      type: "op",
      mode: t.mode,
      limits: !0,
      parentIsSupSub: !1,
      symbol: !1,
      name: a
    };
  },
  htmlBuilder: fr,
  mathmlBuilder: an
});
ne({
  type: "op",
  names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "", "", "", "", "", ""],
  props: {
    numArgs: 0
  },
  handler(e) {
    var {
      parser: t,
      funcName: a
    } = e, r = a;
    return r.length === 1 && (r = Y_[r]), {
      type: "op",
      mode: t.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !0,
      name: r
    };
  },
  htmlBuilder: fr,
  mathmlBuilder: an
});
var m0 = (e, t) => {
  var a, r, n = !1, s;
  e.type === "supsub" ? (a = e.sup, r = e.sub, s = Te(e.base, "operatorname"), n = !0) : s = Te(e, "operatorname");
  var i;
  if (s.body.length > 0) {
    for (var o = s.body.map((m) => {
      var h = m.text;
      return typeof h == "string" ? {
        type: "textord",
        mode: m.mode,
        text: h
      } : m;
    }), c = nt(o, t.withFont("mathrm"), !0), u = 0; u < c.length; u++) {
      var d = c[u];
      d instanceof Ht && (d.text = d.text.replace(/\u2212/, "-").replace(/\u2217/, "*"));
    }
    i = B.makeSpan(["mop"], c, t);
  } else
    i = B.makeSpan(["mop"], [], t);
  return n ? h0(i, a, r, t, t.style, 0, 0) : i;
}, V_ = (e, t) => {
  for (var a = Tt(e.body, t.withFont("mathrm")), r = !0, n = 0; n < a.length; n++) {
    var s = a[n];
    if (!(s instanceof W.SpaceNode)) if (s instanceof W.MathNode)
      switch (s.type) {
        case "mi":
        case "mn":
        case "ms":
        case "mspace":
        case "mtext":
          break;
        case "mo": {
          var i = s.children[0];
          s.children.length === 1 && i instanceof W.TextNode ? i.text = i.text.replace(/\u2212/, "-").replace(/\u2217/, "*") : r = !1;
          break;
        }
        default:
          r = !1;
      }
    else
      r = !1;
  }
  if (r) {
    var o = a.map((d) => d.toText()).join("");
    a = [new W.TextNode(o)];
  }
  var c = new W.MathNode("mi", a);
  c.setAttribute("mathvariant", "normal");
  var u = new W.MathNode("mo", [Ut("", "text")]);
  return e.parentIsSupSub ? new W.MathNode("mrow", [c, u]) : W.newDocumentFragment([c, u]);
};
ne({
  type: "operatorname",
  names: ["\\operatorname@", "\\operatornamewithlimits"],
  props: {
    numArgs: 1
  },
  handler: (e, t) => {
    var {
      parser: a,
      funcName: r
    } = e, n = t[0];
    return {
      type: "operatorname",
      mode: a.mode,
      body: Qe(n),
      alwaysHandleSupSub: r === "\\operatornamewithlimits",
      limits: !1,
      parentIsSupSub: !1
    };
  },
  htmlBuilder: m0,
  mathmlBuilder: V_
});
k("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
Wa({
  type: "ordgroup",
  htmlBuilder(e, t) {
    return e.semisimple ? B.makeFragment(nt(e.body, t, !1)) : B.makeSpan(["mord"], nt(e.body, t, !0), t);
  },
  mathmlBuilder(e, t) {
    return za(e.body, t, !0);
  }
});
ne({
  type: "overline",
  names: ["\\overline"],
  props: {
    numArgs: 1
  },
  handler(e, t) {
    var {
      parser: a
    } = e, r = t[0];
    return {
      type: "overline",
      mode: a.mode,
      body: r
    };
  },
  htmlBuilder(e, t) {
    var a = Ce(e.body, t.havingCrampedStyle()), r = B.makeLineSpan("overline-line", t), n = t.fontMetrics().defaultRuleThickness, s = B.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: a
      }, {
        type: "kern",
        size: 3 * n
      }, {
        type: "elem",
        elem: r
      }, {
        type: "kern",
        size: n
      }]
    }, t);
    return B.makeSpan(["mord", "overline"], [s], t);
  },
  mathmlBuilder(e, t) {
    var a = new W.MathNode("mo", [new W.TextNode("")]);
    a.setAttribute("stretchy", "true");
    var r = new W.MathNode("mover", [Le(e.body, t), a]);
    return r.setAttribute("accent", "true"), r;
  }
});
ne({
  type: "phantom",
  names: ["\\phantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: a
    } = e, r = t[0];
    return {
      type: "phantom",
      mode: a.mode,
      body: Qe(r)
    };
  },
  htmlBuilder: (e, t) => {
    var a = nt(e.body, t.withPhantom(), !1);
    return B.makeFragment(a);
  },
  mathmlBuilder: (e, t) => {
    var a = Tt(e.body, t);
    return new W.MathNode("mphantom", a);
  }
});
ne({
  type: "hphantom",
  names: ["\\hphantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: a
    } = e, r = t[0];
    return {
      type: "hphantom",
      mode: a.mode,
      body: r
    };
  },
  htmlBuilder: (e, t) => {
    var a = B.makeSpan([], [Ce(e.body, t.withPhantom())]);
    if (a.height = 0, a.depth = 0, a.children)
      for (var r = 0; r < a.children.length; r++)
        a.children[r].height = 0, a.children[r].depth = 0;
    return a = B.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: a
      }]
    }, t), B.makeSpan(["mord"], [a], t);
  },
  mathmlBuilder: (e, t) => {
    var a = Tt(Qe(e.body), t), r = new W.MathNode("mphantom", a), n = new W.MathNode("mpadded", [r]);
    return n.setAttribute("height", "0px"), n.setAttribute("depth", "0px"), n;
  }
});
ne({
  type: "vphantom",
  names: ["\\vphantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: a
    } = e, r = t[0];
    return {
      type: "vphantom",
      mode: a.mode,
      body: r
    };
  },
  htmlBuilder: (e, t) => {
    var a = B.makeSpan(["inner"], [Ce(e.body, t.withPhantom())]), r = B.makeSpan(["fix"], []);
    return B.makeSpan(["mord", "rlap"], [a, r], t);
  },
  mathmlBuilder: (e, t) => {
    var a = Tt(Qe(e.body), t), r = new W.MathNode("mphantom", a), n = new W.MathNode("mpadded", [r]);
    return n.setAttribute("width", "0px"), n;
  }
});
ne({
  type: "raisebox",
  names: ["\\raisebox"],
  props: {
    numArgs: 2,
    argTypes: ["size", "hbox"],
    allowedInText: !0
  },
  handler(e, t) {
    var {
      parser: a
    } = e, r = Te(t[0], "size").value, n = t[1];
    return {
      type: "raisebox",
      mode: a.mode,
      dy: r,
      body: n
    };
  },
  htmlBuilder(e, t) {
    var a = Ce(e.body, t), r = Ge(e.dy, t);
    return B.makeVList({
      positionType: "shift",
      positionData: -r,
      children: [{
        type: "elem",
        elem: a
      }]
    }, t);
  },
  mathmlBuilder(e, t) {
    var a = new W.MathNode("mpadded", [Le(e.body, t)]), r = e.dy.number + e.dy.unit;
    return a.setAttribute("voffset", r), a;
  }
});
ne({
  type: "internal",
  names: ["\\relax"],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler(e) {
    var {
      parser: t
    } = e;
    return {
      type: "internal",
      mode: t.mode
    };
  }
});
ne({
  type: "rule",
  names: ["\\rule"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    argTypes: ["size", "size", "size"]
  },
  handler(e, t, a) {
    var {
      parser: r
    } = e, n = a[0], s = Te(t[0], "size"), i = Te(t[1], "size");
    return {
      type: "rule",
      mode: r.mode,
      shift: n && Te(n, "size").value,
      width: s.value,
      height: i.value
    };
  },
  htmlBuilder(e, t) {
    var a = B.makeSpan(["mord", "rule"], [], t), r = Ge(e.width, t), n = Ge(e.height, t), s = e.shift ? Ge(e.shift, t) : 0;
    return a.style.borderRightWidth = ee(r), a.style.borderTopWidth = ee(n), a.style.bottom = ee(s), a.width = r, a.height = n + s, a.depth = -s, a.maxFontSize = n * 1.125 * t.sizeMultiplier, a;
  },
  mathmlBuilder(e, t) {
    var a = Ge(e.width, t), r = Ge(e.height, t), n = e.shift ? Ge(e.shift, t) : 0, s = t.color && t.getColor() || "black", i = new W.MathNode("mspace");
    i.setAttribute("mathbackground", s), i.setAttribute("width", ee(a)), i.setAttribute("height", ee(r));
    var o = new W.MathNode("mpadded", [i]);
    return n >= 0 ? o.setAttribute("height", ee(n)) : (o.setAttribute("height", ee(n)), o.setAttribute("depth", ee(-n))), o.setAttribute("voffset", ee(n)), o;
  }
});
function p0(e, t, a) {
  for (var r = nt(e, t, !1), n = t.sizeMultiplier / a.sizeMultiplier, s = 0; s < r.length; s++) {
    var i = r[s].classes.indexOf("sizing");
    i < 0 ? Array.prototype.push.apply(r[s].classes, t.sizingClasses(a)) : r[s].classes[i + 1] === "reset-size" + t.size && (r[s].classes[i + 1] = "reset-size" + a.size), r[s].height *= n, r[s].depth *= n;
  }
  return B.makeFragment(r);
}
var Rc = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"], G_ = (e, t) => {
  var a = t.havingSize(e.size);
  return p0(e.body, a, t);
};
ne({
  type: "sizing",
  names: Rc,
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      breakOnTokenText: a,
      funcName: r,
      parser: n
    } = e, s = n.parseExpression(!1, a);
    return {
      type: "sizing",
      mode: n.mode,
      // Figure out what size to use based on the list of functions above
      size: Rc.indexOf(r) + 1,
      body: s
    };
  },
  htmlBuilder: G_,
  mathmlBuilder: (e, t) => {
    var a = t.havingSize(e.size), r = Tt(e.body, a), n = new W.MathNode("mstyle", r);
    return n.setAttribute("mathsize", ee(a.sizeMultiplier)), n;
  }
});
ne({
  type: "smash",
  names: ["\\smash"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    allowedInText: !0
  },
  handler: (e, t, a) => {
    var {
      parser: r
    } = e, n = !1, s = !1, i = a[0] && Te(a[0], "ordgroup");
    if (i)
      for (var o = "", c = 0; c < i.body.length; ++c) {
        var u = i.body[c];
        if (o = u.text, o === "t")
          n = !0;
        else if (o === "b")
          s = !0;
        else {
          n = !1, s = !1;
          break;
        }
      }
    else
      n = !0, s = !0;
    var d = t[0];
    return {
      type: "smash",
      mode: r.mode,
      body: d,
      smashHeight: n,
      smashDepth: s
    };
  },
  htmlBuilder: (e, t) => {
    var a = B.makeSpan([], [Ce(e.body, t)]);
    if (!e.smashHeight && !e.smashDepth)
      return a;
    if (e.smashHeight && (a.height = 0, a.children))
      for (var r = 0; r < a.children.length; r++)
        a.children[r].height = 0;
    if (e.smashDepth && (a.depth = 0, a.children))
      for (var n = 0; n < a.children.length; n++)
        a.children[n].depth = 0;
    var s = B.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: a
      }]
    }, t);
    return B.makeSpan(["mord"], [s], t);
  },
  mathmlBuilder: (e, t) => {
    var a = new W.MathNode("mpadded", [Le(e.body, t)]);
    return e.smashHeight && a.setAttribute("height", "0px"), e.smashDepth && a.setAttribute("depth", "0px"), a;
  }
});
ne({
  type: "sqrt",
  names: ["\\sqrt"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(e, t, a) {
    var {
      parser: r
    } = e, n = a[0], s = t[0];
    return {
      type: "sqrt",
      mode: r.mode,
      body: s,
      index: n
    };
  },
  htmlBuilder(e, t) {
    var a = Ce(e.body, t.havingCrampedStyle());
    a.height === 0 && (a.height = t.fontMetrics().xHeight), a = B.wrapFragment(a, t);
    var r = t.fontMetrics(), n = r.defaultRuleThickness, s = n;
    t.style.id < ge.TEXT.id && (s = t.fontMetrics().xHeight);
    var i = n + s / 4, o = a.height + a.depth + i + n, {
      span: c,
      ruleWidth: u,
      advanceWidth: d
    } = ma.sqrtImage(o, t), m = c.height - u;
    m > a.height + a.depth + i && (i = (i + m - a.height - a.depth) / 2);
    var h = c.height - a.height - i - u;
    a.style.paddingLeft = ee(d);
    var y = B.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: a,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: -(a.height + h)
      }, {
        type: "elem",
        elem: c
      }, {
        type: "kern",
        size: u
      }]
    }, t);
    if (e.index) {
      var w = t.havingStyle(ge.SCRIPTSCRIPT), v = Ce(e.index, w, t), F = 0.6 * (y.height - y.depth), z = B.makeVList({
        positionType: "shift",
        positionData: -F,
        children: [{
          type: "elem",
          elem: v
        }]
      }, t), C = B.makeSpan(["root"], [z]);
      return B.makeSpan(["mord", "sqrt"], [C, y], t);
    } else
      return B.makeSpan(["mord", "sqrt"], [y], t);
  },
  mathmlBuilder(e, t) {
    var {
      body: a,
      index: r
    } = e;
    return r ? new W.MathNode("mroot", [Le(a, t), Le(r, t)]) : new W.MathNode("msqrt", [Le(a, t)]);
  }
});
var Fc = {
  display: ge.DISPLAY,
  text: ge.TEXT,
  script: ge.SCRIPT,
  scriptscript: ge.SCRIPTSCRIPT
};
ne({
  type: "styling",
  names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(e, t) {
    var {
      breakOnTokenText: a,
      funcName: r,
      parser: n
    } = e, s = n.parseExpression(!0, a), i = r.slice(1, r.length - 5);
    return {
      type: "styling",
      mode: n.mode,
      // Figure out what style to use by pulling out the style from
      // the function name
      style: i,
      body: s
    };
  },
  htmlBuilder(e, t) {
    var a = Fc[e.style], r = t.havingStyle(a).withFont("");
    return p0(e.body, r, t);
  },
  mathmlBuilder(e, t) {
    var a = Fc[e.style], r = t.havingStyle(a), n = Tt(e.body, r), s = new W.MathNode("mstyle", n), i = {
      display: ["0", "true"],
      text: ["0", "false"],
      script: ["1", "false"],
      scriptscript: ["2", "false"]
    }, o = i[e.style];
    return s.setAttribute("scriptlevel", o[0]), s.setAttribute("displaystyle", o[1]), s;
  }
});
var W_ = function(t, a) {
  var r = t.base;
  if (r)
    if (r.type === "op") {
      var n = r.limits && (a.style.size === ge.DISPLAY.size || r.alwaysHandleSupSub);
      return n ? fr : null;
    } else if (r.type === "operatorname") {
      var s = r.alwaysHandleSupSub && (a.style.size === ge.DISPLAY.size || r.limits);
      return s ? m0 : null;
    } else {
      if (r.type === "accent")
        return me.isCharacterBox(r.base) ? qi : null;
      if (r.type === "horizBrace") {
        var i = !t.sub;
        return i === r.isOver ? f0 : null;
      } else
        return null;
    }
  else return null;
};
Wa({
  type: "supsub",
  htmlBuilder(e, t) {
    var a = W_(e, t);
    if (a)
      return a(e, t);
    var {
      base: r,
      sup: n,
      sub: s
    } = e, i = Ce(r, t), o, c, u = t.fontMetrics(), d = 0, m = 0, h = r && me.isCharacterBox(r);
    if (n) {
      var y = t.havingStyle(t.style.sup());
      o = Ce(n, y, t), h || (d = i.height - y.fontMetrics().supDrop * y.sizeMultiplier / t.sizeMultiplier);
    }
    if (s) {
      var w = t.havingStyle(t.style.sub());
      c = Ce(s, w, t), h || (m = i.depth + w.fontMetrics().subDrop * w.sizeMultiplier / t.sizeMultiplier);
    }
    var v;
    t.style === ge.DISPLAY ? v = u.sup1 : t.style.cramped ? v = u.sup3 : v = u.sup2;
    var F = t.sizeMultiplier, z = ee(0.5 / u.ptPerEm / F), C = null;
    if (c) {
      var U = e.base && e.base.type === "op" && e.base.name && (e.base.name === "\\oiint" || e.base.name === "\\oiiint");
      (i instanceof Ht || U) && (C = ee(-i.italic));
    }
    var $;
    if (o && c) {
      d = Math.max(d, v, o.depth + 0.25 * u.xHeight), m = Math.max(m, u.sub2);
      var O = u.defaultRuleThickness, p = 4 * O;
      if (d - o.depth - (c.height - m) < p) {
        m = p - (d - o.depth) + c.height;
        var M = 0.8 * u.xHeight - (d - o.depth);
        M > 0 && (d += M, m -= M);
      }
      var te = [{
        type: "elem",
        elem: c,
        shift: m,
        marginRight: z,
        marginLeft: C
      }, {
        type: "elem",
        elem: o,
        shift: -d,
        marginRight: z
      }];
      $ = B.makeVList({
        positionType: "individualShift",
        children: te
      }, t);
    } else if (c) {
      m = Math.max(m, u.sub1, c.height - 0.8 * u.xHeight);
      var Z = [{
        type: "elem",
        elem: c,
        marginLeft: C,
        marginRight: z
      }];
      $ = B.makeVList({
        positionType: "shift",
        positionData: m,
        children: Z
      }, t);
    } else if (o)
      d = Math.max(d, v, o.depth + 0.25 * u.xHeight), $ = B.makeVList({
        positionType: "shift",
        positionData: -d,
        children: [{
          type: "elem",
          elem: o,
          marginRight: z
        }]
      }, t);
    else
      throw new Error("supsub must have either sup or sub.");
    var P = si(i, "right") || "mord";
    return B.makeSpan([P], [i, B.makeSpan(["msupsub"], [$])], t);
  },
  mathmlBuilder(e, t) {
    var a = !1, r, n;
    e.base && e.base.type === "horizBrace" && (n = !!e.sup, n === e.base.isOver && (a = !0, r = e.base.isOver)), e.base && (e.base.type === "op" || e.base.type === "operatorname") && (e.base.parentIsSupSub = !0);
    var s = [Le(e.base, t)];
    e.sub && s.push(Le(e.sub, t)), e.sup && s.push(Le(e.sup, t));
    var i;
    if (a)
      i = r ? "mover" : "munder";
    else if (e.sub)
      if (e.sup) {
        var u = e.base;
        u && u.type === "op" && u.limits && t.style === ge.DISPLAY || u && u.type === "operatorname" && u.alwaysHandleSupSub && (t.style === ge.DISPLAY || u.limits) ? i = "munderover" : i = "msubsup";
      } else {
        var c = e.base;
        c && c.type === "op" && c.limits && (t.style === ge.DISPLAY || c.alwaysHandleSupSub) || c && c.type === "operatorname" && c.alwaysHandleSupSub && (c.limits || t.style === ge.DISPLAY) ? i = "munder" : i = "msub";
      }
    else {
      var o = e.base;
      o && o.type === "op" && o.limits && (t.style === ge.DISPLAY || o.alwaysHandleSupSub) || o && o.type === "operatorname" && o.alwaysHandleSupSub && (o.limits || t.style === ge.DISPLAY) ? i = "mover" : i = "msup";
    }
    return new W.MathNode(i, s);
  }
});
Wa({
  type: "atom",
  htmlBuilder(e, t) {
    return B.mathsym(e.text, e.mode, t, ["m" + e.family]);
  },
  mathmlBuilder(e, t) {
    var a = new W.MathNode("mo", [Ut(e.text, e.mode)]);
    if (e.family === "bin") {
      var r = Ui(e, t);
      r === "bold-italic" && a.setAttribute("mathvariant", r);
    } else e.family === "punct" ? a.setAttribute("separator", "true") : (e.family === "open" || e.family === "close") && a.setAttribute("stretchy", "false");
    return a;
  }
});
var g0 = {
  mi: "italic",
  mn: "normal",
  mtext: "normal"
};
Wa({
  type: "mathord",
  htmlBuilder(e, t) {
    return B.makeOrd(e, t, "mathord");
  },
  mathmlBuilder(e, t) {
    var a = new W.MathNode("mi", [Ut(e.text, e.mode, t)]), r = Ui(e, t) || "italic";
    return r !== g0[a.type] && a.setAttribute("mathvariant", r), a;
  }
});
Wa({
  type: "textord",
  htmlBuilder(e, t) {
    return B.makeOrd(e, t, "textord");
  },
  mathmlBuilder(e, t) {
    var a = Ut(e.text, e.mode, t), r = Ui(e, t) || "normal", n;
    return e.mode === "text" ? n = new W.MathNode("mtext", [a]) : /[0-9]/.test(e.text) ? n = new W.MathNode("mn", [a]) : e.text === "\\prime" ? n = new W.MathNode("mo", [a]) : n = new W.MathNode("mi", [a]), r !== g0[n.type] && n.setAttribute("mathvariant", r), n;
  }
});
var Ps = {
  "\\nobreak": "nobreak",
  "\\allowbreak": "allowbreak"
}, Hs = {
  " ": {},
  "\\ ": {},
  "~": {
    className: "nobreak"
  },
  "\\space": {},
  "\\nobreakspace": {
    className: "nobreak"
  }
};
Wa({
  type: "spacing",
  htmlBuilder(e, t) {
    if (Hs.hasOwnProperty(e.text)) {
      var a = Hs[e.text].className || "";
      if (e.mode === "text") {
        var r = B.makeOrd(e, t, "textord");
        return r.classes.push(a), r;
      } else
        return B.makeSpan(["mspace", a], [B.mathsym(e.text, e.mode, t)], t);
    } else {
      if (Ps.hasOwnProperty(e.text))
        return B.makeSpan(["mspace", Ps[e.text]], [], t);
      throw new Q('Unknown type of space "' + e.text + '"');
    }
  },
  mathmlBuilder(e, t) {
    var a;
    if (Hs.hasOwnProperty(e.text))
      a = new W.MathNode("mtext", [new W.TextNode("")]);
    else {
      if (Ps.hasOwnProperty(e.text))
        return new W.MathNode("mspace");
      throw new Q('Unknown type of space "' + e.text + '"');
    }
    return a;
  }
});
var Oc = () => {
  var e = new W.MathNode("mtd", []);
  return e.setAttribute("width", "50%"), e;
};
Wa({
  type: "tag",
  mathmlBuilder(e, t) {
    var a = new W.MathNode("mtable", [new W.MathNode("mtr", [Oc(), new W.MathNode("mtd", [za(e.body, t)]), Oc(), new W.MathNode("mtd", [za(e.tag, t)])])]);
    return a.setAttribute("width", "100%"), a;
  }
});
var Lc = {
  "\\text": void 0,
  "\\textrm": "textrm",
  "\\textsf": "textsf",
  "\\texttt": "texttt",
  "\\textnormal": "textrm"
}, Mc = {
  "\\textbf": "textbf",
  "\\textmd": "textmd"
}, $_ = {
  "\\textit": "textit",
  "\\textup": "textup"
}, Bc = (e, t) => {
  var a = e.font;
  if (a) {
    if (Lc[a])
      return t.withTextFontFamily(Lc[a]);
    if (Mc[a])
      return t.withTextFontWeight(Mc[a]);
    if (a === "\\emph")
      return t.fontShape === "textit" ? t.withTextFontShape("textup") : t.withTextFontShape("textit");
  } else return t;
  return t.withTextFontShape($_[a]);
};
ne({
  type: "text",
  names: [
    // Font families
    "\\text",
    "\\textrm",
    "\\textsf",
    "\\texttt",
    "\\textnormal",
    // Font weights
    "\\textbf",
    "\\textmd",
    // Font Shapes
    "\\textit",
    "\\textup",
    "\\emph"
  ],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInArgument: !0,
    allowedInText: !0
  },
  handler(e, t) {
    var {
      parser: a,
      funcName: r
    } = e, n = t[0];
    return {
      type: "text",
      mode: a.mode,
      body: Qe(n),
      font: r
    };
  },
  htmlBuilder(e, t) {
    var a = Bc(e, t), r = nt(e.body, a, !0);
    return B.makeSpan(["mord", "text"], r, a);
  },
  mathmlBuilder(e, t) {
    var a = Bc(e, t);
    return za(e.body, a);
  }
});
ne({
  type: "underline",
  names: ["\\underline"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(e, t) {
    var {
      parser: a
    } = e;
    return {
      type: "underline",
      mode: a.mode,
      body: t[0]
    };
  },
  htmlBuilder(e, t) {
    var a = Ce(e.body, t), r = B.makeLineSpan("underline-line", t), n = t.fontMetrics().defaultRuleThickness, s = B.makeVList({
      positionType: "top",
      positionData: a.height,
      children: [{
        type: "kern",
        size: n
      }, {
        type: "elem",
        elem: r
      }, {
        type: "kern",
        size: 3 * n
      }, {
        type: "elem",
        elem: a
      }]
    }, t);
    return B.makeSpan(["mord", "underline"], [s], t);
  },
  mathmlBuilder(e, t) {
    var a = new W.MathNode("mo", [new W.TextNode("")]);
    a.setAttribute("stretchy", "true");
    var r = new W.MathNode("munder", [Le(e.body, t), a]);
    return r.setAttribute("accentunder", "true"), r;
  }
});
ne({
  type: "vcenter",
  names: ["\\vcenter"],
  props: {
    numArgs: 1,
    argTypes: ["original"],
    // In LaTeX, \vcenter can act only on a box.
    allowedInText: !1
  },
  handler(e, t) {
    var {
      parser: a
    } = e;
    return {
      type: "vcenter",
      mode: a.mode,
      body: t[0]
    };
  },
  htmlBuilder(e, t) {
    var a = Ce(e.body, t), r = t.fontMetrics().axisHeight, n = 0.5 * (a.height - r - (a.depth + r));
    return B.makeVList({
      positionType: "shift",
      positionData: n,
      children: [{
        type: "elem",
        elem: a
      }]
    }, t);
  },
  mathmlBuilder(e, t) {
    return new W.MathNode("mpadded", [Le(e.body, t)], ["vcenter"]);
  }
});
ne({
  type: "verb",
  names: ["\\verb"],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler(e, t, a) {
    throw new Q("\\verb ended by end of line instead of matching delimiter");
  },
  htmlBuilder(e, t) {
    for (var a = Pc(e), r = [], n = t.havingStyle(t.style.text()), s = 0; s < a.length; s++) {
      var i = a[s];
      i === "~" && (i = "\\textasciitilde"), r.push(B.makeSymbol(i, "Typewriter-Regular", e.mode, n, ["mord", "texttt"]));
    }
    return B.makeSpan(["mord", "text"].concat(n.sizingClasses(t)), B.tryCombineChars(r), n);
  },
  mathmlBuilder(e, t) {
    var a = new W.TextNode(Pc(e)), r = new W.MathNode("mtext", [a]);
    return r.setAttribute("mathvariant", "monospace"), r;
  }
});
var Pc = (e) => e.body.replace(/ /g, e.star ? "" : ""), xa = Pu, y0 = `[ \r
	]`, X_ = "\\\\[a-zA-Z@]+", Q_ = "\\\\[^\uD800-\uDFFF]", K_ = "(" + X_ + ")" + y0 + "*", J_ = `\\\\(
|[ \r	]+
?)[ \r	]*`, li = "[-]", Z_ = new RegExp(li + "+$"), e2 = "(" + y0 + "+)|" + // whitespace
(J_ + "|") + // \whitespace
"([!-\\[\\]---]" + // single codepoint
(li + "*") + // ...plus accents
"|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
(li + "*") + // ...plus accents
"|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + // \verb unstarred
("|" + K_) + // \macroName + spaces
("|" + Q_ + ")");
class Hc {
  // Category codes. The lexer only supports comment characters (14) for now.
  // MacroExpander additionally distinguishes active (13).
  constructor(t, a) {
    this.input = void 0, this.settings = void 0, this.tokenRegex = void 0, this.catcodes = void 0, this.input = t, this.settings = a, this.tokenRegex = new RegExp(e2, "g"), this.catcodes = {
      "%": 14,
      // comment character
      "~": 13
      // active character
    };
  }
  setCatcode(t, a) {
    this.catcodes[t] = a;
  }
  /**
   * This function lexes a single token.
   */
  lex() {
    var t = this.input, a = this.tokenRegex.lastIndex;
    if (a === t.length)
      return new Pt("EOF", new zt(this, a, a));
    var r = this.tokenRegex.exec(t);
    if (r === null || r.index !== a)
      throw new Q("Unexpected character: '" + t[a] + "'", new Pt(t[a], new zt(this, a, a + 1)));
    var n = r[6] || r[3] || (r[2] ? "\\ " : " ");
    if (this.catcodes[n] === 14) {
      var s = t.indexOf(`
`, this.tokenRegex.lastIndex);
      return s === -1 ? (this.tokenRegex.lastIndex = t.length, this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)")) : this.tokenRegex.lastIndex = s + 1, this.lex();
    }
    return new Pt(n, new zt(this, a, this.tokenRegex.lastIndex));
  }
}
class t2 {
  /**
   * Both arguments are optional.  The first argument is an object of
   * built-in mappings which never change.  The second argument is an object
   * of initial (global-level) mappings, which will constantly change
   * according to any global/top-level `set`s done.
   */
  constructor(t, a) {
    t === void 0 && (t = {}), a === void 0 && (a = {}), this.current = void 0, this.builtins = void 0, this.undefStack = void 0, this.current = a, this.builtins = t, this.undefStack = [];
  }
  /**
   * Start a new nested group, affecting future local `set`s.
   */
  beginGroup() {
    this.undefStack.push({});
  }
  /**
   * End current nested group, restoring values before the group began.
   */
  endGroup() {
    if (this.undefStack.length === 0)
      throw new Q("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
    var t = this.undefStack.pop();
    for (var a in t)
      t.hasOwnProperty(a) && (t[a] == null ? delete this.current[a] : this.current[a] = t[a]);
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    for (; this.undefStack.length > 0; )
      this.endGroup();
  }
  /**
   * Detect whether `name` has a definition.  Equivalent to
   * `get(name) != null`.
   */
  has(t) {
    return this.current.hasOwnProperty(t) || this.builtins.hasOwnProperty(t);
  }
  /**
   * Get the current value of a name, or `undefined` if there is no value.
   *
   * Note: Do not use `if (namespace.get(...))` to detect whether a macro
   * is defined, as the definition may be the empty string which evaluates
   * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
   * `if (namespace.has(...))`.
   */
  get(t) {
    return this.current.hasOwnProperty(t) ? this.current[t] : this.builtins[t];
  }
  /**
   * Set the current value of a name, and optionally set it globally too.
   * Local set() sets the current value and (when appropriate) adds an undo
   * operation to the undo stack.  Global set() may change the undo
   * operation at every level, so takes time linear in their number.
   * A value of undefined means to delete existing definitions.
   */
  set(t, a, r) {
    if (r === void 0 && (r = !1), r) {
      for (var n = 0; n < this.undefStack.length; n++)
        delete this.undefStack[n][t];
      this.undefStack.length > 0 && (this.undefStack[this.undefStack.length - 1][t] = a);
    } else {
      var s = this.undefStack[this.undefStack.length - 1];
      s && !s.hasOwnProperty(t) && (s[t] = this.current[t]);
    }
    a == null ? delete this.current[t] : this.current[t] = a;
  }
}
var a2 = i0;
k("\\noexpand", function(e) {
  var t = e.popToken();
  return e.isExpandable(t.text) && (t.noexpand = !0, t.treatAsRelax = !0), {
    tokens: [t],
    numArgs: 0
  };
});
k("\\expandafter", function(e) {
  var t = e.popToken();
  return e.expandOnce(!0), {
    tokens: [t],
    numArgs: 0
  };
});
k("\\@firstoftwo", function(e) {
  var t = e.consumeArgs(2);
  return {
    tokens: t[0],
    numArgs: 0
  };
});
k("\\@secondoftwo", function(e) {
  var t = e.consumeArgs(2);
  return {
    tokens: t[1],
    numArgs: 0
  };
});
k("\\@ifnextchar", function(e) {
  var t = e.consumeArgs(3);
  e.consumeSpaces();
  var a = e.future();
  return t[0].length === 1 && t[0][0].text === a.text ? {
    tokens: t[1],
    numArgs: 0
  } : {
    tokens: t[2],
    numArgs: 0
  };
});
k("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
k("\\TextOrMath", function(e) {
  var t = e.consumeArgs(2);
  return e.mode === "text" ? {
    tokens: t[0],
    numArgs: 0
  } : {
    tokens: t[1],
    numArgs: 0
  };
});
var Uc = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
};
k("\\char", function(e) {
  var t = e.popToken(), a, r = "";
  if (t.text === "'")
    a = 8, t = e.popToken();
  else if (t.text === '"')
    a = 16, t = e.popToken();
  else if (t.text === "`")
    if (t = e.popToken(), t.text[0] === "\\")
      r = t.text.charCodeAt(1);
    else {
      if (t.text === "EOF")
        throw new Q("\\char` missing argument");
      r = t.text.charCodeAt(0);
    }
  else
    a = 10;
  if (a) {
    if (r = Uc[t.text], r == null || r >= a)
      throw new Q("Invalid base-" + a + " digit " + t.text);
    for (var n; (n = Uc[e.future().text]) != null && n < a; )
      r *= a, r += n, e.popToken();
  }
  return "\\@char{" + r + "}";
});
var Ki = (e, t, a) => {
  var r = e.consumeArg().tokens;
  if (r.length !== 1)
    throw new Q("\\newcommand's first argument must be a macro name");
  var n = r[0].text, s = e.isDefined(n);
  if (s && !t)
    throw new Q("\\newcommand{" + n + "} attempting to redefine " + (n + "; use \\renewcommand"));
  if (!s && !a)
    throw new Q("\\renewcommand{" + n + "} when command " + n + " does not yet exist; use \\newcommand");
  var i = 0;
  if (r = e.consumeArg().tokens, r.length === 1 && r[0].text === "[") {
    for (var o = "", c = e.expandNextToken(); c.text !== "]" && c.text !== "EOF"; )
      o += c.text, c = e.expandNextToken();
    if (!o.match(/^\s*[0-9]+\s*$/))
      throw new Q("Invalid number of arguments: " + o);
    i = parseInt(o), r = e.consumeArg().tokens;
  }
  return e.macros.set(n, {
    tokens: r,
    numArgs: i
  }), "";
};
k("\\newcommand", (e) => Ki(e, !1, !0));
k("\\renewcommand", (e) => Ki(e, !0, !1));
k("\\providecommand", (e) => Ki(e, !0, !0));
k("\\message", (e) => {
  var t = e.consumeArgs(1)[0];
  return console.log(t.reverse().map((a) => a.text).join("")), "";
});
k("\\errmessage", (e) => {
  var t = e.consumeArgs(1)[0];
  return console.error(t.reverse().map((a) => a.text).join("")), "";
});
k("\\show", (e) => {
  var t = e.popToken(), a = t.text;
  return console.log(t, e.macros.get(a), xa[a], Pe.math[a], Pe.text[a]), "";
});
k("\\bgroup", "{");
k("\\egroup", "}");
k("~", "\\nobreakspace");
k("\\lq", "`");
k("\\rq", "'");
k("\\aa", "\\r a");
k("\\AA", "\\r A");
k("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`}");
k("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
k("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`}");
k("", "\\mathscr{B}");
k("", "\\mathscr{E}");
k("", "\\mathscr{F}");
k("", "\\mathscr{H}");
k("", "\\mathscr{I}");
k("", "\\mathscr{L}");
k("", "\\mathscr{M}");
k("", "\\mathscr{R}");
k("", "\\mathfrak{C}");
k("", "\\mathfrak{H}");
k("", "\\mathfrak{Z}");
k("\\Bbbk", "\\Bbb{k}");
k("", "\\cdotp");
k("\\llap", "\\mathllap{\\textrm{#1}}");
k("\\rlap", "\\mathrlap{\\textrm{#1}}");
k("\\clap", "\\mathclap{\\textrm{#1}}");
k("\\mathstrut", "\\vphantom{(}");
k("\\underbar", "\\underline{\\text{#1}}");
k("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
k("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`}}");
k("\\ne", "\\neq");
k("", "\\neq");
k("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`}}");
k("", "\\notin");
k("", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`}}");
k("", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`}}");
k("", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`}}");
k("", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`}}");
k("", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`}}");
k("", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`}}");
k("", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`}}");
k("", "\\perp");
k("", "\\mathclose{!\\mkern-0.8mu!}");
k("", "\\notni");
k("", "\\ulcorner");
k("", "\\urcorner");
k("", "\\llcorner");
k("", "\\lrcorner");
k("", "\\copyright");
k("", "\\textregistered");
k("", "\\textregistered");
k("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
k("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
k("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
k("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
k("\\vdots", "\\mathord{\\varvdots\\rule{0pt}{15pt}}");
k("", "\\vdots");
k("\\varGamma", "\\mathit{\\Gamma}");
k("\\varDelta", "\\mathit{\\Delta}");
k("\\varTheta", "\\mathit{\\Theta}");
k("\\varLambda", "\\mathit{\\Lambda}");
k("\\varXi", "\\mathit{\\Xi}");
k("\\varPi", "\\mathit{\\Pi}");
k("\\varSigma", "\\mathit{\\Sigma}");
k("\\varUpsilon", "\\mathit{\\Upsilon}");
k("\\varPhi", "\\mathit{\\Phi}");
k("\\varPsi", "\\mathit{\\Psi}");
k("\\varOmega", "\\mathit{\\Omega}");
k("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
k("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax");
k("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
k("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
k("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
k("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
var jc = {
  ",": "\\dotsc",
  "\\not": "\\dotsb",
  // \keybin@ checks for the following:
  "+": "\\dotsb",
  "=": "\\dotsb",
  "<": "\\dotsb",
  ">": "\\dotsb",
  "-": "\\dotsb",
  "*": "\\dotsb",
  ":": "\\dotsb",
  // Symbols whose definition starts with \DOTSB:
  "\\DOTSB": "\\dotsb",
  "\\coprod": "\\dotsb",
  "\\bigvee": "\\dotsb",
  "\\bigwedge": "\\dotsb",
  "\\biguplus": "\\dotsb",
  "\\bigcap": "\\dotsb",
  "\\bigcup": "\\dotsb",
  "\\prod": "\\dotsb",
  "\\sum": "\\dotsb",
  "\\bigotimes": "\\dotsb",
  "\\bigoplus": "\\dotsb",
  "\\bigodot": "\\dotsb",
  "\\bigsqcup": "\\dotsb",
  "\\And": "\\dotsb",
  "\\longrightarrow": "\\dotsb",
  "\\Longrightarrow": "\\dotsb",
  "\\longleftarrow": "\\dotsb",
  "\\Longleftarrow": "\\dotsb",
  "\\longleftrightarrow": "\\dotsb",
  "\\Longleftrightarrow": "\\dotsb",
  "\\mapsto": "\\dotsb",
  "\\longmapsto": "\\dotsb",
  "\\hookrightarrow": "\\dotsb",
  "\\doteq": "\\dotsb",
  // Symbols whose definition starts with \mathbin:
  "\\mathbin": "\\dotsb",
  // Symbols whose definition starts with \mathrel:
  "\\mathrel": "\\dotsb",
  "\\relbar": "\\dotsb",
  "\\Relbar": "\\dotsb",
  "\\xrightarrow": "\\dotsb",
  "\\xleftarrow": "\\dotsb",
  // Symbols whose definition starts with \DOTSI:
  "\\DOTSI": "\\dotsi",
  "\\int": "\\dotsi",
  "\\oint": "\\dotsi",
  "\\iint": "\\dotsi",
  "\\iiint": "\\dotsi",
  "\\iiiint": "\\dotsi",
  "\\idotsint": "\\dotsi",
  // Symbols whose definition starts with \DOTSX:
  "\\DOTSX": "\\dotsx"
};
k("\\dots", function(e) {
  var t = "\\dotso", a = e.expandAfterFuture().text;
  return a in jc ? t = jc[a] : (a.slice(0, 4) === "\\not" || a in Pe.math && me.contains(["bin", "rel"], Pe.math[a].group)) && (t = "\\dotsb"), t;
});
var Ji = {
  // \rightdelim@ checks for the following:
  ")": !0,
  "]": !0,
  "\\rbrack": !0,
  "\\}": !0,
  "\\rbrace": !0,
  "\\rangle": !0,
  "\\rceil": !0,
  "\\rfloor": !0,
  "\\rgroup": !0,
  "\\rmoustache": !0,
  "\\right": !0,
  "\\bigr": !0,
  "\\biggr": !0,
  "\\Bigr": !0,
  "\\Biggr": !0,
  // \extra@ also tests for the following:
  $: !0,
  // \extrap@ checks for the following:
  ";": !0,
  ".": !0,
  ",": !0
};
k("\\dotso", function(e) {
  var t = e.future().text;
  return t in Ji ? "\\ldots\\," : "\\ldots";
});
k("\\dotsc", function(e) {
  var t = e.future().text;
  return t in Ji && t !== "," ? "\\ldots\\," : "\\ldots";
});
k("\\cdots", function(e) {
  var t = e.future().text;
  return t in Ji ? "\\@cdots\\," : "\\@cdots";
});
k("\\dotsb", "\\cdots");
k("\\dotsm", "\\cdots");
k("\\dotsi", "\\!\\cdots");
k("\\dotsx", "\\ldots\\,");
k("\\DOTSI", "\\relax");
k("\\DOTSB", "\\relax");
k("\\DOTSX", "\\relax");
k("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
k("\\,", "\\tmspace+{3mu}{.1667em}");
k("\\thinspace", "\\,");
k("\\>", "\\mskip{4mu}");
k("\\:", "\\tmspace+{4mu}{.2222em}");
k("\\medspace", "\\:");
k("\\;", "\\tmspace+{5mu}{.2777em}");
k("\\thickspace", "\\;");
k("\\!", "\\tmspace-{3mu}{.1667em}");
k("\\negthinspace", "\\!");
k("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
k("\\negthickspace", "\\tmspace-{5mu}{.277em}");
k("\\enspace", "\\kern.5em ");
k("\\enskip", "\\hskip.5em\\relax");
k("\\quad", "\\hskip1em\\relax");
k("\\qquad", "\\hskip2em\\relax");
k("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
k("\\tag@paren", "\\tag@literal{({#1})}");
k("\\tag@literal", (e) => {
  if (e.macros.get("\\df@tag"))
    throw new Q("Multiple \\tag");
  return "\\gdef\\df@tag{\\text{#1}}";
});
k("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
k("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
k("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
k("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
k("\\newline", "\\\\\\relax");
k("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
var _0 = ee(Jt["Main-Regular"][84][1] - 0.7 * Jt["Main-Regular"][65][1]);
k("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + _0 + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
k("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + _0 + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
k("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
k("\\@hspace", "\\hskip #1\\relax");
k("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
k("\\ordinarycolon", ":");
k("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
k("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
k("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
k("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
k("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
k("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
k("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
k("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
k("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
k("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
k("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
k("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
k("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
k("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
k("", "\\dblcolon");
k("", "\\eqcolon");
k("", "\\coloneqq");
k("", "\\eqqcolon");
k("", "\\Coloneqq");
k("\\ratio", "\\vcentcolon");
k("\\coloncolon", "\\dblcolon");
k("\\colonequals", "\\coloneqq");
k("\\coloncolonequals", "\\Coloneqq");
k("\\equalscolon", "\\eqqcolon");
k("\\equalscoloncolon", "\\Eqqcolon");
k("\\colonminus", "\\coloneq");
k("\\coloncolonminus", "\\Coloneq");
k("\\minuscolon", "\\eqcolon");
k("\\minuscoloncolon", "\\Eqcolon");
k("\\coloncolonapprox", "\\Colonapprox");
k("\\coloncolonsim", "\\Colonsim");
k("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
k("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
k("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
k("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
k("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`}}");
k("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
k("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
k("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
k("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
k("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
k("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
k("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
k("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
k("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{}");
k("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{}");
k("\\ngeqq", "\\html@mathml{\\@ngeqq}{}");
k("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{}");
k("\\nleqq", "\\html@mathml{\\@nleqq}{}");
k("\\nleqslant", "\\html@mathml{\\@nleqslant}{}");
k("\\nshortmid", "\\html@mathml{\\@nshortmid}{}");
k("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{}");
k("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{}");
k("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{}");
k("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{}");
k("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{}");
k("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{}");
k("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{}");
k("\\imath", "\\html@mathml{\\@imath}{}");
k("\\jmath", "\\html@mathml{\\@jmath}{}");
k("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`}}");
k("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`}}");
k("", "\\llbracket");
k("", "\\rrbracket");
k("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`}}");
k("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`}}");
k("", "\\lBrace");
k("", "\\rBrace");
k("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`}}");
k("", "\\minuso");
k("\\darr", "\\downarrow");
k("\\dArr", "\\Downarrow");
k("\\Darr", "\\Downarrow");
k("\\lang", "\\langle");
k("\\rang", "\\rangle");
k("\\uarr", "\\uparrow");
k("\\uArr", "\\Uparrow");
k("\\Uarr", "\\Uparrow");
k("\\N", "\\mathbb{N}");
k("\\R", "\\mathbb{R}");
k("\\Z", "\\mathbb{Z}");
k("\\alef", "\\aleph");
k("\\alefsym", "\\aleph");
k("\\Alpha", "\\mathrm{A}");
k("\\Beta", "\\mathrm{B}");
k("\\bull", "\\bullet");
k("\\Chi", "\\mathrm{X}");
k("\\clubs", "\\clubsuit");
k("\\cnums", "\\mathbb{C}");
k("\\Complex", "\\mathbb{C}");
k("\\Dagger", "\\ddagger");
k("\\diamonds", "\\diamondsuit");
k("\\empty", "\\emptyset");
k("\\Epsilon", "\\mathrm{E}");
k("\\Eta", "\\mathrm{H}");
k("\\exist", "\\exists");
k("\\harr", "\\leftrightarrow");
k("\\hArr", "\\Leftrightarrow");
k("\\Harr", "\\Leftrightarrow");
k("\\hearts", "\\heartsuit");
k("\\image", "\\Im");
k("\\infin", "\\infty");
k("\\Iota", "\\mathrm{I}");
k("\\isin", "\\in");
k("\\Kappa", "\\mathrm{K}");
k("\\larr", "\\leftarrow");
k("\\lArr", "\\Leftarrow");
k("\\Larr", "\\Leftarrow");
k("\\lrarr", "\\leftrightarrow");
k("\\lrArr", "\\Leftrightarrow");
k("\\Lrarr", "\\Leftrightarrow");
k("\\Mu", "\\mathrm{M}");
k("\\natnums", "\\mathbb{N}");
k("\\Nu", "\\mathrm{N}");
k("\\Omicron", "\\mathrm{O}");
k("\\plusmn", "\\pm");
k("\\rarr", "\\rightarrow");
k("\\rArr", "\\Rightarrow");
k("\\Rarr", "\\Rightarrow");
k("\\real", "\\Re");
k("\\reals", "\\mathbb{R}");
k("\\Reals", "\\mathbb{R}");
k("\\Rho", "\\mathrm{P}");
k("\\sdot", "\\cdot");
k("\\sect", "\\S");
k("\\spades", "\\spadesuit");
k("\\sub", "\\subset");
k("\\sube", "\\subseteq");
k("\\supe", "\\supseteq");
k("\\Tau", "\\mathrm{T}");
k("\\thetasym", "\\vartheta");
k("\\weierp", "\\wp");
k("\\Zeta", "\\mathrm{Z}");
k("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
k("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
k("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
k("\\bra", "\\mathinner{\\langle{#1}|}");
k("\\ket", "\\mathinner{|{#1}\\rangle}");
k("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
k("\\Bra", "\\left\\langle#1\\right|");
k("\\Ket", "\\left|#1\\right\\rangle");
var b0 = (e) => (t) => {
  var a = t.consumeArg().tokens, r = t.consumeArg().tokens, n = t.consumeArg().tokens, s = t.consumeArg().tokens, i = t.macros.get("|"), o = t.macros.get("\\|");
  t.macros.beginGroup();
  var c = (m) => (h) => {
    e && (h.macros.set("|", i), n.length && h.macros.set("\\|", o));
    var y = m;
    if (!m && n.length) {
      var w = h.future();
      w.text === "|" && (h.popToken(), y = !0);
    }
    return {
      tokens: y ? n : r,
      numArgs: 0
    };
  };
  t.macros.set("|", c(!1)), n.length && t.macros.set("\\|", c(!0));
  var u = t.consumeArg().tokens, d = t.expandTokens([
    ...s,
    ...u,
    ...a
    // reversed
  ]);
  return t.macros.endGroup(), {
    tokens: d.reverse(),
    numArgs: 0
  };
};
k("\\bra@ket", b0(!1));
k("\\bra@set", b0(!0));
k("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");
k("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");
k("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}");
k("\\angln", "{\\angl n}");
k("\\blue", "\\textcolor{##6495ed}{#1}");
k("\\orange", "\\textcolor{##ffa500}{#1}");
k("\\pink", "\\textcolor{##ff00af}{#1}");
k("\\red", "\\textcolor{##df0030}{#1}");
k("\\green", "\\textcolor{##28ae7b}{#1}");
k("\\gray", "\\textcolor{gray}{#1}");
k("\\purple", "\\textcolor{##9d38bd}{#1}");
k("\\blueA", "\\textcolor{##ccfaff}{#1}");
k("\\blueB", "\\textcolor{##80f6ff}{#1}");
k("\\blueC", "\\textcolor{##63d9ea}{#1}");
k("\\blueD", "\\textcolor{##11accd}{#1}");
k("\\blueE", "\\textcolor{##0c7f99}{#1}");
k("\\tealA", "\\textcolor{##94fff5}{#1}");
k("\\tealB", "\\textcolor{##26edd5}{#1}");
k("\\tealC", "\\textcolor{##01d1c1}{#1}");
k("\\tealD", "\\textcolor{##01a995}{#1}");
k("\\tealE", "\\textcolor{##208170}{#1}");
k("\\greenA", "\\textcolor{##b6ffb0}{#1}");
k("\\greenB", "\\textcolor{##8af281}{#1}");
k("\\greenC", "\\textcolor{##74cf70}{#1}");
k("\\greenD", "\\textcolor{##1fab54}{#1}");
k("\\greenE", "\\textcolor{##0d923f}{#1}");
k("\\goldA", "\\textcolor{##ffd0a9}{#1}");
k("\\goldB", "\\textcolor{##ffbb71}{#1}");
k("\\goldC", "\\textcolor{##ff9c39}{#1}");
k("\\goldD", "\\textcolor{##e07d10}{#1}");
k("\\goldE", "\\textcolor{##a75a05}{#1}");
k("\\redA", "\\textcolor{##fca9a9}{#1}");
k("\\redB", "\\textcolor{##ff8482}{#1}");
k("\\redC", "\\textcolor{##f9685d}{#1}");
k("\\redD", "\\textcolor{##e84d39}{#1}");
k("\\redE", "\\textcolor{##bc2612}{#1}");
k("\\maroonA", "\\textcolor{##ffbde0}{#1}");
k("\\maroonB", "\\textcolor{##ff92c6}{#1}");
k("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
k("\\maroonD", "\\textcolor{##ca337c}{#1}");
k("\\maroonE", "\\textcolor{##9e034e}{#1}");
k("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
k("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
k("\\purpleC", "\\textcolor{##aa87ff}{#1}");
k("\\purpleD", "\\textcolor{##7854ab}{#1}");
k("\\purpleE", "\\textcolor{##543b78}{#1}");
k("\\mintA", "\\textcolor{##f5f9e8}{#1}");
k("\\mintB", "\\textcolor{##edf2df}{#1}");
k("\\mintC", "\\textcolor{##e0e5cc}{#1}");
k("\\grayA", "\\textcolor{##f6f7f7}{#1}");
k("\\grayB", "\\textcolor{##f0f1f2}{#1}");
k("\\grayC", "\\textcolor{##e3e5e6}{#1}");
k("\\grayD", "\\textcolor{##d6d8da}{#1}");
k("\\grayE", "\\textcolor{##babec2}{#1}");
k("\\grayF", "\\textcolor{##888d93}{#1}");
k("\\grayG", "\\textcolor{##626569}{#1}");
k("\\grayH", "\\textcolor{##3b3e40}{#1}");
k("\\grayI", "\\textcolor{##21242c}{#1}");
k("\\kaBlue", "\\textcolor{##314453}{#1}");
k("\\kaGreen", "\\textcolor{##71B307}{#1}");
var k0 = {
  "^": !0,
  // Parser.js
  _: !0,
  // Parser.js
  "\\limits": !0,
  // Parser.js
  "\\nolimits": !0
  // Parser.js
};
class r2 {
  constructor(t, a, r) {
    this.settings = void 0, this.expansionCount = void 0, this.lexer = void 0, this.macros = void 0, this.stack = void 0, this.mode = void 0, this.settings = a, this.expansionCount = 0, this.feed(t), this.macros = new t2(a2, a.macros), this.mode = r, this.stack = [];
  }
  /**
   * Feed a new input string to the same MacroExpander
   * (with existing macros etc.).
   */
  feed(t) {
    this.lexer = new Hc(t, this.settings);
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(t) {
    this.mode = t;
  }
  /**
   * Start a new group nesting within all namespaces.
   */
  beginGroup() {
    this.macros.beginGroup();
  }
  /**
   * End current group nesting within all namespaces.
   */
  endGroup() {
    this.macros.endGroup();
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    this.macros.endGroups();
  }
  /**
   * Returns the topmost token on the stack, without expanding it.
   * Similar in behavior to TeX's `\futurelet`.
   */
  future() {
    return this.stack.length === 0 && this.pushToken(this.lexer.lex()), this.stack[this.stack.length - 1];
  }
  /**
   * Remove and return the next unexpanded token.
   */
  popToken() {
    return this.future(), this.stack.pop();
  }
  /**
   * Add a given token to the token stack.  In particular, this get be used
   * to put back a token returned from one of the other methods.
   */
  pushToken(t) {
    this.stack.push(t);
  }
  /**
   * Append an array of tokens to the token stack.
   */
  pushTokens(t) {
    this.stack.push(...t);
  }
  /**
   * Find an macro argument without expanding tokens and append the array of
   * tokens to the token stack. Uses Token as a container for the result.
   */
  scanArgument(t) {
    var a, r, n;
    if (t) {
      if (this.consumeSpaces(), this.future().text !== "[")
        return null;
      a = this.popToken(), {
        tokens: n,
        end: r
      } = this.consumeArg(["]"]);
    } else
      ({
        tokens: n,
        start: a,
        end: r
      } = this.consumeArg());
    return this.pushToken(new Pt("EOF", r.loc)), this.pushTokens(n), a.range(r, "");
  }
  /**
   * Consume all following space tokens, without expansion.
   */
  consumeSpaces() {
    for (; ; ) {
      var t = this.future();
      if (t.text === " ")
        this.stack.pop();
      else
        break;
    }
  }
  /**
   * Consume an argument from the token stream, and return the resulting array
   * of tokens and start/end token.
   */
  consumeArg(t) {
    var a = [], r = t && t.length > 0;
    r || this.consumeSpaces();
    var n = this.future(), s, i = 0, o = 0;
    do {
      if (s = this.popToken(), a.push(s), s.text === "{")
        ++i;
      else if (s.text === "}") {
        if (--i, i === -1)
          throw new Q("Extra }", s);
      } else if (s.text === "EOF")
        throw new Q("Unexpected end of input in a macro argument, expected '" + (t && r ? t[o] : "}") + "'", s);
      if (t && r)
        if ((i === 0 || i === 1 && t[o] === "{") && s.text === t[o]) {
          if (++o, o === t.length) {
            a.splice(-o, o);
            break;
          }
        } else
          o = 0;
    } while (i !== 0 || r);
    return n.text === "{" && a[a.length - 1].text === "}" && (a.pop(), a.shift()), a.reverse(), {
      tokens: a,
      start: n,
      end: s
    };
  }
  /**
   * Consume the specified number of (delimited) arguments from the token
   * stream and return the resulting array of arguments.
   */
  consumeArgs(t, a) {
    if (a) {
      if (a.length !== t + 1)
        throw new Q("The length of delimiters doesn't match the number of args!");
      for (var r = a[0], n = 0; n < r.length; n++) {
        var s = this.popToken();
        if (r[n] !== s.text)
          throw new Q("Use of the macro doesn't match its definition", s);
      }
    }
    for (var i = [], o = 0; o < t; o++)
      i.push(this.consumeArg(a && a[o + 1]).tokens);
    return i;
  }
  /**
   * Increment `expansionCount` by the specified amount.
   * Throw an error if it exceeds `maxExpand`.
   */
  countExpansion(t) {
    if (this.expansionCount += t, this.expansionCount > this.settings.maxExpand)
      throw new Q("Too many expansions: infinite loop or need to increase maxExpand setting");
  }
  /**
   * Expand the next token only once if possible.
   *
   * If the token is expanded, the resulting tokens will be pushed onto
   * the stack in reverse order, and the number of such tokens will be
   * returned.  This number might be zero or positive.
   *
   * If not, the return value is `false`, and the next token remains at the
   * top of the stack.
   *
   * In either case, the next token will be on the top of the stack,
   * or the stack will be empty (in case of empty expansion
   * and no other tokens).
   *
   * Used to implement `expandAfterFuture` and `expandNextToken`.
   *
   * If expandableOnly, only expandable tokens are expanded and
   * an undefined control sequence results in an error.
   */
  expandOnce(t) {
    var a = this.popToken(), r = a.text, n = a.noexpand ? null : this._getExpansion(r);
    if (n == null || t && n.unexpandable) {
      if (t && n == null && r[0] === "\\" && !this.isDefined(r))
        throw new Q("Undefined control sequence: " + r);
      return this.pushToken(a), !1;
    }
    this.countExpansion(1);
    var s = n.tokens, i = this.consumeArgs(n.numArgs, n.delimiters);
    if (n.numArgs) {
      s = s.slice();
      for (var o = s.length - 1; o >= 0; --o) {
        var c = s[o];
        if (c.text === "#") {
          if (o === 0)
            throw new Q("Incomplete placeholder at end of macro body", c);
          if (c = s[--o], c.text === "#")
            s.splice(o + 1, 1);
          else if (/^[1-9]$/.test(c.text))
            s.splice(o, 2, ...i[+c.text - 1]);
          else
            throw new Q("Not a valid argument number", c);
        }
      }
    }
    return this.pushTokens(s), s.length;
  }
  /**
   * Expand the next token only once (if possible), and return the resulting
   * top token on the stack (without removing anything from the stack).
   * Similar in behavior to TeX's `\expandafter\futurelet`.
   * Equivalent to expandOnce() followed by future().
   */
  expandAfterFuture() {
    return this.expandOnce(), this.future();
  }
  /**
   * Recursively expand first token, then return first non-expandable token.
   */
  expandNextToken() {
    for (; ; )
      if (this.expandOnce() === !1) {
        var t = this.stack.pop();
        return t.treatAsRelax && (t.text = "\\relax"), t;
      }
    throw new Error();
  }
  /**
   * Fully expand the given macro name and return the resulting list of
   * tokens, or return `undefined` if no such macro is defined.
   */
  expandMacro(t) {
    return this.macros.has(t) ? this.expandTokens([new Pt(t)]) : void 0;
  }
  /**
   * Fully expand the given token stream and return the resulting list of
   * tokens.  Note that the input tokens are in reverse order, but the
   * output tokens are in forward order.
   */
  expandTokens(t) {
    var a = [], r = this.stack.length;
    for (this.pushTokens(t); this.stack.length > r; )
      if (this.expandOnce(!0) === !1) {
        var n = this.stack.pop();
        n.treatAsRelax && (n.noexpand = !1, n.treatAsRelax = !1), a.push(n);
      }
    return this.countExpansion(a.length), a;
  }
  /**
   * Fully expand the given macro name and return the result as a string,
   * or return `undefined` if no such macro is defined.
   */
  expandMacroAsText(t) {
    var a = this.expandMacro(t);
    return a && a.map((r) => r.text).join("");
  }
  /**
   * Returns the expanded macro as a reversed array of tokens and a macro
   * argument count.  Or returns `null` if no such macro.
   */
  _getExpansion(t) {
    var a = this.macros.get(t);
    if (a == null)
      return a;
    if (t.length === 1) {
      var r = this.lexer.catcodes[t];
      if (r != null && r !== 13)
        return;
    }
    var n = typeof a == "function" ? a(this) : a;
    if (typeof n == "string") {
      var s = 0;
      if (n.indexOf("#") !== -1)
        for (var i = n.replace(/##/g, ""); i.indexOf("#" + (s + 1)) !== -1; )
          ++s;
      for (var o = new Hc(n, this.settings), c = [], u = o.lex(); u.text !== "EOF"; )
        c.push(u), u = o.lex();
      c.reverse();
      var d = {
        tokens: c,
        numArgs: s
      };
      return d;
    }
    return n;
  }
  /**
   * Determine whether a command is currently "defined" (has some
   * functionality), meaning that it's a macro (in the current group),
   * a function, a symbol, or one of the special commands listed in
   * `implicitCommands`.
   */
  isDefined(t) {
    return this.macros.has(t) || xa.hasOwnProperty(t) || Pe.math.hasOwnProperty(t) || Pe.text.hasOwnProperty(t) || k0.hasOwnProperty(t);
  }
  /**
   * Determine whether a command is expandable.
   */
  isExpandable(t) {
    var a = this.macros.get(t);
    return a != null ? typeof a == "string" || typeof a == "function" || !a.unexpandable : xa.hasOwnProperty(t) && !xa[t].primitive;
  }
}
var qc = /^[]/, _n = Object.freeze({
  "": "+",
  "": "-",
  "": "=",
  "": "(",
  "": ")",
  "": "0",
  "": "1",
  "": "2",
  "": "3",
  "": "4",
  "": "5",
  "": "6",
  "": "7",
  "": "8",
  "": "9",
  "": "a",
  "": "e",
  "": "h",
  "": "i",
  "": "j",
  "": "k",
  "": "l",
  "": "m",
  "": "n",
  "": "o",
  "": "p",
  "": "r",
  "": "s",
  "": "t",
  "": "u",
  "": "v",
  "": "x",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "+",
  "": "-",
  "": "=",
  "": "(",
  "": ")",
  "": "0",
  "": "1",
  "": "2",
  "": "3",
  "": "4",
  "": "5",
  "": "6",
  "": "7",
  "": "8",
  "": "9",
  "": "A",
  "": "B",
  "": "D",
  "": "E",
  "": "G",
  "": "H",
  "": "I",
  "": "J",
  "": "K",
  "": "L",
  "": "M",
  "": "N",
  "": "O",
  "": "P",
  "": "R",
  "": "T",
  "": "U",
  "": "V",
  "": "W",
  "": "a",
  "": "b",
  "": "c",
  "": "d",
  "": "e",
  "": "f",
  "": "g",
  : "h",
  "": "i",
  : "j",
  "": "k",
  : "l",
  "": "m",
  : "n",
  "": "o",
  "": "p",
  : "r",
  : "s",
  "": "t",
  "": "u",
  "": "v",
  : "w",
  : "x",
  : "y",
  "": "z",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": ""
}), Us = {
  "": {
    text: "\\'",
    math: "\\acute"
  },
  "": {
    text: "\\`",
    math: "\\grave"
  },
  "": {
    text: '\\"',
    math: "\\ddot"
  },
  "": {
    text: "\\~",
    math: "\\tilde"
  },
  "": {
    text: "\\=",
    math: "\\bar"
  },
  "": {
    text: "\\u",
    math: "\\breve"
  },
  "": {
    text: "\\v",
    math: "\\check"
  },
  "": {
    text: "\\^",
    math: "\\hat"
  },
  "": {
    text: "\\.",
    math: "\\dot"
  },
  "": {
    text: "\\r",
    math: "\\mathring"
  },
  "": {
    text: "\\H"
  },
  "": {
    text: "\\c"
  }
}, Yc = {
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "b",
  : "c",
  : "c",
  : "c",
  : "c",
  : "c",
  : "c",
  : "d",
  : "d",
  : "d",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "f",
  : "g",
  : "g",
  : "g",
  : "g",
  : "g",
  : "g",
  : "g",
  : "h",
  : "h",
  : "h",
  : "h",
  : "h",
  : "i",
  : "i",
  : "i",
  : "i",
  : "i",
  : "i",
  : "i",
  : "i",
  : "i",
  : "j",
  : "j",
  : "k",
  : "k",
  : "k",
  : "l",
  : "l",
  : "l",
  : "m",
  : "m",
  : "n",
  : "n",
  : "n",
  : "n",
  : "n",
  : "n",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "p",
  : "p",
  : "r",
  : "r",
  : "r",
  : "r",
  : "s",
  : "s",
  : "s",
  : "s",
  : "s",
  : "s",
  : "s",
  : "t",
  : "t",
  : "t",
  : "t",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "v",
  : "w",
  : "w",
  : "w",
  : "w",
  : "w",
  : "w",
  : "x",
  : "x",
  : "y",
  : "y",
  : "y",
  : "y",
  : "y",
  : "y",
  : "y",
  : "y",
  : "z",
  : "z",
  : "z",
  : "z",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "B",
  : "C",
  : "C",
  : "C",
  : "C",
  : "C",
  : "C",
  : "D",
  : "D",
  : "D",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "F",
  : "G",
  : "G",
  : "G",
  : "G",
  : "G",
  : "G",
  : "G",
  : "H",
  : "H",
  : "H",
  : "H",
  : "H",
  : "I",
  : "I",
  : "I",
  : "I",
  : "I",
  : "I",
  : "I",
  : "I",
  : "I",
  : "I",
  : "J",
  : "K",
  : "K",
  : "K",
  : "L",
  : "L",
  : "L",
  : "M",
  : "M",
  : "N",
  : "N",
  : "N",
  : "N",
  : "N",
  : "N",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "P",
  : "P",
  : "R",
  : "R",
  : "R",
  : "R",
  : "S",
  : "S",
  : "S",
  : "S",
  : "S",
  : "S",
  : "S",
  : "T",
  : "T",
  : "T",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "V",
  : "W",
  : "W",
  : "W",
  : "W",
  : "W",
  : "X",
  : "X",
  : "Y",
  : "Y",
  : "Y",
  : "Y",
  : "Y",
  : "Y",
  : "Y",
  : "Z",
  : "Z",
  : "Z",
  : "Z",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : ""
};
let w0 = class E0 {
  constructor(t, a) {
    this.mode = void 0, this.gullet = void 0, this.settings = void 0, this.leftrightDepth = void 0, this.nextToken = void 0, this.mode = "math", this.gullet = new r2(t, a, this.mode), this.settings = a, this.leftrightDepth = 0;
  }
  /**
   * Checks a result to make sure it has the right type, and throws an
   * appropriate error otherwise.
   */
  expect(t, a) {
    if (a === void 0 && (a = !0), this.fetch().text !== t)
      throw new Q("Expected '" + t + "', got '" + this.fetch().text + "'", this.fetch());
    a && this.consume();
  }
  /**
   * Discards the current lookahead token, considering it consumed.
   */
  consume() {
    this.nextToken = null;
  }
  /**
   * Return the current lookahead token, or if there isn't one (at the
   * beginning, or if the previous lookahead token was consume()d),
   * fetch the next token as the new lookahead token and return it.
   */
  fetch() {
    return this.nextToken == null && (this.nextToken = this.gullet.expandNextToken()), this.nextToken;
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(t) {
    this.mode = t, this.gullet.switchMode(t);
  }
  /**
   * Main parsing function, which parses an entire input.
   */
  parse() {
    this.settings.globalGroup || this.gullet.beginGroup(), this.settings.colorIsTextColor && this.gullet.macros.set("\\color", "\\textcolor");
    try {
      var t = this.parseExpression(!1);
      return this.expect("EOF"), this.settings.globalGroup || this.gullet.endGroup(), t;
    } finally {
      this.gullet.endGroups();
    }
  }
  /**
   * Fully parse a separate sequence of tokens as a separate job.
   * Tokens should be specified in reverse order, as in a MacroDefinition.
   */
  subparse(t) {
    var a = this.nextToken;
    this.consume(), this.gullet.pushToken(new Pt("}")), this.gullet.pushTokens(t);
    var r = this.parseExpression(!1);
    return this.expect("}"), this.nextToken = a, r;
  }
  /**
   * Parses an "expression", which is a list of atoms.
   *
   * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
   *                 happens when functions have higher precedence han infix
   *                 nodes in implicit parses.
   *
   * `breakOnTokenText`: The text of the token that the expression should end
   *                     with, or `null` if something else should end the
   *                     expression.
   */
  parseExpression(t, a) {
    for (var r = []; ; ) {
      this.mode === "math" && this.consumeSpaces();
      var n = this.fetch();
      if (E0.endOfExpression.indexOf(n.text) !== -1 || a && n.text === a || t && xa[n.text] && xa[n.text].infix)
        break;
      var s = this.parseAtom(a);
      if (s) {
        if (s.type === "internal")
          continue;
      } else break;
      r.push(s);
    }
    return this.mode === "text" && this.formLigatures(r), this.handleInfixNodes(r);
  }
  /**
   * Rewrites infix operators such as \over with corresponding commands such
   * as \frac.
   *
   * There can only be one infix operator per group.  If there's more than one
   * then the expression is ambiguous.  This can be resolved by adding {}.
   */
  handleInfixNodes(t) {
    for (var a = -1, r, n = 0; n < t.length; n++)
      if (t[n].type === "infix") {
        if (a !== -1)
          throw new Q("only one infix operator per group", t[n].token);
        a = n, r = t[n].replaceWith;
      }
    if (a !== -1 && r) {
      var s, i, o = t.slice(0, a), c = t.slice(a + 1);
      o.length === 1 && o[0].type === "ordgroup" ? s = o[0] : s = {
        type: "ordgroup",
        mode: this.mode,
        body: o
      }, c.length === 1 && c[0].type === "ordgroup" ? i = c[0] : i = {
        type: "ordgroup",
        mode: this.mode,
        body: c
      };
      var u;
      return r === "\\\\abovefrac" ? u = this.callFunction(r, [s, t[a], i], []) : u = this.callFunction(r, [s, i], []), [u];
    } else
      return t;
  }
  /**
   * Handle a subscript or superscript with nice errors.
   */
  handleSupSubscript(t) {
    var a = this.fetch(), r = a.text;
    this.consume(), this.consumeSpaces();
    var n = this.parseGroup(t);
    if (!n)
      throw new Q("Expected group after '" + r + "'", a);
    return n;
  }
  /**
   * Converts the textual input of an unsupported command into a text node
   * contained within a color node whose color is determined by errorColor
   */
  formatUnsupportedCmd(t) {
    for (var a = [], r = 0; r < t.length; r++)
      a.push({
        type: "textord",
        mode: "text",
        text: t[r]
      });
    var n = {
      type: "text",
      mode: this.mode,
      body: a
    }, s = {
      type: "color",
      mode: this.mode,
      color: this.settings.errorColor,
      body: [n]
    };
    return s;
  }
  /**
   * Parses a group with optional super/subscripts.
   */
  parseAtom(t) {
    var a = this.parseGroup("atom", t);
    if (this.mode === "text")
      return a;
    for (var r, n; ; ) {
      this.consumeSpaces();
      var s = this.fetch();
      if (s.text === "\\limits" || s.text === "\\nolimits") {
        if (a && a.type === "op") {
          var i = s.text === "\\limits";
          a.limits = i, a.alwaysHandleSupSub = !0;
        } else if (a && a.type === "operatorname")
          a.alwaysHandleSupSub && (a.limits = s.text === "\\limits");
        else
          throw new Q("Limit controls must follow a math operator", s);
        this.consume();
      } else if (s.text === "^") {
        if (r)
          throw new Q("Double superscript", s);
        r = this.handleSupSubscript("superscript");
      } else if (s.text === "_") {
        if (n)
          throw new Q("Double subscript", s);
        n = this.handleSupSubscript("subscript");
      } else if (s.text === "'") {
        if (r)
          throw new Q("Double superscript", s);
        var o = {
          type: "textord",
          mode: this.mode,
          text: "\\prime"
        }, c = [o];
        for (this.consume(); this.fetch().text === "'"; )
          c.push(o), this.consume();
        this.fetch().text === "^" && c.push(this.handleSupSubscript("superscript")), r = {
          type: "ordgroup",
          mode: this.mode,
          body: c
        };
      } else if (_n[s.text]) {
        var u = qc.test(s.text), d = [];
        for (d.push(new Pt(_n[s.text])), this.consume(); ; ) {
          var m = this.fetch().text;
          if (!_n[m] || qc.test(m) !== u)
            break;
          d.unshift(new Pt(_n[m])), this.consume();
        }
        var h = this.subparse(d);
        u ? n = {
          type: "ordgroup",
          mode: "math",
          body: h
        } : r = {
          type: "ordgroup",
          mode: "math",
          body: h
        };
      } else
        break;
    }
    return r || n ? {
      type: "supsub",
      mode: this.mode,
      base: a,
      sup: r,
      sub: n
    } : a;
  }
  /**
   * Parses an entire function, including its base and all of its arguments.
   */
  parseFunction(t, a) {
    var r = this.fetch(), n = r.text, s = xa[n];
    if (!s)
      return null;
    if (this.consume(), a && a !== "atom" && !s.allowedInArgument)
      throw new Q("Got function '" + n + "' with no arguments" + (a ? " as " + a : ""), r);
    if (this.mode === "text" && !s.allowedInText)
      throw new Q("Can't use function '" + n + "' in text mode", r);
    if (this.mode === "math" && s.allowedInMath === !1)
      throw new Q("Can't use function '" + n + "' in math mode", r);
    var {
      args: i,
      optArgs: o
    } = this.parseArguments(n, s);
    return this.callFunction(n, i, o, r, t);
  }
  /**
   * Call a function handler with a suitable context and arguments.
   */
  callFunction(t, a, r, n, s) {
    var i = {
      funcName: t,
      parser: this,
      token: n,
      breakOnTokenText: s
    }, o = xa[t];
    if (o && o.handler)
      return o.handler(i, a, r);
    throw new Q("No function handler for " + t);
  }
  /**
   * Parses the arguments of a function or environment
   */
  parseArguments(t, a) {
    var r = a.numArgs + a.numOptionalArgs;
    if (r === 0)
      return {
        args: [],
        optArgs: []
      };
    for (var n = [], s = [], i = 0; i < r; i++) {
      var o = a.argTypes && a.argTypes[i], c = i < a.numOptionalArgs;
      (a.primitive && o == null || // \sqrt expands into primitive if optional argument doesn't exist
      a.type === "sqrt" && i === 1 && s[0] == null) && (o = "primitive");
      var u = this.parseGroupOfType("argument to '" + t + "'", o, c);
      if (c)
        s.push(u);
      else if (u != null)
        n.push(u);
      else
        throw new Q("Null argument, please report this as a bug");
    }
    return {
      args: n,
      optArgs: s
    };
  }
  /**
   * Parses a group when the mode is changing.
   */
  parseGroupOfType(t, a, r) {
    switch (a) {
      case "color":
        return this.parseColorGroup(r);
      case "size":
        return this.parseSizeGroup(r);
      case "url":
        return this.parseUrlGroup(r);
      case "math":
      case "text":
        return this.parseArgumentGroup(r, a);
      case "hbox": {
        var n = this.parseArgumentGroup(r, "text");
        return n != null ? {
          type: "styling",
          mode: n.mode,
          body: [n],
          style: "text"
          // simulate \textstyle
        } : null;
      }
      case "raw": {
        var s = this.parseStringGroup("raw", r);
        return s != null ? {
          type: "raw",
          mode: "text",
          string: s.text
        } : null;
      }
      case "primitive": {
        if (r)
          throw new Q("A primitive argument cannot be optional");
        var i = this.parseGroup(t);
        if (i == null)
          throw new Q("Expected group as " + t, this.fetch());
        return i;
      }
      case "original":
      case null:
      case void 0:
        return this.parseArgumentGroup(r);
      default:
        throw new Q("Unknown group type as " + t, this.fetch());
    }
  }
  /**
   * Discard any space tokens, fetching the next non-space token.
   */
  consumeSpaces() {
    for (; this.fetch().text === " "; )
      this.consume();
  }
  /**
   * Parses a group, essentially returning the string formed by the
   * brace-enclosed tokens plus some position information.
   */
  parseStringGroup(t, a) {
    var r = this.gullet.scanArgument(a);
    if (r == null)
      return null;
    for (var n = "", s; (s = this.fetch()).text !== "EOF"; )
      n += s.text, this.consume();
    return this.consume(), r.text = n, r;
  }
  /**
   * Parses a regex-delimited group: the largest sequence of tokens
   * whose concatenated strings match `regex`. Returns the string
   * formed by the tokens plus some position information.
   */
  parseRegexGroup(t, a) {
    for (var r = this.fetch(), n = r, s = "", i; (i = this.fetch()).text !== "EOF" && t.test(s + i.text); )
      n = i, s += n.text, this.consume();
    if (s === "")
      throw new Q("Invalid " + a + ": '" + r.text + "'", r);
    return r.range(n, s);
  }
  /**
   * Parses a color description.
   */
  parseColorGroup(t) {
    var a = this.parseStringGroup("color", t);
    if (a == null)
      return null;
    var r = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(a.text);
    if (!r)
      throw new Q("Invalid color: '" + a.text + "'", a);
    var n = r[0];
    return /^[0-9a-f]{6}$/i.test(n) && (n = "#" + n), {
      type: "color-token",
      mode: this.mode,
      color: n
    };
  }
  /**
   * Parses a size specification, consisting of magnitude and unit.
   */
  parseSizeGroup(t) {
    var a, r = !1;
    if (this.gullet.consumeSpaces(), !t && this.gullet.future().text !== "{" ? a = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size") : a = this.parseStringGroup("size", t), !a)
      return null;
    !t && a.text.length === 0 && (a.text = "0pt", r = !0);
    var n = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(a.text);
    if (!n)
      throw new Q("Invalid size: '" + a.text + "'", a);
    var s = {
      number: +(n[1] + n[2]),
      // sign + magnitude, cast to number
      unit: n[3]
    };
    if (!zu(s))
      throw new Q("Invalid unit: '" + s.unit + "'", a);
    return {
      type: "size",
      mode: this.mode,
      value: s,
      isBlank: r
    };
  }
  /**
   * Parses an URL, checking escaped letters and allowed protocols,
   * and setting the catcode of % as an active character (as in \hyperref).
   */
  parseUrlGroup(t) {
    this.gullet.lexer.setCatcode("%", 13), this.gullet.lexer.setCatcode("~", 12);
    var a = this.parseStringGroup("url", t);
    if (this.gullet.lexer.setCatcode("%", 14), this.gullet.lexer.setCatcode("~", 13), a == null)
      return null;
    var r = a.text.replace(/\\([#$%&~_^{}])/g, "$1");
    return {
      type: "url",
      mode: this.mode,
      url: r
    };
  }
  /**
   * Parses an argument with the mode specified.
   */
  parseArgumentGroup(t, a) {
    var r = this.gullet.scanArgument(t);
    if (r == null)
      return null;
    var n = this.mode;
    a && this.switchMode(a), this.gullet.beginGroup();
    var s = this.parseExpression(!1, "EOF");
    this.expect("EOF"), this.gullet.endGroup();
    var i = {
      type: "ordgroup",
      mode: this.mode,
      loc: r.loc,
      body: s
    };
    return a && this.switchMode(n), i;
  }
  /**
   * Parses an ordinary group, which is either a single nucleus (like "x")
   * or an expression in braces (like "{x+y}") or an implicit group, a group
   * that starts at the current position, and ends right before a higher explicit
   * group ends, or at EOF.
   */
  parseGroup(t, a) {
    var r = this.fetch(), n = r.text, s;
    if (n === "{" || n === "\\begingroup") {
      this.consume();
      var i = n === "{" ? "}" : "\\endgroup";
      this.gullet.beginGroup();
      var o = this.parseExpression(!1, i), c = this.fetch();
      this.expect(i), this.gullet.endGroup(), s = {
        type: "ordgroup",
        mode: this.mode,
        loc: zt.range(r, c),
        body: o,
        // A group formed by \begingroup...\endgroup is a semi-simple group
        // which doesn't affect spacing in math mode, i.e., is transparent.
        // https://tex.stackexchange.com/questions/1930/when-should-one-
        // use-begingroup-instead-of-bgroup
        semisimple: n === "\\begingroup" || void 0
      };
    } else if (s = this.parseFunction(a, t) || this.parseSymbol(), s == null && n[0] === "\\" && !k0.hasOwnProperty(n)) {
      if (this.settings.throwOnError)
        throw new Q("Undefined control sequence: " + n, r);
      s = this.formatUnsupportedCmd(n), this.consume();
    }
    return s;
  }
  /**
   * Form ligature-like combinations of characters for text mode.
   * This includes inputs like "--", "---", "``" and "''".
   * The result will simply replace multiple textord nodes with a single
   * character in each value by a single textord node having multiple
   * characters in its value.  The representation is still ASCII source.
   * The group will be modified in place.
   */
  formLigatures(t) {
    for (var a = t.length - 1, r = 0; r < a; ++r) {
      var n = t[r], s = n.text;
      s === "-" && t[r + 1].text === "-" && (r + 1 < a && t[r + 2].text === "-" ? (t.splice(r, 3, {
        type: "textord",
        mode: "text",
        loc: zt.range(n, t[r + 2]),
        text: "---"
      }), a -= 2) : (t.splice(r, 2, {
        type: "textord",
        mode: "text",
        loc: zt.range(n, t[r + 1]),
        text: "--"
      }), a -= 1)), (s === "'" || s === "`") && t[r + 1].text === s && (t.splice(r, 2, {
        type: "textord",
        mode: "text",
        loc: zt.range(n, t[r + 1]),
        text: s + s
      }), a -= 1);
    }
  }
  /**
   * Parse a single symbol out of the string. Here, we handle single character
   * symbols and special functions like \verb.
   */
  parseSymbol() {
    var t = this.fetch(), a = t.text;
    if (/^\\verb[^a-zA-Z]/.test(a)) {
      this.consume();
      var r = a.slice(5), n = r.charAt(0) === "*";
      if (n && (r = r.slice(1)), r.length < 2 || r.charAt(0) !== r.slice(-1))
        throw new Q(`\\verb assertion failed --
                    please report what input caused this bug`);
      return r = r.slice(1, -1), {
        type: "verb",
        mode: "text",
        body: r,
        star: n
      };
    }
    Yc.hasOwnProperty(a[0]) && !Pe[this.mode][a[0]] && (this.settings.strict && this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + a[0] + '" used in math mode', t), a = Yc[a[0]] + a.slice(1));
    var s = Z_.exec(a);
    s && (a = a.substring(0, s.index), a === "i" ? a = "" : a === "j" && (a = ""));
    var i;
    if (Pe[this.mode][a]) {
      this.settings.strict && this.mode === "math" && ni.indexOf(a) >= 0 && this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + a[0] + '" used in math mode', t);
      var o = Pe[this.mode][a].group, c = zt.range(t), u;
      if (Vy.hasOwnProperty(o)) {
        var d = o;
        u = {
          type: "atom",
          mode: this.mode,
          family: d,
          loc: c,
          text: a
        };
      } else
        u = {
          type: o,
          mode: this.mode,
          loc: c,
          text: a
        };
      i = u;
    } else if (a.charCodeAt(0) >= 128)
      this.settings.strict && (Su(a.charCodeAt(0)) ? this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + a[0] + '" used in math mode', t) : this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + a[0] + '"' + (" (" + a.charCodeAt(0) + ")"), t)), i = {
        type: "textord",
        mode: "text",
        loc: zt.range(t),
        text: a
      };
    else
      return null;
    if (this.consume(), s)
      for (var m = 0; m < s[0].length; m++) {
        var h = s[0][m];
        if (!Us[h])
          throw new Q("Unknown accent ' " + h + "'", t);
        var y = Us[h][this.mode] || Us[h].text;
        if (!y)
          throw new Q("Accent " + h + " unsupported in " + this.mode + " mode", t);
        i = {
          type: "accent",
          mode: this.mode,
          loc: zt.range(t),
          label: y,
          isStretchy: !1,
          isShifty: !0,
          // $FlowFixMe
          base: i
        };
      }
    return i;
  }
};
w0.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
var Zi = function(t, a) {
  if (!(typeof t == "string" || t instanceof String))
    throw new TypeError("KaTeX can only parse string typed expression");
  var r = new w0(t, a);
  delete r.gullet.macros.current["\\df@tag"];
  var n = r.parse();
  if (delete r.gullet.macros.current["\\current@color"], delete r.gullet.macros.current["\\color"], r.gullet.macros.get("\\df@tag")) {
    if (!a.displayMode)
      throw new Q("\\tag works only in display equations");
    n = [{
      type: "tag",
      mode: "text",
      body: n,
      tag: r.subparse([new Pt("\\df@tag")])
    }];
  }
  return n;
}, T0 = function(t, a, r) {
  a.textContent = "";
  var n = eo(t, r).toNode();
  a.appendChild(n);
};
typeof document < "u" && document.compatMode !== "CSS1Compat" && (typeof console < "u" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype."), T0 = function() {
  throw new Q("KaTeX doesn't work in quirks mode.");
});
var n2 = function(t, a) {
  var r = eo(t, a).toMarkup();
  return r;
}, s2 = function(t, a) {
  var r = new Oi(a);
  return Zi(t, r);
}, v0 = function(t, a, r) {
  if (r.throwOnError || !(t instanceof Q))
    throw t;
  var n = B.makeSpan(["katex-error"], [new Ht(a)]);
  return n.setAttribute("title", t.toString()), n.setAttribute("style", "color:" + r.errorColor), n;
}, eo = function(t, a) {
  var r = new Oi(a);
  try {
    var n = Zi(t, r);
    return m_(n, t, r);
  } catch (s) {
    return v0(s, t, r);
  }
}, i2 = function(t, a) {
  var r = new Oi(a);
  try {
    var n = Zi(t, r);
    return p_(n, t, r);
  } catch (s) {
    return v0(s, t, r);
  }
}, Vc = {
  /**
   * Current KaTeX version
   */
  version: "0.16.11",
  /**
   * Renders the given LaTeX into an HTML+MathML combination, and adds
   * it as a child to the specified DOM node.
   */
  render: T0,
  /**
   * Renders the given LaTeX into an HTML+MathML combination string,
   * for sending to the client.
   */
  renderToString: n2,
  /**
   * KaTeX error, usually during parsing.
   */
  ParseError: Q,
  /**
   * The shema of Settings
   */
  SETTINGS_SCHEMA: vn,
  /**
   * Parses the given LaTeX into KaTeX's internal parse tree structure,
   * without rendering to HTML or MathML.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __parse: s2,
  /**
   * Renders the given LaTeX into an HTML+MathML internal DOM tree
   * representation, without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToDomTree: eo,
  /**
   * Renders the given LaTeX into an HTML internal DOM tree representation,
   * without MathML and without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToHTMLTree: i2,
  /**
   * extends internal font metrics object with a new object
   * each key in the new object represents a font name
  */
  __setFontMetrics: By,
  /**
   * adds a new symbol to builtin symbols table
   */
  __defineSymbol: f,
  /**
   * adds a new function to builtin function list,
   * which directly produce parse tree elements
   * and have their own html/mathml builders
   */
  __defineFunction: ne,
  /**
   * adds a new macro to builtin macro list
   */
  __defineMacro: k,
  /**
   * Expose the dom tree node types, which can be useful for type checking nodes.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __domTree: {
    Span: tn,
    Anchor: Bi,
    SymbolNode: Ht,
    SvgNode: pa,
    PathNode: Sa,
    LineNode: ri
  }
};
const o2 = {};
function c2(e) {
  const t = (
    /** @type {Processor} */
    this
  ), a = e || o2, r = t.data(), n = r.micromarkExtensions || (r.micromarkExtensions = []), s = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), i = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  n.push(ly(a)), s.push(ty()), i.push(ay(a));
}
var ui = { exports: {} };
(function(e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const a = [
    "Int8Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Int16Array",
    "Uint16Array",
    "Int32Array",
    "Uint32Array",
    "Float32Array",
    "Float64Array",
    "BigInt64Array",
    "BigUint64Array"
  ];
  function r(p) {
    return a.includes(p);
  }
  const n = [
    "Function",
    "Generator",
    "AsyncGenerator",
    "GeneratorFunction",
    "AsyncGeneratorFunction",
    "AsyncFunction",
    "Observable",
    "Array",
    "Buffer",
    "Blob",
    "Object",
    "RegExp",
    "Date",
    "Error",
    "Map",
    "Set",
    "WeakMap",
    "WeakSet",
    "ArrayBuffer",
    "SharedArrayBuffer",
    "DataView",
    "Promise",
    "URL",
    "FormData",
    "URLSearchParams",
    "HTMLElement",
    ...a
  ];
  function s(p) {
    return n.includes(p);
  }
  const i = [
    "null",
    "undefined",
    "string",
    "number",
    "bigint",
    "boolean",
    "symbol"
  ];
  function o(p) {
    return i.includes(p);
  }
  function c(p) {
    return (M) => typeof M === p;
  }
  const { toString: u } = Object.prototype, d = (p) => {
    const M = u.call(p).slice(8, -1);
    if (/HTML\w+Element/.test(M) && h.domElement(p))
      return "HTMLElement";
    if (s(M))
      return M;
  }, m = (p) => (M) => d(M) === p;
  function h(p) {
    if (p === null)
      return "null";
    switch (typeof p) {
      case "undefined":
        return "undefined";
      case "string":
        return "string";
      case "number":
        return "number";
      case "boolean":
        return "boolean";
      case "function":
        return "Function";
      case "bigint":
        return "bigint";
      case "symbol":
        return "symbol";
    }
    if (h.observable(p))
      return "Observable";
    if (h.array(p))
      return "Array";
    if (h.buffer(p))
      return "Buffer";
    const M = d(p);
    if (M)
      return M;
    if (p instanceof String || p instanceof Boolean || p instanceof Number)
      throw new TypeError("Please don't use object wrappers for primitive types");
    return "Object";
  }
  h.undefined = c("undefined"), h.string = c("string");
  const y = c("number");
  h.number = (p) => y(p) && !h.nan(p), h.bigint = c("bigint"), h.function_ = c("function"), h.null_ = (p) => p === null, h.class_ = (p) => h.function_(p) && p.toString().startsWith("class "), h.boolean = (p) => p === !0 || p === !1, h.symbol = c("symbol"), h.numericString = (p) => h.string(p) && !h.emptyStringOrWhitespace(p) && !Number.isNaN(Number(p)), h.array = (p, M) => Array.isArray(p) ? h.function_(M) ? p.every(M) : !0 : !1, h.buffer = (p) => {
    var M, te, Z, P;
    return (P = (Z = (te = (M = p) === null || M === void 0 ? void 0 : M.constructor) === null || te === void 0 ? void 0 : te.isBuffer) === null || Z === void 0 ? void 0 : Z.call(te, p)) !== null && P !== void 0 ? P : !1;
  }, h.blob = (p) => m("Blob")(p), h.nullOrUndefined = (p) => h.null_(p) || h.undefined(p), h.object = (p) => !h.null_(p) && (typeof p == "object" || h.function_(p)), h.iterable = (p) => {
    var M;
    return h.function_((M = p) === null || M === void 0 ? void 0 : M[Symbol.iterator]);
  }, h.asyncIterable = (p) => {
    var M;
    return h.function_((M = p) === null || M === void 0 ? void 0 : M[Symbol.asyncIterator]);
  }, h.generator = (p) => {
    var M, te;
    return h.iterable(p) && h.function_((M = p) === null || M === void 0 ? void 0 : M.next) && h.function_((te = p) === null || te === void 0 ? void 0 : te.throw);
  }, h.asyncGenerator = (p) => h.asyncIterable(p) && h.function_(p.next) && h.function_(p.throw), h.nativePromise = (p) => m("Promise")(p);
  const w = (p) => {
    var M, te;
    return h.function_((M = p) === null || M === void 0 ? void 0 : M.then) && h.function_((te = p) === null || te === void 0 ? void 0 : te.catch);
  };
  h.promise = (p) => h.nativePromise(p) || w(p), h.generatorFunction = m("GeneratorFunction"), h.asyncGeneratorFunction = (p) => d(p) === "AsyncGeneratorFunction", h.asyncFunction = (p) => d(p) === "AsyncFunction", h.boundFunction = (p) => h.function_(p) && !p.hasOwnProperty("prototype"), h.regExp = m("RegExp"), h.date = m("Date"), h.error = m("Error"), h.map = (p) => m("Map")(p), h.set = (p) => m("Set")(p), h.weakMap = (p) => m("WeakMap")(p), h.weakSet = (p) => m("WeakSet")(p), h.int8Array = m("Int8Array"), h.uint8Array = m("Uint8Array"), h.uint8ClampedArray = m("Uint8ClampedArray"), h.int16Array = m("Int16Array"), h.uint16Array = m("Uint16Array"), h.int32Array = m("Int32Array"), h.uint32Array = m("Uint32Array"), h.float32Array = m("Float32Array"), h.float64Array = m("Float64Array"), h.bigInt64Array = m("BigInt64Array"), h.bigUint64Array = m("BigUint64Array"), h.arrayBuffer = m("ArrayBuffer"), h.sharedArrayBuffer = m("SharedArrayBuffer"), h.dataView = m("DataView"), h.enumCase = (p, M) => Object.values(M).includes(p), h.directInstanceOf = (p, M) => Object.getPrototypeOf(p) === M.prototype, h.urlInstance = (p) => m("URL")(p), h.urlString = (p) => {
    if (!h.string(p))
      return !1;
    try {
      return new URL(p), !0;
    } catch {
      return !1;
    }
  }, h.truthy = (p) => !!p, h.falsy = (p) => !p, h.nan = (p) => Number.isNaN(p), h.primitive = (p) => h.null_(p) || o(typeof p), h.integer = (p) => Number.isInteger(p), h.safeInteger = (p) => Number.isSafeInteger(p), h.plainObject = (p) => {
    if (u.call(p) !== "[object Object]")
      return !1;
    const M = Object.getPrototypeOf(p);
    return M === null || M === Object.getPrototypeOf({});
  }, h.typedArray = (p) => r(d(p));
  const v = (p) => h.safeInteger(p) && p >= 0;
  h.arrayLike = (p) => !h.nullOrUndefined(p) && !h.function_(p) && v(p.length), h.inRange = (p, M) => {
    if (h.number(M))
      return p >= Math.min(0, M) && p <= Math.max(M, 0);
    if (h.array(M) && M.length === 2)
      return p >= Math.min(...M) && p <= Math.max(...M);
    throw new TypeError(`Invalid range: ${JSON.stringify(M)}`);
  };
  const F = 1, z = [
    "innerHTML",
    "ownerDocument",
    "style",
    "attributes",
    "nodeValue"
  ];
  h.domElement = (p) => h.object(p) && p.nodeType === F && h.string(p.nodeName) && !h.plainObject(p) && z.every((M) => M in p), h.observable = (p) => {
    var M, te, Z, P;
    return p ? p === ((te = (M = p)[Symbol.observable]) === null || te === void 0 ? void 0 : te.call(M)) || p === ((P = (Z = p)["@@observable"]) === null || P === void 0 ? void 0 : P.call(Z)) : !1;
  }, h.nodeStream = (p) => h.object(p) && h.function_(p.pipe) && !h.observable(p), h.infinite = (p) => p === 1 / 0 || p === -1 / 0;
  const C = (p) => (M) => h.integer(M) && Math.abs(M % 2) === p;
  h.evenInteger = C(0), h.oddInteger = C(1), h.emptyArray = (p) => h.array(p) && p.length === 0, h.nonEmptyArray = (p) => h.array(p) && p.length > 0, h.emptyString = (p) => h.string(p) && p.length === 0;
  const U = (p) => h.string(p) && !/\S/.test(p);
  h.emptyStringOrWhitespace = (p) => h.emptyString(p) || U(p), h.nonEmptyString = (p) => h.string(p) && p.length > 0, h.nonEmptyStringAndNotWhitespace = (p) => h.string(p) && !h.emptyStringOrWhitespace(p), h.emptyObject = (p) => h.object(p) && !h.map(p) && !h.set(p) && Object.keys(p).length === 0, h.nonEmptyObject = (p) => h.object(p) && !h.map(p) && !h.set(p) && Object.keys(p).length > 0, h.emptySet = (p) => h.set(p) && p.size === 0, h.nonEmptySet = (p) => h.set(p) && p.size > 0, h.emptyMap = (p) => h.map(p) && p.size === 0, h.nonEmptyMap = (p) => h.map(p) && p.size > 0, h.propertyKey = (p) => h.any([h.string, h.number, h.symbol], p), h.formData = (p) => m("FormData")(p), h.urlSearchParams = (p) => m("URLSearchParams")(p);
  const $ = (p, M, te) => {
    if (!h.function_(M))
      throw new TypeError(`Invalid predicate: ${JSON.stringify(M)}`);
    if (te.length === 0)
      throw new TypeError("Invalid number of values");
    return p.call(te, M);
  };
  h.any = (p, ...M) => (h.array(p) ? p : [p]).some((Z) => $(Array.prototype.some, Z, M)), h.all = (p, ...M) => $(Array.prototype.every, p, M);
  const O = (p, M, te, Z = {}) => {
    if (!p) {
      const { multipleValues: P } = Z, re = P ? `received values of types ${[
        ...new Set(te.map((ae) => `\`${h(ae)}\``))
      ].join(", ")}` : `received value of type \`${h(te)}\``;
      throw new TypeError(`Expected value which is \`${M}\`, ${re}.`);
    }
  };
  t.assert = {
    // Unknowns.
    undefined: (p) => O(h.undefined(p), "undefined", p),
    string: (p) => O(h.string(p), "string", p),
    number: (p) => O(h.number(p), "number", p),
    bigint: (p) => O(h.bigint(p), "bigint", p),
    // eslint-disable-next-line @typescript-eslint/ban-types
    function_: (p) => O(h.function_(p), "Function", p),
    null_: (p) => O(h.null_(p), "null", p),
    class_: (p) => O(h.class_(p), "Class", p),
    boolean: (p) => O(h.boolean(p), "boolean", p),
    symbol: (p) => O(h.symbol(p), "symbol", p),
    numericString: (p) => O(h.numericString(p), "string with a number", p),
    array: (p, M) => {
      O(h.array(p), "Array", p), M && p.forEach(M);
    },
    buffer: (p) => O(h.buffer(p), "Buffer", p),
    blob: (p) => O(h.blob(p), "Blob", p),
    nullOrUndefined: (p) => O(h.nullOrUndefined(p), "null or undefined", p),
    object: (p) => O(h.object(p), "Object", p),
    iterable: (p) => O(h.iterable(p), "Iterable", p),
    asyncIterable: (p) => O(h.asyncIterable(p), "AsyncIterable", p),
    generator: (p) => O(h.generator(p), "Generator", p),
    asyncGenerator: (p) => O(h.asyncGenerator(p), "AsyncGenerator", p),
    nativePromise: (p) => O(h.nativePromise(p), "native Promise", p),
    promise: (p) => O(h.promise(p), "Promise", p),
    generatorFunction: (p) => O(h.generatorFunction(p), "GeneratorFunction", p),
    asyncGeneratorFunction: (p) => O(h.asyncGeneratorFunction(p), "AsyncGeneratorFunction", p),
    // eslint-disable-next-line @typescript-eslint/ban-types
    asyncFunction: (p) => O(h.asyncFunction(p), "AsyncFunction", p),
    // eslint-disable-next-line @typescript-eslint/ban-types
    boundFunction: (p) => O(h.boundFunction(p), "Function", p),
    regExp: (p) => O(h.regExp(p), "RegExp", p),
    date: (p) => O(h.date(p), "Date", p),
    error: (p) => O(h.error(p), "Error", p),
    map: (p) => O(h.map(p), "Map", p),
    set: (p) => O(h.set(p), "Set", p),
    weakMap: (p) => O(h.weakMap(p), "WeakMap", p),
    weakSet: (p) => O(h.weakSet(p), "WeakSet", p),
    int8Array: (p) => O(h.int8Array(p), "Int8Array", p),
    uint8Array: (p) => O(h.uint8Array(p), "Uint8Array", p),
    uint8ClampedArray: (p) => O(h.uint8ClampedArray(p), "Uint8ClampedArray", p),
    int16Array: (p) => O(h.int16Array(p), "Int16Array", p),
    uint16Array: (p) => O(h.uint16Array(p), "Uint16Array", p),
    int32Array: (p) => O(h.int32Array(p), "Int32Array", p),
    uint32Array: (p) => O(h.uint32Array(p), "Uint32Array", p),
    float32Array: (p) => O(h.float32Array(p), "Float32Array", p),
    float64Array: (p) => O(h.float64Array(p), "Float64Array", p),
    bigInt64Array: (p) => O(h.bigInt64Array(p), "BigInt64Array", p),
    bigUint64Array: (p) => O(h.bigUint64Array(p), "BigUint64Array", p),
    arrayBuffer: (p) => O(h.arrayBuffer(p), "ArrayBuffer", p),
    sharedArrayBuffer: (p) => O(h.sharedArrayBuffer(p), "SharedArrayBuffer", p),
    dataView: (p) => O(h.dataView(p), "DataView", p),
    enumCase: (p, M) => O(h.enumCase(p, M), "EnumCase", p),
    urlInstance: (p) => O(h.urlInstance(p), "URL", p),
    urlString: (p) => O(h.urlString(p), "string with a URL", p),
    truthy: (p) => O(h.truthy(p), "truthy", p),
    falsy: (p) => O(h.falsy(p), "falsy", p),
    nan: (p) => O(h.nan(p), "NaN", p),
    primitive: (p) => O(h.primitive(p), "primitive", p),
    integer: (p) => O(h.integer(p), "integer", p),
    safeInteger: (p) => O(h.safeInteger(p), "integer", p),
    plainObject: (p) => O(h.plainObject(p), "plain object", p),
    typedArray: (p) => O(h.typedArray(p), "TypedArray", p),
    arrayLike: (p) => O(h.arrayLike(p), "array-like", p),
    domElement: (p) => O(h.domElement(p), "HTMLElement", p),
    observable: (p) => O(h.observable(p), "Observable", p),
    nodeStream: (p) => O(h.nodeStream(p), "Node.js Stream", p),
    infinite: (p) => O(h.infinite(p), "infinite number", p),
    emptyArray: (p) => O(h.emptyArray(p), "empty array", p),
    nonEmptyArray: (p) => O(h.nonEmptyArray(p), "non-empty array", p),
    emptyString: (p) => O(h.emptyString(p), "empty string", p),
    emptyStringOrWhitespace: (p) => O(h.emptyStringOrWhitespace(p), "empty string or whitespace", p),
    nonEmptyString: (p) => O(h.nonEmptyString(p), "non-empty string", p),
    nonEmptyStringAndNotWhitespace: (p) => O(h.nonEmptyStringAndNotWhitespace(p), "non-empty string and not whitespace", p),
    emptyObject: (p) => O(h.emptyObject(p), "empty object", p),
    nonEmptyObject: (p) => O(h.nonEmptyObject(p), "non-empty object", p),
    emptySet: (p) => O(h.emptySet(p), "empty set", p),
    nonEmptySet: (p) => O(h.nonEmptySet(p), "non-empty set", p),
    emptyMap: (p) => O(h.emptyMap(p), "empty map", p),
    nonEmptyMap: (p) => O(h.nonEmptyMap(p), "non-empty map", p),
    propertyKey: (p) => O(h.propertyKey(p), "PropertyKey", p),
    formData: (p) => O(h.formData(p), "FormData", p),
    urlSearchParams: (p) => O(h.urlSearchParams(p), "URLSearchParams", p),
    // Numbers.
    evenInteger: (p) => O(h.evenInteger(p), "even integer", p),
    oddInteger: (p) => O(h.oddInteger(p), "odd integer", p),
    // Two arguments.
    directInstanceOf: (p, M) => O(h.directInstanceOf(p, M), "T", p),
    inRange: (p, M) => O(h.inRange(p, M), "in range", p),
    // Variadic functions.
    any: (p, ...M) => O(h.any(p, ...M), "predicate returns truthy for any value", M, { multipleValues: !0 }),
    all: (p, ...M) => O(h.all(p, ...M), "predicate returns truthy for all values", M, { multipleValues: !0 })
  }, Object.defineProperties(h, {
    class: {
      value: h.class_
    },
    function: {
      value: h.function_
    },
    null: {
      value: h.null_
    }
  }), Object.defineProperties(t.assert, {
    class: {
      value: t.assert.class_
    },
    function: {
      value: t.assert.function_
    },
    null: {
      value: t.assert.null_
    }
  }), t.default = h, e.exports = h, e.exports.default = h, e.exports.assert = t.assert;
})(ui, ui.exports);
var l2 = ui.exports;
const u2 = {
  keywords: [
    "face",
    "smile",
    "happy",
    "joy",
    ":D",
    "grin"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, f2 = {
  keywords: [
    "face",
    "grimace",
    "teeth"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, h2 = {
  keywords: [
    "face",
    "happy",
    "smile",
    "joy",
    "kawaii"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, d2 = {
  keywords: [
    "face",
    "cry",
    "tears",
    "weep",
    "happy",
    "happytears",
    "haha"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, m2 = {
  keywords: [
    "face",
    "rolling",
    "floor",
    "laughing",
    "lol",
    "haha"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, p2 = {
  keywords: [
    "face",
    "celebration",
    "woohoo"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, g2 = {
  keywords: [
    "face",
    "happy",
    "joy",
    "haha",
    ":D",
    ":)",
    "smile",
    "funny"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, y2 = {
  keywords: [
    "face",
    "happy",
    "joy",
    "funny",
    "haha",
    "laugh",
    "like",
    ":D",
    ":)"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, _2 = {
  keywords: [
    "face",
    "hot",
    "happy",
    "laugh",
    "sweat",
    "smile",
    "relief"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, b2 = {
  keywords: [
    "happy",
    "joy",
    "lol",
    "satisfied",
    "haha",
    "face",
    "glad",
    "XD",
    "laugh"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, k2 = {
  keywords: [
    "face",
    "angel",
    "heaven",
    "halo"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, w2 = {
  keywords: [
    "face",
    "happy",
    "mischievous",
    "secret",
    ";)",
    "smile",
    "eye"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, E2 = {
  keywords: [
    "face",
    "smile",
    "happy",
    "flushed",
    "crush",
    "embarrassed",
    "shy",
    "joy"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, T2 = {
  keywords: [
    "face",
    "smile"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, v2 = {
  keywords: [
    "face",
    "flipped",
    "silly",
    "smile"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, x2 = {
  keywords: [
    "face",
    "blush",
    "massage",
    "happiness"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, A2 = {
  keywords: [
    "happy",
    "joy",
    "tongue",
    "smile",
    "face",
    "silly",
    "yummy",
    "nom",
    "delicious",
    "savouring"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, D2 = {
  keywords: [
    "face",
    "relaxed",
    "phew",
    "massage",
    "happiness"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, C2 = {
  keywords: [
    "face",
    "love",
    "like",
    "affection",
    "valentines",
    "infatuation",
    "crush",
    "heart"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, S2 = {
  keywords: [
    "face",
    "love",
    "like",
    "affection",
    "valentines",
    "infatuation",
    "crush",
    "hearts",
    "adore"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, z2 = {
  keywords: [
    "face",
    "love",
    "like",
    "affection",
    "valentines",
    "infatuation",
    "kiss"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, N2 = {
  keywords: [
    "love",
    "like",
    "face",
    "3",
    "valentines",
    "infatuation",
    "kiss"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, I2 = {
  keywords: [
    "face",
    "affection",
    "valentines",
    "infatuation",
    "kiss"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, R2 = {
  keywords: [
    "face",
    "love",
    "like",
    "affection",
    "valentines",
    "infatuation",
    "kiss"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, F2 = {
  keywords: [
    "face",
    "prank",
    "childish",
    "playful",
    "mischievous",
    "smile",
    "wink",
    "tongue"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, O2 = {
  keywords: [
    "face",
    "goofy",
    "crazy"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, L2 = {
  keywords: [
    "face",
    "distrust",
    "scepticism",
    "disapproval",
    "disbelief",
    "surprise"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, M2 = {
  keywords: [
    "face",
    "stuffy",
    "wealthy"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, B2 = {
  keywords: [
    "face",
    "prank",
    "playful",
    "mischievous",
    "smile",
    "tongue"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, P2 = {
  keywords: [
    "face",
    "prank",
    "childish",
    "playful",
    "mischievous",
    "smile",
    "tongue"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, H2 = {
  keywords: [
    "face",
    "rich",
    "dollar",
    "money"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, U2 = {
  keywords: [
    "face",
    "nerdy",
    "geek",
    "dork"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, j2 = {
  keywords: [
    "face",
    "cool",
    "smile",
    "summer",
    "beach",
    "sunglass"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, q2 = {
  keywords: [
    "face",
    "smile",
    "starry",
    "eyes",
    "grinning"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, Y2 = {
  keywords: [
    "face"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, V2 = {
  keywords: [
    "face",
    "cowgirl",
    "hat"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, G2 = {
  keywords: [
    "face",
    "smile",
    "hug"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, W2 = {
  keywords: [
    "face",
    "smile",
    "mean",
    "prank",
    "smug",
    "sarcasm"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, $2 = {
  keywords: [
    "face",
    "hellokitty"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, X2 = {
  keywords: [
    "indifference",
    "meh",
    ":|",
    "neutral"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, Q2 = {
  keywords: [
    "face",
    "indifferent",
    "-_-",
    "meh",
    "deadpan"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, K2 = {
  keywords: [
    "indifference",
    "bored",
    "straight face",
    "serious",
    "sarcasm",
    "unimpressed",
    "skeptical",
    "dubious",
    "side_eye"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, J2 = {
  keywords: [
    "face",
    "eyeroll",
    "frustrated"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, Z2 = {
  keywords: [
    "face",
    "hmmm",
    "think",
    "consider"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, e4 = {
  keywords: [
    "face",
    "lie",
    "pinocchio"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, t4 = {
  keywords: [
    "face",
    "whoops",
    "shock",
    "surprise"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, a4 = {
  keywords: [
    "face",
    "quiet",
    "shhh"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, r4 = {
  keywords: [
    "face",
    "swearing",
    "cursing",
    "cussing",
    "profanity",
    "expletive"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, n4 = {
  keywords: [
    "face",
    "shocked",
    "mind",
    "blown"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, s4 = {
  keywords: [
    "face",
    "blush",
    "shy",
    "flattered"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, i4 = {
  keywords: [
    "face",
    "sad",
    "upset",
    "depressed",
    ":("
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, o4 = {
  keywords: [
    "face",
    "concern",
    "nervous",
    ":("
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, c4 = {
  keywords: [
    "mad",
    "face",
    "annoyed",
    "frustrated"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, l4 = {
  keywords: [
    "angry",
    "mad",
    "hate",
    "despise"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, u4 = {
  keywords: [
    "face",
    "sad",
    "depressed",
    "upset"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, f4 = {
  keywords: [
    "face",
    "indifference",
    "huh",
    "weird",
    "hmmm",
    ":/"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, h4 = {
  keywords: [
    "face",
    "frowning",
    "disappointed",
    "sad",
    "upset"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, d4 = {
  keywords: [
    "face",
    "sad",
    "upset",
    "frown"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, m4 = {
  keywords: [
    "face",
    "sick",
    "no",
    "upset",
    "oops"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, p4 = {
  keywords: [
    "face",
    "confused",
    "sick",
    "unwell",
    "oops",
    ":S"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, g4 = {
  keywords: [
    "sick",
    "whine",
    "upset",
    "frustrated"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, y4 = {
  keywords: [
    "face",
    "tired",
    "sleepy",
    "sad",
    "frustrated",
    "upset"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, _4 = {
  keywords: [
    "face",
    "begging",
    "mercy"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, b4 = {
  keywords: [
    "face",
    "gas",
    "phew",
    "proud",
    "pride"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, k4 = {
  keywords: [
    "face",
    "surprise",
    "impressed",
    "wow",
    "whoa",
    ":O"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, w4 = {
  keywords: [
    "face",
    "munch",
    "scared",
    "omg"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, E4 = {
  keywords: [
    "face",
    "scared",
    "terrified",
    "nervous",
    "oops",
    "huh"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, T4 = {
  keywords: [
    "face",
    "nervous",
    "sweat"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, v4 = {
  keywords: [
    "face",
    "woo",
    "shh"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, x4 = {
  keywords: [
    "face",
    "aw",
    "what"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, A4 = {
  keywords: [
    "face",
    "stunned",
    "nervous"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, D4 = {
  keywords: [
    "face",
    "tears",
    "sad",
    "depressed",
    "upset",
    ":'("
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, C4 = {
  keywords: [
    "face",
    "phew",
    "sweat",
    "nervous"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, S4 = {
  keywords: [
    "face"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, z4 = {
  keywords: [
    "face",
    "tired",
    "rest",
    "nap"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, N4 = {
  keywords: [
    "face",
    "hot",
    "sad",
    "tired",
    "exercise"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, I4 = {
  keywords: [
    "face",
    "feverish",
    "heat",
    "red",
    "sweating"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, R4 = {
  keywords: [
    "face",
    "blue",
    "freezing",
    "frozen",
    "frostbite",
    "icicles"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, F4 = {
  keywords: [
    "face",
    "cry",
    "tears",
    "sad",
    "upset",
    "depressed"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, O4 = {
  keywords: [
    "spent",
    "unconscious",
    "xox",
    "dizzy"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, L4 = {
  keywords: [
    "face",
    "xox",
    "surprised",
    "poisoned"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, M4 = {
  keywords: [
    "face",
    "sealed",
    "zipper",
    "secret"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, B4 = {
  keywords: [
    "face",
    "vomit",
    "gross",
    "green",
    "sick",
    "throw up",
    "ill"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, P4 = {
  keywords: [
    "face",
    "gesundheit",
    "sneeze",
    "sick",
    "allergy"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, H4 = {
  keywords: [
    "face",
    "sick"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, U4 = {
  keywords: [
    "face",
    "sick",
    "ill",
    "disease"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, j4 = {
  keywords: [
    "sick",
    "temperature",
    "thermometer",
    "cold",
    "fever"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, q4 = {
  keywords: [
    "injured",
    "clumsy",
    "bandage",
    "hurt"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, Y4 = {
  keywords: [
    "face",
    "dizzy",
    "intoxicated",
    "tipsy",
    "wavy"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, V4 = {
  keywords: [
    "face",
    "tired",
    "sleepy",
    "night",
    "zzz"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, G4 = {
  keywords: [
    "sleepy",
    "tired",
    "dream"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, W4 = {
  keywords: [
    "hankey",
    "shitface",
    "fail",
    "turd",
    "shit"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, $4 = {
  keywords: [
    "devil",
    "horns"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, X4 = {
  keywords: [
    "devil",
    "angry",
    "horns"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, Q4 = {
  keywords: [
    "monster",
    "red",
    "mask",
    "halloween",
    "scary",
    "creepy",
    "devil",
    "demon",
    "japanese",
    "ogre"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, K4 = {
  keywords: [
    "red",
    "evil",
    "mask",
    "monster",
    "scary",
    "creepy",
    "japanese",
    "goblin"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, J4 = {
  keywords: [
    "dead",
    "skeleton",
    "creepy",
    "death"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, Z4 = {
  keywords: [
    "halloween",
    "spooky",
    "scary"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, eb = {
  keywords: [
    "UFO",
    "paul",
    "weird",
    "outer_space"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, tb = {
  keywords: [
    "computer",
    "machine",
    "bot"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, ab = {
  keywords: [
    "animal",
    "cats",
    "happy",
    "smile"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, rb = {
  keywords: [
    "animal",
    "cats",
    "smile"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, nb = {
  keywords: [
    "animal",
    "cats",
    "haha",
    "happy",
    "tears"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, sb = {
  keywords: [
    "animal",
    "love",
    "like",
    "affection",
    "cats",
    "valentines",
    "heart"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, ib = {
  keywords: [
    "animal",
    "cats",
    "smirk"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, ob = {
  keywords: [
    "animal",
    "cats",
    "kiss"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, cb = {
  keywords: [
    "animal",
    "cats",
    "munch",
    "scared",
    "scream"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, lb = {
  keywords: [
    "animal",
    "tears",
    "weep",
    "sad",
    "cats",
    "upset",
    "cry"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, ub = {
  keywords: [
    "animal",
    "cats"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, fb = {
  keywords: [
    "hands",
    "gesture",
    "cupped",
    "prayer"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, hb = {
  keywords: [
    "gesture",
    "hooray",
    "yea",
    "celebration",
    "hands"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, db = {
  keywords: [
    "hands",
    "praise",
    "applause",
    "congrats",
    "yay"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, mb = {
  keywords: [
    "hands",
    "gesture",
    "goodbye",
    "solong",
    "farewell",
    "hello",
    "hi",
    "palm"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, pb = {
  keywords: [
    "hands",
    "gesture"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, gb = {
  keywords: [
    "angry",
    "violence",
    "fist",
    "hit",
    "attack",
    "hand"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, yb = {
  keywords: [
    "fingers",
    "hand",
    "grasp"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, _b = {
  keywords: [
    "hand",
    "fistbump"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, bb = {
  keywords: [
    "hand",
    "fistbump"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, kb = {
  keywords: [
    "fingers",
    "ohyeah",
    "hand",
    "peace",
    "victory",
    "two"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, wb = {
  keywords: [
    "fingers",
    "limbs",
    "perfect",
    "ok",
    "okay"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Eb = {
  keywords: [
    "fingers",
    "stop",
    "highfive",
    "palm",
    "ban"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Tb = {
  keywords: [
    "fingers",
    "raised",
    "backhand"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, vb = {
  keywords: [
    "fingers",
    "butterfly",
    "hands",
    "open"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, xb = {
  keywords: [
    "arm",
    "flex",
    "hand",
    "summer",
    "strong",
    "biceps"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Ab = {
  keywords: [
    "please",
    "hope",
    "wish",
    "namaste",
    "highfive"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Db = {
  keywords: [
    "kick",
    "stomp"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Cb = {
  keywords: [
    "kick",
    "limb"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Sb = {
  keywords: [
    "agreement",
    "shake"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, zb = {
  keywords: [
    "hand",
    "fingers",
    "direction",
    "up"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Nb = {
  keywords: [
    "fingers",
    "hand",
    "direction",
    "up"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Ib = {
  keywords: [
    "fingers",
    "hand",
    "direction",
    "down"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Rb = {
  keywords: [
    "direction",
    "fingers",
    "hand",
    "left"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Fb = {
  keywords: [
    "fingers",
    "hand",
    "direction",
    "right"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Ob = {
  keywords: [
    "hand",
    "fingers",
    "rude",
    "middle",
    "flipping"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Lb = {
  keywords: [
    "hand",
    "fingers",
    "palm"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Mb = {
  keywords: [
    "hand",
    "fingers",
    "gesture"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Bb = {
  keywords: [
    "hand",
    "fingers",
    "evil_eye",
    "sign_of_horns",
    "rock_on"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Pb = {
  keywords: [
    "good",
    "lucky"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Hb = {
  keywords: [
    "hand",
    "fingers",
    "spock",
    "star trek"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Ub = {
  keywords: [
    "lower_left_ballpoint_pen",
    "stationery",
    "write",
    "compose"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, jb = {
  keywords: [
    "camera",
    "phone"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, qb = {
  keywords: [
    "beauty",
    "manicure",
    "finger",
    "fashion",
    "nail"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Yb = {
  keywords: [
    "mouth",
    "kiss"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, Vb = {
  keywords: [
    "teeth",
    "dentist"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, Gb = {
  keywords: [
    "mouth",
    "playful"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, Wb = {
  keywords: [
    "face",
    "hear",
    "sound",
    "listen"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, $b = {
  keywords: [
    "smell",
    "sniff"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Xb = {
  keywords: [
    "face",
    "look",
    "see",
    "watch",
    "stare"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, Qb = {
  keywords: [
    "look",
    "watch",
    "stalk",
    "peek",
    "see"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, Kb = {
  keywords: [
    "smart",
    "intelligent"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, Jb = {
  keywords: [
    "user",
    "person",
    "human"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, Zb = {
  keywords: [
    "user",
    "person",
    "human",
    "group",
    "team"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, e3 = {
  keywords: [
    "user",
    "person",
    "human",
    "sing",
    "say",
    "talk"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, t3 = {
  keywords: [
    "child",
    "boy",
    "girl",
    "toddler"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, a3 = {
  keywords: [
    "gender-neutral",
    "young"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, r3 = {
  keywords: [
    "man",
    "male",
    "guy",
    "teenager"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, n3 = {
  keywords: [
    "female",
    "woman",
    "teenager"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, s3 = {
  keywords: [
    "gender-neutral",
    "person"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, i3 = {
  keywords: [
    "mustache",
    "father",
    "dad",
    "guy",
    "classy",
    "sir",
    "moustache"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, o3 = {
  keywords: [
    "female",
    "girls",
    "lady"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, c3 = {
  keywords: [
    "woman",
    "female",
    "girl",
    "blonde",
    "person"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, l3 = {
  keywords: [
    "man",
    "male",
    "boy",
    "blonde",
    "guy",
    "person"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, u3 = {
  keywords: [
    "person",
    "bewhiskered"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, f3 = {
  keywords: [
    "human",
    "elder",
    "senior",
    "gender-neutral"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, h3 = {
  keywords: [
    "human",
    "male",
    "men",
    "old",
    "elder",
    "senior"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, d3 = {
  keywords: [
    "human",
    "female",
    "women",
    "lady",
    "old",
    "elder",
    "senior"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, m3 = {
  keywords: [
    "male",
    "boy",
    "chinese"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, p3 = {
  keywords: [
    "female",
    "hijab",
    "mantilla",
    "tichel"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, g3 = {
  keywords: [
    "female",
    "indian",
    "hinduism",
    "arabs",
    "woman"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, y3 = {
  keywords: [
    "male",
    "indian",
    "hinduism",
    "arabs"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, _3 = {
  keywords: [
    "woman",
    "police",
    "law",
    "legal",
    "enforcement",
    "arrest",
    "911",
    "female"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, b3 = {
  keywords: [
    "man",
    "police",
    "law",
    "legal",
    "enforcement",
    "arrest",
    "911"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, k3 = {
  keywords: [
    "female",
    "human",
    "wip",
    "build",
    "construction",
    "worker",
    "labor",
    "woman"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, w3 = {
  keywords: [
    "male",
    "human",
    "wip",
    "guy",
    "build",
    "construction",
    "worker",
    "labor"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, E3 = {
  keywords: [
    "uk",
    "gb",
    "british",
    "female",
    "royal",
    "woman"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, T3 = {
  keywords: [
    "uk",
    "gb",
    "british",
    "male",
    "guy",
    "royal"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, v3 = {
  keywords: [
    "human",
    "spy",
    "detective",
    "female",
    "woman"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, x3 = {
  keywords: [
    "human",
    "spy",
    "detective"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, A3 = {
  keywords: [
    "doctor",
    "nurse",
    "therapist",
    "healthcare",
    "woman",
    "human"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, D3 = {
  keywords: [
    "doctor",
    "nurse",
    "therapist",
    "healthcare",
    "man",
    "human"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, C3 = {
  keywords: [
    "rancher",
    "gardener",
    "woman",
    "human"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, S3 = {
  keywords: [
    "rancher",
    "gardener",
    "man",
    "human"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, z3 = {
  keywords: [
    "chef",
    "woman",
    "human"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, N3 = {
  keywords: [
    "chef",
    "man",
    "human"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, I3 = {
  keywords: [
    "graduate",
    "woman",
    "human"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, R3 = {
  keywords: [
    "graduate",
    "man",
    "human"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, F3 = {
  keywords: [
    "rockstar",
    "entertainer",
    "woman",
    "human"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, O3 = {
  keywords: [
    "rockstar",
    "entertainer",
    "man",
    "human"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, L3 = {
  keywords: [
    "instructor",
    "professor",
    "woman",
    "human"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, M3 = {
  keywords: [
    "instructor",
    "professor",
    "man",
    "human"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, B3 = {
  keywords: [
    "assembly",
    "industrial",
    "woman",
    "human"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, P3 = {
  keywords: [
    "assembly",
    "industrial",
    "man",
    "human"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, H3 = {
  keywords: [
    "coder",
    "developer",
    "engineer",
    "programmer",
    "software",
    "woman",
    "human",
    "laptop",
    "computer"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, U3 = {
  keywords: [
    "coder",
    "developer",
    "engineer",
    "programmer",
    "software",
    "man",
    "human",
    "laptop",
    "computer"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, j3 = {
  keywords: [
    "business",
    "manager",
    "woman",
    "human"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, q3 = {
  keywords: [
    "business",
    "manager",
    "man",
    "human"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Y3 = {
  keywords: [
    "plumber",
    "woman",
    "human",
    "wrench"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, V3 = {
  keywords: [
    "plumber",
    "man",
    "human",
    "wrench"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, G3 = {
  keywords: [
    "biologist",
    "chemist",
    "engineer",
    "physicist",
    "woman",
    "human"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, W3 = {
  keywords: [
    "biologist",
    "chemist",
    "engineer",
    "physicist",
    "man",
    "human"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, $3 = {
  keywords: [
    "painter",
    "woman",
    "human"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, X3 = {
  keywords: [
    "painter",
    "man",
    "human"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Q3 = {
  keywords: [
    "fireman",
    "woman",
    "human"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, K3 = {
  keywords: [
    "fireman",
    "man",
    "human"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, J3 = {
  keywords: [
    "aviator",
    "plane",
    "woman",
    "human"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Z3 = {
  keywords: [
    "aviator",
    "plane",
    "man",
    "human"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, ek = {
  keywords: [
    "space",
    "rocket",
    "woman",
    "human"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, tk = {
  keywords: [
    "space",
    "rocket",
    "man",
    "human"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, ak = {
  keywords: [
    "justice",
    "court",
    "woman",
    "human"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, rk = {
  keywords: [
    "justice",
    "court",
    "man",
    "human"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, nk = {
  keywords: [
    "woman",
    "female",
    "good",
    "heroine",
    "superpowers"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, sk = {
  keywords: [
    "man",
    "male",
    "good",
    "hero",
    "superpowers"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, ik = {
  keywords: [
    "woman",
    "female",
    "evil",
    "bad",
    "criminal",
    "heroine",
    "superpowers"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, ok = {
  keywords: [
    "man",
    "male",
    "evil",
    "bad",
    "criminal",
    "hero",
    "superpowers"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, ck = {
  keywords: [
    "woman",
    "female",
    "xmas",
    "mother christmas"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, lk = {
  keywords: [
    "festival",
    "man",
    "male",
    "xmas",
    "father christmas"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, uk = {
  keywords: [
    "woman",
    "female",
    "mage",
    "witch"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, fk = {
  keywords: [
    "man",
    "male",
    "mage",
    "sorcerer"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, hk = {
  keywords: [
    "woman",
    "female"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, dk = {
  keywords: [
    "man",
    "male"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, mk = {
  keywords: [
    "woman",
    "female"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, pk = {
  keywords: [
    "man",
    "male",
    "dracula"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, gk = {
  keywords: [
    "woman",
    "female",
    "undead",
    "walking dead"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, yk = {
  keywords: [
    "man",
    "male",
    "dracula",
    "undead",
    "walking dead"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, _k = {
  keywords: [
    "woman",
    "female"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, bk = {
  keywords: [
    "man",
    "male"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, kk = {
  keywords: [
    "woman",
    "female",
    "merwoman",
    "ariel"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, wk = {
  keywords: [
    "man",
    "male",
    "triton"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Ek = {
  keywords: [
    "woman",
    "female"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Tk = {
  keywords: [
    "man",
    "male"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, vk = {
  keywords: [
    "heaven",
    "wings",
    "halo"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, xk = {
  keywords: [
    "baby"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Ak = {
  keywords: [
    "nursing",
    "baby"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Dk = {
  keywords: [
    "girl",
    "woman",
    "female",
    "blond",
    "crown",
    "royal",
    "queen"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Ck = {
  keywords: [
    "boy",
    "man",
    "male",
    "crown",
    "royal",
    "king"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Sk = {
  keywords: [
    "couple",
    "marriage",
    "wedding",
    "woman",
    "bride"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, zk = {
  keywords: [
    "couple",
    "marriage",
    "wedding",
    "groom"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Nk = {
  keywords: [
    "woman",
    "walking",
    "exercise",
    "race",
    "running",
    "female"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Ik = {
  keywords: [
    "man",
    "walking",
    "exercise",
    "race",
    "running"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Rk = {
  keywords: [
    "human",
    "feet",
    "steps",
    "woman",
    "female"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Fk = {
  keywords: [
    "human",
    "feet",
    "steps"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Ok = {
  keywords: [
    "female",
    "girl",
    "woman",
    "fun"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Lk = {
  keywords: [
    "male",
    "boy",
    "fun",
    "dancer"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Mk = {
  keywords: [
    "female",
    "bunny",
    "women",
    "girls"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, Bk = {
  keywords: [
    "male",
    "bunny",
    "men",
    "boys"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, Pk = {
  keywords: [
    "pair",
    "people",
    "human",
    "love",
    "date",
    "dating",
    "like",
    "affection",
    "valentines",
    "marriage"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, Hk = {
  keywords: [
    "pair",
    "couple",
    "love",
    "like",
    "bromance",
    "friendship",
    "people",
    "human"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, Uk = {
  keywords: [
    "pair",
    "friendship",
    "couple",
    "love",
    "like",
    "female",
    "people",
    "human"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, jk = {
  keywords: [
    "woman",
    "female",
    "girl"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, qk = {
  keywords: [
    "man",
    "male",
    "boy"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Yk = {
  keywords: [
    "man",
    "male",
    "boy",
    "disbelief"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Vk = {
  keywords: [
    "woman",
    "female",
    "girl",
    "disbelief"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Gk = {
  keywords: [
    "woman",
    "female",
    "girl",
    "confused",
    "indifferent",
    "doubt"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Wk = {
  keywords: [
    "man",
    "male",
    "boy",
    "confused",
    "indifferent",
    "doubt"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, $k = {
  keywords: [
    "female",
    "girl",
    "woman",
    "human",
    "information"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Xk = {
  keywords: [
    "male",
    "boy",
    "man",
    "human",
    "information"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Qk = {
  keywords: [
    "female",
    "girl",
    "woman",
    "nope"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Kk = {
  keywords: [
    "male",
    "boy",
    "man",
    "nope"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Jk = {
  keywords: [
    "women",
    "girl",
    "female",
    "pink",
    "human",
    "woman"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, Zk = {
  keywords: [
    "men",
    "boy",
    "male",
    "blue",
    "human",
    "man"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, e6 = {
  keywords: [
    "female",
    "girl",
    "woman"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, t6 = {
  keywords: [
    "male",
    "boy",
    "man"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, a6 = {
  keywords: [
    "female",
    "girl",
    "woman"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, r6 = {
  keywords: [
    "male",
    "boy",
    "man"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, n6 = {
  keywords: [
    "female",
    "girl",
    "woman",
    "sad",
    "depressed",
    "discouraged",
    "unhappy"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, s6 = {
  keywords: [
    "male",
    "boy",
    "man",
    "sad",
    "depressed",
    "discouraged",
    "unhappy"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, i6 = {
  keywords: [
    "female",
    "girl",
    "woman"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, o6 = {
  keywords: [
    "male",
    "boy",
    "man"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, c6 = {
  keywords: [
    "female",
    "girl",
    "woman",
    "head"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, l6 = {
  keywords: [
    "male",
    "boy",
    "man",
    "head"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, u6 = {
  keywords: [
    "female",
    "woman",
    "spa",
    "steamroom",
    "sauna"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, f6 = {
  keywords: [
    "male",
    "man",
    "spa",
    "steamroom",
    "sauna"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "people"
}, h6 = {
  keywords: [
    "pair",
    "love",
    "like",
    "affection",
    "human",
    "dating",
    "valentines",
    "marriage"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, d6 = {
  keywords: [
    "pair",
    "love",
    "like",
    "affection",
    "human",
    "dating",
    "valentines",
    "marriage"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, m6 = {
  keywords: [
    "pair",
    "love",
    "like",
    "affection",
    "human",
    "dating",
    "valentines",
    "marriage"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, p6 = {
  keywords: [
    "pair",
    "valentines",
    "love",
    "like",
    "dating",
    "marriage"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, g6 = {
  keywords: [
    "pair",
    "valentines",
    "love",
    "like",
    "dating",
    "marriage"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, y6 = {
  keywords: [
    "pair",
    "valentines",
    "love",
    "like",
    "dating",
    "marriage"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, _6 = {
  keywords: [
    "home",
    "parents",
    "child",
    "mom",
    "dad",
    "father",
    "mother",
    "people",
    "human"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, b6 = {
  keywords: [
    "home",
    "parents",
    "people",
    "human",
    "child"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, k6 = {
  keywords: [
    "home",
    "parents",
    "people",
    "human",
    "children"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, w6 = {
  keywords: [
    "home",
    "parents",
    "people",
    "human",
    "children"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, E6 = {
  keywords: [
    "home",
    "parents",
    "people",
    "human",
    "children"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, T6 = {
  keywords: [
    "home",
    "parents",
    "people",
    "human",
    "children"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, v6 = {
  keywords: [
    "home",
    "parents",
    "people",
    "human",
    "children"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, x6 = {
  keywords: [
    "home",
    "parents",
    "people",
    "human",
    "children"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, A6 = {
  keywords: [
    "home",
    "parents",
    "people",
    "human",
    "children"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, D6 = {
  keywords: [
    "home",
    "parents",
    "people",
    "human",
    "children"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, C6 = {
  keywords: [
    "home",
    "parents",
    "people",
    "human",
    "children"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, S6 = {
  keywords: [
    "home",
    "parents",
    "people",
    "human",
    "children"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, z6 = {
  keywords: [
    "home",
    "parents",
    "people",
    "human",
    "children"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, N6 = {
  keywords: [
    "home",
    "parents",
    "people",
    "human",
    "children"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, I6 = {
  keywords: [
    "home",
    "parents",
    "people",
    "human",
    "children"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, R6 = {
  keywords: [
    "home",
    "parent",
    "people",
    "human",
    "child"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, F6 = {
  keywords: [
    "home",
    "parent",
    "people",
    "human",
    "child"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, O6 = {
  keywords: [
    "home",
    "parent",
    "people",
    "human",
    "children"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, L6 = {
  keywords: [
    "home",
    "parent",
    "people",
    "human",
    "children"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, M6 = {
  keywords: [
    "home",
    "parent",
    "people",
    "human",
    "children"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, B6 = {
  keywords: [
    "home",
    "parent",
    "people",
    "human",
    "child"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, P6 = {
  keywords: [
    "home",
    "parent",
    "people",
    "human",
    "child"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, H6 = {
  keywords: [
    "home",
    "parent",
    "people",
    "human",
    "children"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, U6 = {
  keywords: [
    "home",
    "parent",
    "people",
    "human",
    "children"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, j6 = {
  keywords: [
    "home",
    "parent",
    "people",
    "human",
    "children"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, q6 = {
  keywords: [
    "ball",
    "crochet",
    "knit"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, Y6 = {
  keywords: [
    "needle",
    "sewing",
    "spool",
    "string"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, V6 = {
  keywords: [
    "jacket"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, G6 = {
  keywords: [
    "doctor",
    "experiment",
    "scientist",
    "chemist"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, W6 = {
  keywords: [
    "fashion",
    "shopping_bags",
    "female"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, $6 = {
  keywords: [
    "fashion",
    "cloth",
    "casual",
    "shirt",
    "tee"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, X6 = {
  keywords: [
    "fashion",
    "shopping"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, Q6 = {
  keywords: [
    "shirt",
    "suitup",
    "formal",
    "fashion",
    "cloth",
    "business"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, K6 = {
  keywords: [
    "clothes",
    "fashion",
    "shopping"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, J6 = {
  keywords: [
    "swimming",
    "female",
    "woman",
    "girl",
    "fashion",
    "beach",
    "summer"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, Z6 = {
  keywords: [
    "dress",
    "fashion",
    "women",
    "female",
    "japanese"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, e5 = {
  keywords: [
    "female",
    "girl",
    "fashion",
    "woman"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, t5 = {
  keywords: [
    "face",
    "lips",
    "love",
    "like",
    "affection",
    "valentines"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, a5 = {
  keywords: [
    "feet",
    "tracking",
    "walking",
    "beach"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, r5 = {
  keywords: [
    "ballet",
    "slip-on",
    "slipper"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, n5 = {
  keywords: [
    "fashion",
    "shoes",
    "female",
    "pumps",
    "stiletto"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, s5 = {
  keywords: [
    "shoes",
    "fashion",
    "flip flops"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, i5 = {
  keywords: [
    "shoes",
    "fashion"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, o5 = {
  keywords: [
    "fashion",
    "male"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, c5 = {
  keywords: [
    "shoes",
    "sports",
    "sneakers"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, l5 = {
  keywords: [
    "backpacking",
    "camping",
    "hiking"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, u5 = {
  keywords: [
    "stockings",
    "clothes"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, f5 = {
  keywords: [
    "hands",
    "winter",
    "clothes"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, h5 = {
  keywords: [
    "neck",
    "winter",
    "clothes"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, d5 = {
  keywords: [
    "fashion",
    "accessories",
    "female",
    "lady",
    "spring"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, m5 = {
  keywords: [
    "magic",
    "gentleman",
    "classy",
    "circus"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, p5 = {
  keywords: [
    "cap",
    "baseball"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, g5 = {
  keywords: [
    "construction",
    "build"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, y5 = {
  keywords: [
    "school",
    "college",
    "degree",
    "university",
    "graduation",
    "cap",
    "hat",
    "legal",
    "learn",
    "education"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, _5 = {
  keywords: [
    "king",
    "kod",
    "leader",
    "royalty",
    "lord"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, b5 = {
  keywords: [
    "student",
    "education",
    "bag",
    "backpack"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, k5 = {
  keywords: [
    "packing",
    "travel"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, w5 = {
  keywords: [
    "bag",
    "accessories",
    "shopping"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, E5 = {
  keywords: [
    "fashion",
    "accessories",
    "money",
    "sales",
    "shopping"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, T5 = {
  keywords: [
    "fashion",
    "accessory",
    "accessories",
    "shopping"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, v5 = {
  keywords: [
    "business",
    "documents",
    "work",
    "law",
    "legal",
    "job",
    "career"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, x5 = {
  keywords: [
    "fashion",
    "accessories",
    "eyesight",
    "nerdy",
    "dork",
    "geek"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, A5 = {
  keywords: [
    "face",
    "cool",
    "accessories"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, D5 = {
  keywords: [
    "eyes",
    "protection",
    "safety"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, C5 = {
  keywords: [
    "wedding",
    "propose",
    "marriage",
    "valentines",
    "diamond",
    "fashion",
    "jewelry",
    "gem",
    "engagement"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, S5 = {
  keywords: [
    "weather",
    "rain",
    "drizzle"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "people"
}, z5 = {
  keywords: [
    "animal",
    "friend",
    "nature",
    "woof",
    "puppy",
    "pet",
    "faithful"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, N5 = {
  keywords: [
    "animal",
    "meow",
    "nature",
    "pet",
    "kitten"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, I5 = {
  keywords: [
    "animal",
    "nature",
    "cheese_wedge",
    "rodent"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, R5 = {
  keywords: [
    "animal",
    "nature"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, F5 = {
  keywords: [
    "animal",
    "nature",
    "pet",
    "spring",
    "magic",
    "bunny"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, O5 = {
  keywords: [
    "animal",
    "nature",
    "face"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, L5 = {
  keywords: [
    "animal",
    "nature",
    "wild"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, M5 = {
  keywords: [
    "animal",
    "nature",
    "panda"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, B5 = {
  keywords: [
    "animal",
    "nature"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, P5 = {
  keywords: [
    "animal",
    "cat",
    "danger",
    "wild",
    "nature",
    "roar"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, H5 = {
  keywords: [
    "animal",
    "nature"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, U5 = {
  keywords: [
    "beef",
    "ox",
    "animal",
    "nature",
    "moo",
    "milk"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, j5 = {
  keywords: [
    "animal",
    "oink",
    "nature"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, q5 = {
  keywords: [
    "animal",
    "oink"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, Y5 = {
  keywords: [
    "animal",
    "nature",
    "croak",
    "toad"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, V5 = {
  keywords: [
    "animal",
    "nature",
    "ocean",
    "sea"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, G5 = {
  keywords: [
    "animal",
    "creature",
    "ocean",
    "sea",
    "nature",
    "beach"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, W5 = {
  keywords: [
    "animal",
    "ocean",
    "nature",
    "seafood"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, $5 = {
  keywords: [
    "animal",
    "nature",
    "circus"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, X5 = {
  keywords: [
    "animal",
    "nature",
    "circus"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, Q5 = {
  keywords: [
    "monkey",
    "animal",
    "nature",
    "haha"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, K5 = {
  keywords: [
    "animal",
    "monkey",
    "nature"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, J5 = {
  keywords: [
    "monkey",
    "animal",
    "nature",
    "omg"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, Z5 = {
  keywords: [
    "animal",
    "nature",
    "banana",
    "circus"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, e7 = {
  keywords: [
    "animal",
    "cluck",
    "nature",
    "bird"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, t7 = {
  keywords: [
    "animal",
    "nature"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, a7 = {
  keywords: [
    "animal",
    "nature",
    "fly",
    "tweet",
    "spring"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, r7 = {
  keywords: [
    "animal",
    "chicken",
    "bird"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, n7 = {
  keywords: [
    "animal",
    "chicken",
    "egg",
    "born",
    "baby",
    "bird"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, s7 = {
  keywords: [
    "animal",
    "chicken",
    "baby",
    "bird"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, i7 = {
  keywords: [
    "animal",
    "nature",
    "bird",
    "mallard"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, o7 = {
  keywords: [
    "animal",
    "nature",
    "bird"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, c7 = {
  keywords: [
    "animal",
    "nature",
    "bird",
    "hoot"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, l7 = {
  keywords: [
    "animal",
    "nature",
    "blind",
    "vampire"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, u7 = {
  keywords: [
    "animal",
    "nature",
    "wild"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, f7 = {
  keywords: [
    "animal",
    "nature"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, h7 = {
  keywords: [
    "animal",
    "brown",
    "nature"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, d7 = {
  keywords: [
    "animal",
    "nature",
    "mystical"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, m7 = {
  keywords: [
    "animal",
    "insect",
    "nature",
    "bug",
    "spring",
    "honey"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, p7 = {
  keywords: [
    "animal",
    "insect",
    "nature",
    "worm"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, g7 = {
  keywords: [
    "animal",
    "insect",
    "nature",
    "caterpillar"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, y7 = {
  keywords: [
    "slow",
    "animal",
    "shell"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, _7 = {
  keywords: [
    "animal",
    "insect",
    "nature",
    "ladybug"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, b7 = {
  keywords: [
    "animal",
    "insect",
    "nature",
    "bug"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, k7 = {
  keywords: [
    "animal",
    "cricket",
    "chirp"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, w7 = {
  keywords: [
    "animal",
    "arachnid"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, E7 = {
  keywords: [
    "animal",
    "arachnid"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, T7 = {
  keywords: [
    "animal",
    "crustacean"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, v7 = {
  keywords: [
    "animal",
    "evil",
    "nature",
    "hiss",
    "python"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, x7 = {
  keywords: [
    "animal",
    "nature",
    "reptile"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, A7 = {
  keywords: [
    "animal",
    "nature",
    "dinosaur",
    "brachiosaurus",
    "brontosaurus",
    "diplodocus",
    "extinct"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, D7 = {
  keywords: [
    "animal",
    "slow",
    "nature",
    "tortoise"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, C7 = {
  keywords: [
    "animal",
    "swim",
    "ocean",
    "beach",
    "nemo"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, S7 = {
  keywords: [
    "animal",
    "food",
    "nature"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, z7 = {
  keywords: [
    "animal",
    "nature",
    "food",
    "sea",
    "ocean"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, N7 = {
  keywords: [
    "animal",
    "nature",
    "fish",
    "sea",
    "ocean",
    "flipper",
    "fins",
    "beach"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, I7 = {
  keywords: [
    "animal",
    "nature",
    "fish",
    "sea",
    "ocean",
    "jaws",
    "fins",
    "beach"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, R7 = {
  keywords: [
    "animal",
    "nature",
    "sea",
    "ocean"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, F7 = {
  keywords: [
    "animal",
    "nature",
    "sea",
    "ocean"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, O7 = {
  keywords: [
    "animal",
    "nature",
    "reptile",
    "lizard",
    "alligator"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, L7 = {
  keywords: [
    "animal",
    "nature"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, M7 = {
  keywords: [
    "animal",
    "nature",
    "stripes",
    "safari"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, B7 = {
  keywords: [
    "animal",
    "nature",
    "roar"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, P7 = {
  keywords: [
    "animal",
    "nature",
    "ox",
    "cow"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, H7 = {
  keywords: [
    "animal",
    "cow",
    "beef"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, U7 = {
  keywords: [
    "beef",
    "ox",
    "animal",
    "nature",
    "moo",
    "milk"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, j7 = {
  keywords: [
    "animal",
    "nature",
    "horns",
    "venison"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, q7 = {
  keywords: [
    "animal",
    "hot",
    "desert",
    "hump"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, Y7 = {
  keywords: [
    "animal",
    "nature",
    "hot",
    "desert",
    "hump"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, V7 = {
  keywords: [
    "animal",
    "nature",
    "spots",
    "safari"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, G7 = {
  keywords: [
    "animal",
    "nature",
    "nose",
    "th",
    "circus"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, W7 = {
  keywords: [
    "animal",
    "nature",
    "horn"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, $7 = {
  keywords: [
    "animal",
    "nature"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, X7 = {
  keywords: [
    "animal",
    "sheep",
    "nature"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, Q7 = {
  keywords: [
    "animal",
    "nature",
    "wool",
    "shipit"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, K7 = {
  keywords: [
    "animal",
    "gamble",
    "luck"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, J7 = {
  keywords: [
    "animal",
    "nature"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, Z7 = {
  keywords: [
    "animal",
    "mouse",
    "rodent"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, e8 = {
  keywords: [
    "animal",
    "nature",
    "rodent"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, t8 = {
  keywords: [
    "animal",
    "nature",
    "chicken"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, a8 = {
  keywords: [
    "animal",
    "bird"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, r8 = {
  keywords: [
    "animal",
    "bird"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, n8 = {
  keywords: [
    "animal",
    "nature",
    "friend",
    "doge",
    "pet",
    "faithful"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, s8 = {
  keywords: [
    "dog",
    "animal",
    "101",
    "nature",
    "pet"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, i8 = {
  keywords: [
    "animal",
    "meow",
    "pet",
    "cats"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, o8 = {
  keywords: [
    "animal",
    "nature",
    "pet",
    "magic",
    "spring"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, c8 = {
  keywords: [
    "animal",
    "nature",
    "rodent",
    "squirrel"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, l8 = {
  keywords: [
    "animal",
    "nature",
    "spiny"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, u8 = {
  keywords: [
    "animal",
    "nature"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, f8 = {
  keywords: [
    "animal",
    "nature",
    "alpaca"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, h8 = {
  keywords: [
    "animal",
    "nature"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, d8 = {
  keywords: [
    "animal",
    "nature",
    "australia",
    "joey",
    "hop",
    "marsupial"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, m8 = {
  keywords: [
    "animal",
    "nature",
    "honey"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, p8 = {
  keywords: [
    "animal",
    "nature",
    "bird"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, g8 = {
  keywords: [
    "animal",
    "nature",
    "peahen",
    "bird"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, y8 = {
  keywords: [
    "animal",
    "nature",
    "bird",
    "pirate",
    "talk"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, _8 = {
  keywords: [
    "animal",
    "nature",
    "bisque",
    "claws",
    "seafood"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, b8 = {
  keywords: [
    "animal",
    "nature",
    "insect",
    "malaria"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, k8 = {
  keywords: [
    "animal",
    "tracking",
    "footprints",
    "dog",
    "cat",
    "pet",
    "feet"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, w8 = {
  keywords: [
    "animal",
    "myth",
    "nature",
    "chinese",
    "green"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, E8 = {
  keywords: [
    "animal",
    "myth",
    "nature",
    "chinese",
    "green"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, T8 = {
  keywords: [
    "vegetable",
    "plant",
    "nature"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, v8 = {
  keywords: [
    "festival",
    "vacation",
    "december",
    "xmas",
    "celebration"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, x8 = {
  keywords: [
    "plant",
    "nature"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, A8 = {
  keywords: [
    "plant",
    "nature"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, D8 = {
  keywords: [
    "plant",
    "vegetable",
    "nature",
    "summer",
    "beach",
    "mojito",
    "tropical"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, C8 = {
  keywords: [
    "plant",
    "nature",
    "grass",
    "lawn",
    "spring"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, S8 = {
  keywords: [
    "vegetable",
    "plant",
    "medicine",
    "weed",
    "grass",
    "lawn"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, z8 = {
  keywords: [
    "vegetable",
    "plant",
    "nature",
    "irish",
    "clover"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, N8 = {
  keywords: [
    "vegetable",
    "plant",
    "nature",
    "lucky",
    "irish"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, I8 = {
  keywords: [
    "plant",
    "nature",
    "vegetable",
    "panda",
    "pine_decoration"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, R8 = {
  keywords: [
    "plant",
    "nature",
    "branch",
    "summer"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, F8 = {
  keywords: [
    "nature",
    "plant",
    "tree",
    "vegetable",
    "grass",
    "lawn",
    "spring"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, O8 = {
  keywords: [
    "nature",
    "plant",
    "vegetable",
    "leaves"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, L8 = {
  keywords: [
    "nature",
    "plant",
    "vegetable",
    "ca",
    "fall"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, M8 = {
  keywords: [
    "nature",
    "plant"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, B8 = {
  keywords: [
    "plant",
    "vegetable",
    "flowers",
    "beach"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, P8 = {
  keywords: [
    "nature",
    "plant",
    "fall"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, H8 = {
  keywords: [
    "flowers",
    "valentines",
    "love",
    "spring"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, U8 = {
  keywords: [
    "plant",
    "nature",
    "flower"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, j8 = {
  keywords: [
    "flowers",
    "plant",
    "nature",
    "summer",
    "spring"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, q8 = {
  keywords: [
    "nature",
    "flowers",
    "yellow"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, Y8 = {
  keywords: [
    "nature",
    "plant",
    "spring",
    "flower"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, V8 = {
  keywords: [
    "flowers",
    "nature",
    "spring"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, G8 = {
  keywords: [
    "plant",
    "vegetable"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, W8 = {
  keywords: [
    "food",
    "squirrel"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, $8 = {
  keywords: [
    "halloween",
    "light",
    "pumpkin",
    "creepy",
    "fall"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, X8 = {
  keywords: [
    "nature",
    "sea",
    "beach"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, Q8 = {
  keywords: [
    "animal",
    "insect",
    "arachnid",
    "silk"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, K8 = {
  keywords: [
    "globe",
    "world",
    "USA",
    "international"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, J8 = {
  keywords: [
    "globe",
    "world",
    "international"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, Z8 = {
  keywords: [
    "globe",
    "world",
    "east",
    "international"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, ew = {
  keywords: [
    "nature",
    "yellow",
    "twilight",
    "planet",
    "space",
    "night",
    "evening",
    "sleep"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, tw = {
  keywords: [
    "nature",
    "twilight",
    "planet",
    "space",
    "night",
    "evening",
    "sleep",
    "waxing_gibbous_moon"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, aw = {
  keywords: [
    "nature",
    "twilight",
    "planet",
    "space",
    "night",
    "evening",
    "sleep"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, rw = {
  keywords: [
    "nature",
    "twilight",
    "planet",
    "space",
    "night",
    "evening",
    "sleep"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, nw = {
  keywords: [
    "nature",
    "twilight",
    "planet",
    "space",
    "night",
    "evening",
    "sleep"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, sw = {
  keywords: [
    "nature",
    "twilight",
    "planet",
    "space",
    "night",
    "evening",
    "sleep"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, iw = {
  keywords: [
    "nature",
    "twilight",
    "planet",
    "space",
    "night",
    "evening",
    "sleep"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, ow = {
  keywords: [
    "nature",
    "night",
    "sky",
    "gray",
    "twilight",
    "planet",
    "space",
    "evening",
    "sleep"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, cw = {
  keywords: [
    "nature",
    "twilight",
    "planet",
    "space",
    "night",
    "evening",
    "sleep"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, lw = {
  keywords: [
    "nature",
    "twilight",
    "planet",
    "space",
    "night",
    "evening",
    "sleep"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, uw = {
  keywords: [
    "nature",
    "twilight",
    "planet",
    "space",
    "night",
    "evening",
    "sleep"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, fw = {
  keywords: [
    "nature",
    "twilight",
    "planet",
    "space",
    "night",
    "evening",
    "sleep"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, hw = {
  keywords: [
    "nature",
    "morning",
    "sky"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, dw = {
  keywords: [
    "night",
    "sleep",
    "sky",
    "evening",
    "magic"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, mw = {
  keywords: [
    "night",
    "yellow"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, pw = {
  keywords: [
    "night",
    "sparkle",
    "awesome",
    "good",
    "magic"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, gw = {
  keywords: [
    "star",
    "sparkle",
    "shoot",
    "magic"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, yw = {
  keywords: [
    "stars",
    "shine",
    "shiny",
    "cool",
    "awesome",
    "good",
    "magic"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, _w = {
  keywords: [
    "space"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, bw = {
  keywords: [
    "weather",
    "nature",
    "brightness",
    "summer",
    "beach",
    "spring"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, kw = {
  keywords: [
    "weather"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, ww = {
  keywords: [
    "weather",
    "nature",
    "cloudy",
    "morning",
    "fall",
    "spring"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, Ew = {
  keywords: [
    "weather"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, Tw = {
  keywords: [
    "weather"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, vw = {
  keywords: [
    "weather",
    "sky"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, xw = {
  keywords: [
    "weather"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, Aw = {
  keywords: [
    "weather",
    "lightning"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, Dw = {
  keywords: [
    "weather",
    "thunder"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, Cw = {
  keywords: [
    "thunder",
    "weather",
    "lightning bolt",
    "fast"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, Sw = {
  keywords: [
    "hot",
    "cook",
    "flame"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, zw = {
  keywords: [
    "bomb",
    "explode",
    "explosion",
    "collision",
    "blown"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, Nw = {
  keywords: [
    "winter",
    "season",
    "cold",
    "weather",
    "christmas",
    "xmas"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, Iw = {
  keywords: [
    "weather"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, Rw = {
  keywords: [
    "winter",
    "season",
    "cold",
    "weather",
    "christmas",
    "xmas",
    "frozen",
    "without_snow"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, Fw = {
  keywords: [
    "winter",
    "season",
    "cold",
    "weather",
    "christmas",
    "xmas",
    "frozen"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, Ow = {
  keywords: [
    "gust",
    "air"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, Lw = {
  keywords: [
    "wind",
    "air",
    "fast",
    "shoo",
    "fart",
    "smoke",
    "puff"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, Mw = {
  keywords: [
    "weather",
    "cyclone",
    "twister"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, Bw = {
  keywords: [
    "weather"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, Pw = {
  keywords: [
    "weather",
    "spring"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, Hw = {
  keywords: [
    "rainy",
    "weather",
    "spring"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, Uw = {
  keywords: [
    "water",
    "drip",
    "faucet",
    "spring"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, jw = {
  keywords: [
    "water",
    "drip",
    "oops"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, qw = {
  keywords: [
    "sea",
    "water",
    "wave",
    "nature",
    "tsunami",
    "disaster"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "animals_and_nature"
}, Yw = {
  keywords: [
    "fruit",
    "nature"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, Vw = {
  keywords: [
    "fruit",
    "mac",
    "school"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, Gw = {
  keywords: [
    "fruit",
    "nature",
    "food"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, Ww = {
  keywords: [
    "food",
    "fruit",
    "nature",
    "orange"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, $w = {
  keywords: [
    "fruit",
    "nature"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, Xw = {
  keywords: [
    "fruit",
    "food",
    "monkey"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, Qw = {
  keywords: [
    "fruit",
    "food",
    "picnic",
    "summer"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, Kw = {
  keywords: [
    "fruit",
    "food",
    "wine"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, Jw = {
  keywords: [
    "fruit",
    "food",
    "nature"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, Zw = {
  keywords: [
    "fruit",
    "nature",
    "food"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, e9 = {
  keywords: [
    "food",
    "fruit"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, t9 = {
  keywords: [
    "fruit",
    "nature",
    "food"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, a9 = {
  keywords: [
    "fruit",
    "nature",
    "food"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, r9 = {
  keywords: [
    "fruit",
    "nature",
    "food",
    "palm"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, n9 = {
  keywords: [
    "fruit",
    "food"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, s9 = {
  keywords: [
    "fruit",
    "food",
    "tropical"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, i9 = {
  keywords: [
    "fruit",
    "food"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, o9 = {
  keywords: [
    "fruit",
    "food",
    "vegetable"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, c9 = {
  keywords: [
    "fruit",
    "vegetable",
    "nature",
    "food"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, l9 = {
  keywords: [
    "vegetable",
    "nature",
    "food",
    "aubergine"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, u9 = {
  keywords: [
    "fruit",
    "food",
    "pickle"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, f9 = {
  keywords: [
    "vegetable",
    "food",
    "orange"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, h9 = {
  keywords: [
    "food",
    "spicy",
    "chilli",
    "chili"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, d9 = {
  keywords: [
    "food",
    "tuber",
    "vegatable",
    "starch"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, m9 = {
  keywords: [
    "food",
    "vegetable",
    "plant"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, p9 = {
  keywords: [
    "food",
    "vegetable",
    "plant",
    "bok choy",
    "cabbage",
    "kale",
    "lettuce"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, g9 = {
  keywords: [
    "food",
    "nature"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, y9 = {
  keywords: [
    "food",
    "nut"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, _9 = {
  keywords: [
    "bees",
    "sweet",
    "kitchen"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, b9 = {
  keywords: [
    "food",
    "bread",
    "french"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, k9 = {
  keywords: [
    "food",
    "wheat",
    "breakfast",
    "toast"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, w9 = {
  keywords: [
    "food",
    "bread",
    "french"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, E9 = {
  keywords: [
    "food",
    "bread",
    "bakery",
    "schmear"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, T9 = {
  keywords: [
    "food",
    "bread",
    "twisted"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, v9 = {
  keywords: [
    "food",
    "chadder"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, x9 = {
  keywords: [
    "food",
    "chicken",
    "breakfast"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, A9 = {
  keywords: [
    "food",
    "breakfast",
    "pork",
    "pig",
    "meat"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, D9 = {
  keywords: [
    "food",
    "cow",
    "meat",
    "cut",
    "chop",
    "lambchop",
    "porkchop"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, C9 = {
  keywords: [
    "food",
    "breakfast",
    "flapjacks",
    "hotcakes"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, S9 = {
  keywords: [
    "food",
    "meat",
    "drumstick",
    "bird",
    "chicken",
    "turkey"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, z9 = {
  keywords: [
    "good",
    "food",
    "drumstick"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, N9 = {
  keywords: [
    "skeleton"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, I9 = {
  keywords: [
    "food",
    "animal",
    "appetizer",
    "summer"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, R9 = {
  keywords: [
    "food",
    "breakfast",
    "kitchen",
    "egg"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, F9 = {
  keywords: [
    "meat",
    "fast food",
    "beef",
    "cheeseburger",
    "mcdonalds",
    "burger king"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, O9 = {
  keywords: [
    "chips",
    "snack",
    "fast food"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, L9 = {
  keywords: [
    "food",
    "flatbread",
    "stuffed",
    "gyro"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, M9 = {
  keywords: [
    "food",
    "frankfurter"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, B9 = {
  keywords: [
    "food",
    "party"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, P9 = {
  keywords: [
    "food",
    "lunch",
    "bread"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, H9 = {
  keywords: [
    "food",
    "soup"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, U9 = {
  keywords: [
    "food",
    "italian",
    "noodle"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, j9 = {
  keywords: [
    "food",
    "mexican"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, q9 = {
  keywords: [
    "food",
    "mexican"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, Y9 = {
  keywords: [
    "food",
    "healthy",
    "lettuce"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, V9 = {
  keywords: [
    "food",
    "cooking",
    "casserole",
    "paella"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, G9 = {
  keywords: [
    "food",
    "japanese",
    "noodle",
    "chopsticks"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, W9 = {
  keywords: [
    "food",
    "meat",
    "soup"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, $9 = {
  keywords: [
    "food",
    "japan",
    "sea",
    "beach",
    "narutomaki",
    "pink",
    "swirl",
    "kamaboko",
    "surimi",
    "ramen"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, X9 = {
  keywords: [
    "food",
    "prophecy"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, Q9 = {
  keywords: [
    "food",
    "fish",
    "japanese",
    "rice"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, K9 = {
  keywords: [
    "food",
    "japanese",
    "box"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, J9 = {
  keywords: [
    "food",
    "spicy",
    "hot",
    "indian"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, Z9 = {
  keywords: [
    "food",
    "japanese"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, eE = {
  keywords: [
    "food",
    "china",
    "asian"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, tE = {
  keywords: [
    "food",
    "japanese"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, aE = {
  keywords: [
    "food",
    "japanese"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, rE = {
  keywords: [
    "food",
    "dessert",
    "sweet",
    "japanese",
    "barbecue",
    "meat"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, nE = {
  keywords: [
    "hot",
    "dessert",
    "summer"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, sE = {
  keywords: [
    "food",
    "hot",
    "dessert"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, iE = {
  keywords: [
    "food",
    "hot",
    "dessert",
    "summer"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, oE = {
  keywords: [
    "food",
    "dessert",
    "pastry"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, cE = {
  keywords: [
    "food",
    "dessert"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, lE = {
  keywords: [
    "food",
    "dessert",
    "bakery",
    "sweet"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, uE = {
  keywords: [
    "food",
    "autumn"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, fE = {
  keywords: [
    "food",
    "dessert",
    "cake"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, hE = {
  keywords: [
    "dessert",
    "food"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, dE = {
  keywords: [
    "snack",
    "dessert",
    "sweet",
    "lolly"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, mE = {
  keywords: [
    "food",
    "snack",
    "candy",
    "sweet"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, pE = {
  keywords: [
    "food",
    "snack",
    "dessert",
    "sweet"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, gE = {
  keywords: [
    "food",
    "movie theater",
    "films",
    "snack"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, yE = {
  keywords: [
    "food",
    "empanada",
    "pierogi",
    "potsticker"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, _E = {
  keywords: [
    "food",
    "dessert",
    "snack",
    "sweet",
    "donut"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, bE = {
  keywords: [
    "food",
    "snack",
    "oreo",
    "chocolate",
    "sweet",
    "dessert"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, kE = {
  keywords: [
    "beverage",
    "drink",
    "cow"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, wE = {
  keywords: [
    "relax",
    "beverage",
    "drink",
    "drunk",
    "party",
    "pub",
    "summer",
    "alcohol",
    "booze"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, EE = {
  keywords: [
    "relax",
    "beverage",
    "drink",
    "drunk",
    "party",
    "pub",
    "summer",
    "alcohol",
    "booze"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, TE = {
  keywords: [
    "beverage",
    "drink",
    "party",
    "alcohol",
    "celebrate",
    "cheers",
    "wine",
    "champagne",
    "toast"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, vE = {
  keywords: [
    "drink",
    "beverage",
    "drunk",
    "alcohol",
    "booze"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, xE = {
  keywords: [
    "drink",
    "beverage",
    "drunk",
    "alcohol",
    "liquor",
    "booze",
    "bourbon",
    "scotch",
    "whisky",
    "glass",
    "shot"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, AE = {
  keywords: [
    "drink",
    "drunk",
    "alcohol",
    "beverage",
    "booze",
    "mojito"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, DE = {
  keywords: [
    "beverage",
    "cocktail",
    "summer",
    "beach",
    "alcohol",
    "booze",
    "mojito"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, CE = {
  keywords: [
    "drink",
    "wine",
    "bottle",
    "celebration"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, SE = {
  keywords: [
    "wine",
    "drink",
    "drunk",
    "beverage",
    "japanese",
    "alcohol",
    "booze"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, zE = {
  keywords: [
    "drink",
    "bowl",
    "breakfast",
    "green",
    "british"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, NE = {
  keywords: [
    "drink",
    "soda"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, IE = {
  keywords: [
    "beverage",
    "caffeine",
    "latte",
    "espresso"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, RE = {
  keywords: [
    "food",
    "container",
    "milk"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, FE = {
  keywords: [
    "condiment",
    "shaker"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, OE = {
  keywords: [
    "cutlery",
    "kitchen",
    "tableware"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, LE = {
  keywords: [
    "cutlery",
    "kitchen"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, ME = {
  keywords: [
    "food",
    "eat",
    "meal",
    "lunch",
    "dinner",
    "restaurant"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, BE = {
  keywords: [
    "food",
    "breakfast",
    "cereal",
    "oatmeal",
    "porridge"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, PE = {
  keywords: [
    "food",
    "leftovers"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, HE = {
  keywords: [
    "food"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "food_and_drink"
}, UE = {
  keywords: [
    "sports",
    "football"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, jE = {
  keywords: [
    "sports",
    "balls",
    "NBA"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, qE = {
  keywords: [
    "sports",
    "balls",
    "NFL"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, YE = {
  keywords: [
    "sports",
    "balls"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, VE = {
  keywords: [
    "sports",
    "balls"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, GE = {
  keywords: [
    "sports",
    "balls",
    "green"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, WE = {
  keywords: [
    "sports",
    "balls"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, $E = {
  keywords: [
    "sports",
    "team"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, XE = {
  keywords: [
    "sports",
    "frisbee",
    "ultimate"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, QE = {
  keywords: [
    "sports",
    "business",
    "flag",
    "hole",
    "summer"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, KE = {
  keywords: [
    "sports",
    "business",
    "woman",
    "female"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, JE = {
  keywords: [
    "sports",
    "business"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "activity"
}, ZE = {
  keywords: [
    "sports",
    "pingpong"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, eT = {
  keywords: [
    "sports"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, tT = {
  keywords: [
    "sports"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, aT = {
  keywords: [
    "sports"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, rT = {
  keywords: [
    "sports"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, nT = {
  keywords: [
    "sports",
    "ball",
    "stick"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, sT = {
  keywords: [
    "sports"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, iT = {
  keywords: [
    "sports",
    "winter",
    "cold",
    "snow"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, oT = {
  keywords: [
    "sports",
    "winter",
    "snow"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, cT = {
  keywords: [
    "sports",
    "winter"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "activity"
}, lT = {
  keywords: [
    "sports",
    "fencing",
    "sword"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, uT = {
  keywords: [
    "sports",
    "wrestlers"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, fT = {
  keywords: [
    "sports",
    "wrestlers"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, hT = {
  keywords: [
    "gymnastics"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "activity"
}, dT = {
  keywords: [
    "gymnastics"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "activity"
}, mT = {
  keywords: [
    "sports"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "activity"
}, pT = {
  keywords: [
    "sports"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "activity"
}, gT = {
  keywords: [
    "sports"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, yT = {
  keywords: [
    "sports"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, _T = {
  keywords: [
    "board"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, bT = {
  keywords: [
    "sleigh",
    "luge",
    "toboggan"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, kT = {
  keywords: [
    "sports"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, wT = {
  keywords: [
    "food",
    "hobby",
    "summer"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, ET = {
  keywords: [
    "sports",
    "fighting"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, TT = {
  keywords: [
    "judo",
    "karate",
    "taekwondo"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, vT = {
  keywords: [
    "sports",
    "hobby",
    "water",
    "ship",
    "woman",
    "female"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "activity"
}, xT = {
  keywords: [
    "sports",
    "hobby",
    "water",
    "ship"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "activity"
}, AT = {
  keywords: [
    "sports",
    "hobby",
    "woman",
    "female",
    "rock"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "activity"
}, DT = {
  keywords: [
    "sports",
    "hobby",
    "man",
    "male",
    "rock"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "activity"
}, CT = {
  keywords: [
    "sports",
    "exercise",
    "human",
    "athlete",
    "water",
    "summer",
    "woman",
    "female"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "activity"
}, ST = {
  keywords: [
    "sports",
    "exercise",
    "human",
    "athlete",
    "water",
    "summer"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "activity"
}, zT = {
  keywords: [
    "sports",
    "pool"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "activity"
}, NT = {
  keywords: [
    "sports",
    "pool"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "activity"
}, IT = {
  keywords: [
    "woman",
    "female",
    "meditation",
    "yoga",
    "serenity",
    "zen",
    "mindfulness"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "activity"
}, RT = {
  keywords: [
    "man",
    "male",
    "meditation",
    "yoga",
    "serenity",
    "zen",
    "mindfulness"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "activity"
}, FT = {
  keywords: [
    "sports",
    "ocean",
    "sea",
    "summer",
    "beach",
    "woman",
    "female"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "activity"
}, OT = {
  keywords: [
    "sports",
    "ocean",
    "sea",
    "summer",
    "beach"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "activity"
}, LT = {
  keywords: [
    "clean",
    "shower",
    "bathroom"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "activity"
}, MT = {
  keywords: [
    "sports",
    "human",
    "woman",
    "female"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "activity"
}, BT = {
  keywords: [
    "sports",
    "human"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "activity"
}, PT = {
  keywords: [
    "sports",
    "training",
    "exercise",
    "woman",
    "female"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "activity"
}, HT = {
  keywords: [
    "sports",
    "training",
    "exercise"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "activity"
}, UT = {
  keywords: [
    "sports",
    "bike",
    "exercise",
    "hipster",
    "woman",
    "female"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "activity"
}, jT = {
  keywords: [
    "sports",
    "bike",
    "exercise",
    "hipster"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "activity"
}, qT = {
  keywords: [
    "transportation",
    "sports",
    "human",
    "race",
    "bike",
    "woman",
    "female"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "activity"
}, YT = {
  keywords: [
    "transportation",
    "sports",
    "human",
    "race",
    "bike"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "activity"
}, VT = {
  keywords: [
    "animal",
    "betting",
    "competition",
    "gambling",
    "luck"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "activity"
}, GT = {
  keywords: [
    "suit",
    "business",
    "levitate",
    "hover",
    "jump"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "activity"
}, WT = {
  keywords: [
    "win",
    "award",
    "contest",
    "place",
    "ftw",
    "ceremony"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, $T = {
  keywords: [
    "play",
    "pageant"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, XT = {
  keywords: [
    "award",
    "winning"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, QT = {
  keywords: [
    "award",
    "winning",
    "army"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, KT = {
  keywords: [
    "sports",
    "cause",
    "support",
    "awareness"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, JT = {
  keywords: [
    "flower",
    "decoration",
    "military"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, ZT = {
  keywords: [
    "event",
    "concert",
    "pass"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, ev = {
  keywords: [
    "sports",
    "concert",
    "entrance"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, tv = {
  keywords: [
    "acting",
    "theater",
    "drama"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, av = {
  keywords: [
    "design",
    "paint",
    "draw",
    "colors"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, rv = {
  keywords: [
    "festival",
    "carnival",
    "party"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, nv = {
  keywords: [
    "juggle",
    "balance",
    "skill",
    "multitask"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "activity"
}, sv = {
  keywords: [
    "juggle",
    "balance",
    "skill",
    "multitask"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "activity"
}, iv = {
  keywords: [
    "sound",
    "music",
    "PA",
    "sing",
    "talkshow"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, ov = {
  keywords: [
    "music",
    "score",
    "gadgets"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, cv = {
  keywords: [
    "treble",
    "clef",
    "compose"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, lv = {
  keywords: [
    "piano",
    "instrument",
    "compose"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, uv = {
  keywords: [
    "music",
    "instrument",
    "drumsticks",
    "snare"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, fv = {
  keywords: [
    "music",
    "instrument",
    "jazz",
    "blues"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, hv = {
  keywords: [
    "music",
    "brass"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, dv = {
  keywords: [
    "music",
    "instrument"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, mv = {
  keywords: [
    "music",
    "instrument",
    "orchestra",
    "symphony"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, pv = {
  keywords: [
    "movie",
    "film",
    "record"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, gv = {
  keywords: [
    "play",
    "console",
    "PS4",
    "controller"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, yv = {
  keywords: [
    "game",
    "arcade",
    "play"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, _v = {
  keywords: [
    "game",
    "play",
    "bar",
    "target",
    "bullseye"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, bv = {
  keywords: [
    "dice",
    "random",
    "tabletop",
    "play",
    "luck"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, kv = {
  keywords: [
    "expendable"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, wv = {
  keywords: [
    "bet",
    "gamble",
    "vegas",
    "fruit machine",
    "luck",
    "casino"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, Ev = {
  keywords: [
    "interlocking",
    "puzzle",
    "piece"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, Tv = {
  keywords: [
    "sports",
    "fun",
    "play"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "activity"
}, vv = {
  keywords: [
    "red",
    "transportation",
    "vehicle"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, xv = {
  keywords: [
    "uber",
    "vehicle",
    "cars",
    "transportation"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Av = {
  keywords: [
    "transportation",
    "vehicle"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Dv = {
  keywords: [
    "car",
    "vehicle",
    "transportation"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Cv = {
  keywords: [
    "bart",
    "transportation",
    "vehicle"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Sv = {
  keywords: [
    "sports",
    "race",
    "fast",
    "formula",
    "f1"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, zv = {
  keywords: [
    "vehicle",
    "cars",
    "transportation",
    "law",
    "legal",
    "enforcement"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Nv = {
  keywords: [
    "health",
    "911",
    "hospital"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Iv = {
  keywords: [
    "transportation",
    "cars",
    "vehicle"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Rv = {
  keywords: [
    "vehicle",
    "car",
    "transportation"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Fv = {
  keywords: [
    "cars",
    "transportation"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Ov = {
  keywords: [
    "vehicle",
    "cars",
    "transportation",
    "express"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Lv = {
  keywords: [
    "vehicle",
    "car",
    "farming",
    "agriculture"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Mv = {
  keywords: [
    "vehicle",
    "kick",
    "razor"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Bv = {
  keywords: [
    "race",
    "sports",
    "fast"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Pv = {
  keywords: [
    "sports",
    "bicycle",
    "exercise",
    "hipster"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Hv = {
  keywords: [
    "vehicle",
    "vespa",
    "sasha"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Uv = {
  keywords: [
    "police",
    "ambulance",
    "911",
    "emergency",
    "alert",
    "error",
    "pinged",
    "law",
    "legal"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, jv = {
  keywords: [
    "vehicle",
    "law",
    "legal",
    "enforcement",
    "911"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, qv = {
  keywords: [
    "vehicle",
    "transportation"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Yv = {
  keywords: [
    "car",
    "vehicle",
    "transportation"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Vv = {
  keywords: [
    "vehicle",
    "cars",
    "uber"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Gv = {
  keywords: [
    "transportation",
    "vehicle",
    "ski"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Wv = {
  keywords: [
    "transportation",
    "vehicle",
    "ski"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, $v = {
  keywords: [
    "vehicle",
    "transportation"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Xv = {
  keywords: [
    "transportation",
    "vehicle"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Qv = {
  keywords: [
    "transportation",
    "vehicle",
    "carriage",
    "public",
    "travel"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Kv = {
  keywords: [
    "transportation",
    "vehicle"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Jv = {
  keywords: [
    "transportation",
    "vehicle"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Zv = {
  keywords: [
    "transportation",
    "vehicle",
    "speed",
    "fast",
    "public",
    "travel"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, ex = {
  keywords: [
    "transportation",
    "vehicle"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, tx = {
  keywords: [
    "transportation",
    "vehicle"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, ax = {
  keywords: [
    "transportation",
    "vehicle",
    "train"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, rx = {
  keywords: [
    "transportation",
    "vehicle"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, nx = {
  keywords: [
    "transportation",
    "blue-square",
    "mrt",
    "underground",
    "tube"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, sx = {
  keywords: [
    "transportation",
    "vehicle"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, ix = {
  keywords: [
    "transportation",
    "vehicle",
    "public"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, ox = {
  keywords: [
    "transportation",
    "vehicle",
    "ufo"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, cx = {
  keywords: [
    "transportation",
    "vehicle",
    "fly"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, lx = {
  keywords: [
    "flight",
    "transportation",
    "fly",
    "vehicle"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, ux = {
  keywords: [
    "vehicle",
    "transportation",
    "flight",
    "fly"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, fx = {
  keywords: [
    "airport",
    "flight",
    "landing"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, hx = {
  keywords: [
    "airport",
    "flight",
    "boarding"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, dx = {
  keywords: [
    "ship",
    "summer",
    "transportation",
    "water",
    "sailing"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, mx = {
  keywords: [
    "ship"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, px = {
  keywords: [
    "ship",
    "transportation",
    "vehicle",
    "summer"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, gx = {
  keywords: [
    "boat",
    "ship",
    "yacht"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, yx = {
  keywords: [
    "yacht",
    "cruise",
    "ferry"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, _x = {
  keywords: [
    "launch",
    "ship",
    "staffmode",
    "NASA",
    "outer space",
    "outer_space",
    "fly"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, bx = {
  keywords: [
    "communication",
    "gps",
    "orbit",
    "spaceflight",
    "NASA",
    "ISS"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, kx = {
  keywords: [
    "sit",
    "airplane",
    "transport",
    "bus",
    "flight",
    "fly"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, wx = {
  keywords: [
    "boat",
    "paddle",
    "water",
    "ship"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Ex = {
  keywords: [
    "ship",
    "ferry",
    "sea",
    "boat"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Tx = {
  keywords: [
    "wip",
    "progress",
    "caution",
    "warning"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, vx = {
  keywords: [
    "gas station",
    "petroleum"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, xx = {
  keywords: [
    "transportation",
    "wait"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Ax = {
  keywords: [
    "transportation",
    "driving"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Dx = {
  keywords: [
    "transportation",
    "signal"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Cx = {
  keywords: [
    "contest",
    "finishline",
    "race",
    "gokart"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Sx = {
  keywords: [
    "transportation",
    "titanic",
    "deploy"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, zx = {
  keywords: [
    "photo",
    "carnival",
    "londoneye"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Nx = {
  keywords: [
    "carnival",
    "playground",
    "photo",
    "fun"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Ix = {
  keywords: [
    "photo",
    "carnival"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Rx = {
  keywords: [
    "wip",
    "working",
    "progress"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Fx = {
  keywords: [
    "photo",
    "mountain"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Ox = {
  keywords: [
    "photo",
    "japanese"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Lx = {
  keywords: [
    "building",
    "industry",
    "pollution",
    "smoke"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Mx = {
  keywords: [
    "photo",
    "summer",
    "water",
    "fresh"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Bx = {
  keywords: [
    "photo",
    "japan",
    "asia",
    "tsukimi"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Px = {
  keywords: [
    "photo",
    "nature",
    "environment"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Hx = {
  keywords: [
    "photo",
    "nature",
    "environment",
    "winter",
    "cold"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Ux = {
  keywords: [
    "photo",
    "mountain",
    "nature",
    "japanese"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, jx = {
  keywords: [
    "photo",
    "nature",
    "disaster"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, qx = {
  keywords: [
    "nation",
    "country",
    "japanese",
    "asia"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Yx = {
  keywords: [
    "photo",
    "outdoors",
    "tent"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Vx = {
  keywords: [
    "photo",
    "camping",
    "outdoors"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Gx = {
  keywords: [
    "photo",
    "environment",
    "nature"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Wx = {
  keywords: [
    "road",
    "cupertino",
    "interstate",
    "highway"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, $x = {
  keywords: [
    "train",
    "transportation"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Xx = {
  keywords: [
    "morning",
    "view",
    "vacation",
    "photo"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Qx = {
  keywords: [
    "view",
    "vacation",
    "photo"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Kx = {
  keywords: [
    "photo",
    "warm",
    "saharah"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Jx = {
  keywords: [
    "weather",
    "summer",
    "sunny",
    "sand",
    "mojito"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, Zx = {
  keywords: [
    "photo",
    "tropical",
    "mojito"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, eA = {
  keywords: [
    "photo",
    "good morning",
    "dawn"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, tA = {
  keywords: [
    "photo",
    "evening",
    "sky",
    "buildings"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, aA = {
  keywords: [
    "photo",
    "night life",
    "urban"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, rA = {
  keywords: [
    "evening",
    "city",
    "downtown"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, nA = {
  keywords: [
    "photo",
    "sanfrancisco"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, sA = {
  keywords: [
    "photo",
    "space",
    "stars"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, iA = {
  keywords: [
    "night",
    "photo"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, oA = {
  keywords: [
    "stars",
    "night",
    "shine"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, cA = {
  keywords: [
    "photo",
    "festival",
    "carnival",
    "congratulations"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, lA = {
  keywords: [
    "nature",
    "happy",
    "unicorn_face",
    "photo",
    "sky",
    "spring"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, uA = {
  keywords: [
    "buildings",
    "photo"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, fA = {
  keywords: [
    "building",
    "royalty",
    "history"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, hA = {
  keywords: [
    "photo",
    "building"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, dA = {
  keywords: [
    "photo",
    "place",
    "sports",
    "concert",
    "venue"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, mA = {
  keywords: [
    "american",
    "newyork"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, pA = {
  keywords: [
    "building",
    "home"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, gA = {
  keywords: [
    "home",
    "plant",
    "nature"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, yA = {
  keywords: [
    "abandon",
    "evict",
    "broken",
    "building"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, _A = {
  keywords: [
    "building",
    "bureau",
    "work"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, bA = {
  keywords: [
    "building",
    "shopping",
    "mall"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, kA = {
  keywords: [
    "building",
    "envelope",
    "communication"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, wA = {
  keywords: [
    "building",
    "email"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, EA = {
  keywords: [
    "building",
    "health",
    "surgery",
    "doctor"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, TA = {
  keywords: [
    "building",
    "money",
    "sales",
    "cash",
    "business",
    "enterprise"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, vA = {
  keywords: [
    "building",
    "accomodation",
    "checkin"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, xA = {
  keywords: [
    "building",
    "shopping",
    "groceries"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, AA = {
  keywords: [
    "building",
    "student",
    "education",
    "learn",
    "teach"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, DA = {
  keywords: [
    "like",
    "affection",
    "dating"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, CA = {
  keywords: [
    "love",
    "like",
    "affection",
    "couple",
    "marriage",
    "bride",
    "groom"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, SA = {
  keywords: [
    "art",
    "culture",
    "history"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, zA = {
  keywords: [
    "building",
    "religion",
    "christ"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, NA = {
  keywords: [
    "islam",
    "worship",
    "minaret"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, IA = {
  keywords: [
    "judaism",
    "worship",
    "temple",
    "jewish"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, RA = {
  keywords: [
    "mecca",
    "mosque",
    "islam"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, FA = {
  keywords: [
    "temple",
    "japan",
    "kyoto"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "travel_and_places"
}, OA = {
  keywords: [
    "time",
    "accessories"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, LA = {
  keywords: [
    "technology",
    "apple",
    "gadgets",
    "dial"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, MA = {
  keywords: [
    "iphone",
    "incoming"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, BA = {
  keywords: [
    "technology",
    "laptop",
    "screen",
    "display",
    "monitor"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, PA = {
  keywords: [
    "technology",
    "computer",
    "type",
    "input",
    "text"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, HA = {
  keywords: [
    "technology",
    "computing",
    "screen"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, UA = {
  keywords: [
    "paper",
    "ink"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, jA = {
  keywords: [
    "click"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, qA = {
  keywords: [
    "technology",
    "trackpad"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, YA = {
  keywords: [
    "game",
    "play"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, VA = {
  keywords: [
    "tool"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, GA = {
  keywords: [
    "technology",
    "record",
    "data",
    "disk",
    "90s"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, WA = {
  keywords: [
    "oldschool",
    "technology",
    "save",
    "90s",
    "80s"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, $A = {
  keywords: [
    "technology",
    "dvd",
    "disk",
    "disc",
    "90s"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, XA = {
  keywords: [
    "cd",
    "disk",
    "disc"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, QA = {
  keywords: [
    "record",
    "video",
    "oldschool",
    "90s",
    "80s"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, KA = {
  keywords: [
    "gadgets",
    "photography"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, JA = {
  keywords: [
    "photography",
    "gadgets"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, ZA = {
  keywords: [
    "film",
    "record"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, eD = {
  keywords: [
    "film",
    "record"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, tD = {
  keywords: [
    "video",
    "tape",
    "record",
    "movie"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, aD = {
  keywords: [
    "movie"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, rD = {
  keywords: [
    "technology",
    "communication",
    "dial"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, nD = {
  keywords: [
    "technology",
    "communication",
    "dial",
    "telephone"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, sD = {
  keywords: [
    "bbcall",
    "oldschool",
    "90s"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, iD = {
  keywords: [
    "communication",
    "technology"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, oD = {
  keywords: [
    "technology",
    "program",
    "oldschool",
    "show",
    "television"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, cD = {
  keywords: [
    "communication",
    "music",
    "podcast",
    "program"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, lD = {
  keywords: [
    "sing",
    "recording",
    "artist",
    "talkshow"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, uD = {
  keywords: [
    "scale"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, fD = {
  keywords: [
    "dial"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, hD = {
  keywords: [
    "magnetic",
    "navigation",
    "orienteering"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, dD = {
  keywords: [
    "time",
    "deadline"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, mD = {
  keywords: [
    "alarm"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, pD = {
  keywords: [
    "time",
    "wake"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, gD = {
  keywords: [
    "time"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, yD = {
  keywords: [
    "oldschool",
    "time",
    "countdown"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, _D = {
  keywords: [
    "time",
    "clock",
    "oldschool",
    "limit",
    "exam",
    "quiz",
    "test"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, bD = {
  keywords: [
    "communication",
    "future",
    "radio",
    "space"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, kD = {
  keywords: [
    "power",
    "energy",
    "sustain"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, wD = {
  keywords: [
    "charger",
    "power"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, ED = {
  keywords: [
    "light",
    "electricity",
    "idea"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, TD = {
  keywords: [
    "dark",
    "camping",
    "sight",
    "night"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, vD = {
  keywords: [
    "fire",
    "wax"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, xD = {
  keywords: [
    "quench"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, AD = {
  keywords: [
    "bin",
    "trash",
    "rubbish",
    "garbage",
    "toss"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, DD = {
  keywords: [
    "barrell"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, CD = {
  keywords: [
    "dollar",
    "bills",
    "payment",
    "sale"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, SD = {
  keywords: [
    "money",
    "sales",
    "bill",
    "currency"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, zD = {
  keywords: [
    "money",
    "sales",
    "japanese",
    "dollar",
    "currency"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, ND = {
  keywords: [
    "money",
    "sales",
    "dollar",
    "currency"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, ID = {
  keywords: [
    "british",
    "sterling",
    "money",
    "sales",
    "bills",
    "uk",
    "england",
    "currency"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, RD = {
  keywords: [
    "dollar",
    "payment",
    "coins",
    "sale"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, FD = {
  keywords: [
    "money",
    "sales",
    "dollar",
    "bill",
    "payment",
    "shopping"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, OD = {
  keywords: [
    "blue",
    "ruby",
    "diamond",
    "jewelry"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, LD = {
  keywords: [
    "law",
    "fairness",
    "weight"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, MD = {
  keywords: [
    "tools",
    "diy",
    "fix",
    "maintainer",
    "mechanic"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, BD = {
  keywords: [
    "tools",
    "diy",
    "ikea",
    "fix",
    "maintainer"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, PD = {
  keywords: [
    "tools",
    "build",
    "create"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, HD = {
  keywords: [
    "tools",
    "build",
    "create"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, UD = {
  keywords: [
    "tools",
    "build",
    "create"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, jD = {
  keywords: [
    "tools",
    "dig"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, qD = {
  keywords: [
    "handy",
    "tools",
    "fix"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, YD = {
  keywords: [
    "cog"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, VD = {
  keywords: [
    "bricks"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, GD = {
  keywords: [
    "lock",
    "arrest"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, WD = {
  keywords: [
    "attraction",
    "magnetic"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, $D = {
  keywords: [
    "violence",
    "weapon",
    "pistol",
    "revolver"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, XD = {
  keywords: [
    "boom",
    "explode",
    "explosion",
    "terrorism"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, QD = {
  keywords: [
    "dynamite",
    "boom",
    "explode",
    "explosion",
    "explosive"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, KD = {
  keywords: [
    "knife",
    "blade",
    "cutlery",
    "kitchen",
    "weapon"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, JD = {
  keywords: [
    "weapon"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, ZD = {
  keywords: [
    "weapon"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, eC = {
  keywords: [
    "protection",
    "security"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, tC = {
  keywords: [
    "kills",
    "tobacco",
    "cigarette",
    "joint",
    "smoke"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, aC = {
  keywords: [
    "poison",
    "danger",
    "deadly",
    "scary",
    "death",
    "pirate",
    "evil"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, rC = {
  keywords: [
    "vampire",
    "dead",
    "die",
    "death",
    "rip",
    "graveyard",
    "cemetery",
    "casket",
    "funeral",
    "box"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, nC = {
  keywords: [
    "dead",
    "die",
    "death",
    "rip",
    "ashes"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, sC = {
  keywords: [
    "vase",
    "jar"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, iC = {
  keywords: [
    "disco",
    "party",
    "magic",
    "circus",
    "fortune_teller"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, oC = {
  keywords: [
    "dhikr",
    "religious"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, cC = {
  keywords: [
    "bead",
    "charm"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, lC = {
  keywords: [
    "hair",
    "salon",
    "style"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, uC = {
  keywords: [
    "distilling",
    "science",
    "experiment",
    "chemistry"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, fC = {
  keywords: [
    "stars",
    "space",
    "zoom",
    "science",
    "astronomy"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, hC = {
  keywords: [
    "laboratory",
    "experiment",
    "zoomin",
    "science",
    "study"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, dC = {
  keywords: [
    "embarrassing"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, mC = {
  keywords: [
    "health",
    "medicine",
    "doctor",
    "pharmacy",
    "drug"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, pC = {
  keywords: [
    "health",
    "hospital",
    "drugs",
    "blood",
    "medicine",
    "needle",
    "doctor",
    "nurse"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, gC = {
  keywords: [
    "biologist",
    "genetics",
    "life"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, yC = {
  keywords: [
    "amoeba",
    "bacteria",
    "germs"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, _C = {
  keywords: [
    "bacteria",
    "biology",
    "culture",
    "lab"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, bC = {
  keywords: [
    "chemistry",
    "experiment",
    "lab",
    "science"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, kC = {
  keywords: [
    "weather",
    "temperature",
    "hot",
    "cold"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, wC = {
  keywords: [
    "cleaning",
    "sweeping",
    "witch"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, EC = {
  keywords: [
    "laundry"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, TC = {
  keywords: [
    "roll"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, vC = {
  keywords: [
    "sale",
    "tag"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, xC = {
  keywords: [
    "favorite",
    "label",
    "save"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, AC = {
  keywords: [
    "restroom",
    "wc",
    "washroom",
    "bathroom",
    "potty"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, DC = {
  keywords: [
    "clean",
    "water",
    "bathroom"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, CC = {
  keywords: [
    "clean",
    "shower",
    "bathroom"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, SC = {
  keywords: [
    "bar",
    "bathing",
    "cleaning",
    "lather"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, zC = {
  keywords: [
    "absorbing",
    "cleaning",
    "porous"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, NC = {
  keywords: [
    "moisturizer",
    "sunscreen"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, IC = {
  keywords: [
    "lock",
    "door",
    "password"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, RC = {
  keywords: [
    "lock",
    "door",
    "password"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, FC = {
  keywords: [
    "read",
    "chill"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, OC = {
  keywords: [
    "bed",
    "rest"
  ],
  char: "",
  fitzpatrick_scale: !0,
  category: "objects"
}, LC = {
  keywords: [
    "sleep",
    "rest"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, MC = {
  keywords: [
    "house",
    "entry",
    "exit"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, BC = {
  keywords: [
    "service"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, PC = {
  keywords: [
    "plush",
    "stuffed"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, HC = {
  keywords: [
    "photography"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, UC = {
  keywords: [
    "location",
    "direction"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, jC = {
  keywords: [
    "weather",
    "summer"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, qC = {
  keywords: [
    "rock",
    "easter island",
    "moai"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, YC = {
  keywords: [
    "mall",
    "buy",
    "purchase"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, VC = {
  keywords: [
    "trolley"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, GC = {
  keywords: [
    "party",
    "celebration",
    "birthday",
    "circus"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, WC = {
  keywords: [
    "fish",
    "japanese",
    "koinobori",
    "carp",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, $C = {
  keywords: [
    "decoration",
    "pink",
    "girl",
    "bowtie"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, XC = {
  keywords: [
    "present",
    "birthday",
    "christmas",
    "xmas"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, QC = {
  keywords: [
    "festival",
    "party",
    "birthday",
    "circus"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, KC = {
  keywords: [
    "party",
    "congratulations",
    "birthday",
    "magic",
    "circus",
    "celebration"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, JC = {
  keywords: [
    "japanese",
    "toy",
    "kimono"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, ZC = {
  keywords: [
    "nature",
    "ding",
    "spring",
    "bell"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, eS = {
  keywords: [
    "japanese",
    "nation",
    "country",
    "border"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, tS = {
  keywords: [
    "light",
    "paper",
    "halloween",
    "spooky"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, aS = {
  keywords: [
    "gift"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, rS = {
  keywords: [
    "letter",
    "postal",
    "inbox",
    "communication"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, nS = {
  keywords: [
    "email",
    "communication"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, sS = {
  keywords: [
    "email",
    "inbox"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, iS = {
  keywords: [
    "email",
    "like",
    "affection",
    "envelope",
    "valentines"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, oS = {
  keywords: [
    "email",
    "letter",
    "envelope"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, cS = {
  keywords: [
    "email",
    "communication",
    "inbox"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, lS = {
  keywords: [
    "email",
    "inbox",
    "communication"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, uS = {
  keywords: [
    "email",
    "inbox",
    "communication"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, fS = {
  keywords: [
    "email",
    "inbox"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, hS = {
  keywords: [
    "instrument",
    "music"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, dS = {
  keywords: [
    "email",
    "documents"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, mS = {
  keywords: [
    "inbox",
    "email"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, pS = {
  keywords: [
    "documents",
    "ancient",
    "history",
    "paper"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, gS = {
  keywords: [
    "documents",
    "office",
    "paper"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, yS = {
  keywords: [
    "favorite",
    "save",
    "order",
    "tidy"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, _S = {
  keywords: [
    "accounting",
    "expenses"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, bS = {
  keywords: [
    "graph",
    "presentation",
    "stats"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, kS = {
  keywords: [
    "graph",
    "presentation",
    "stats",
    "recovery",
    "business",
    "economics",
    "money",
    "sales",
    "good",
    "success"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, wS = {
  keywords: [
    "graph",
    "presentation",
    "stats",
    "recession",
    "business",
    "economics",
    "money",
    "sales",
    "bad",
    "failure"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, ES = {
  keywords: [
    "documents",
    "office",
    "paper",
    "information"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, TS = {
  keywords: [
    "calendar",
    "schedule"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, vS = {
  keywords: [
    "schedule",
    "date",
    "planning"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, xS = {
  keywords: [
    "date",
    "schedule",
    "planning"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, AS = {
  keywords: [
    "business",
    "stationery"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, DS = {
  keywords: [
    "business",
    "stationery"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, CS = {
  keywords: [
    "election",
    "vote"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, SS = {
  keywords: [
    "filing",
    "organizing"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, zS = {
  keywords: [
    "stationery",
    "documents"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, NS = {
  keywords: [
    "memo",
    "stationery"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, IS = {
  keywords: [
    "documents",
    "business",
    "office"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, RS = {
  keywords: [
    "documents",
    "load"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, FS = {
  keywords: [
    "organizing",
    "business",
    "stationery"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, OS = {
  keywords: [
    "press",
    "headline"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, LS = {
  keywords: [
    "press",
    "headline"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, MS = {
  keywords: [
    "stationery",
    "record",
    "notes",
    "paper",
    "study"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, BS = {
  keywords: [
    "read",
    "library",
    "knowledge",
    "textbook",
    "learn"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, PS = {
  keywords: [
    "read",
    "library",
    "knowledge",
    "study"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, HS = {
  keywords: [
    "read",
    "library",
    "knowledge",
    "learn",
    "study"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, US = {
  keywords: [
    "read",
    "library",
    "knowledge",
    "textbook",
    "study"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, jS = {
  keywords: [
    "classroom",
    "notes",
    "record",
    "paper",
    "study"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, qS = {
  keywords: [
    "notes",
    "paper"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, YS = {
  keywords: [
    "literature",
    "library",
    "study"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, VS = {
  keywords: [
    "book",
    "read",
    "library",
    "knowledge",
    "literature",
    "learn",
    "study"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, GS = {
  keywords: [
    "diaper"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, WS = {
  keywords: [
    "rings",
    "url"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, $S = {
  keywords: [
    "documents",
    "stationery"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, XS = {
  keywords: [
    "documents",
    "stationery"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, QS = {
  keywords: [
    "stationery",
    "cut"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, KS = {
  keywords: [
    "stationery",
    "math",
    "architect",
    "sketch"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, JS = {
  keywords: [
    "stationery",
    "calculate",
    "length",
    "math",
    "school",
    "drawing",
    "architect",
    "sketch"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, ZS = {
  keywords: [
    "calculation"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, ez = {
  keywords: [
    "stationery",
    "mark",
    "here"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, tz = {
  keywords: [
    "stationery",
    "location",
    "map",
    "here"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, az = {
  keywords: [
    "mark",
    "milestone",
    "place"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, rz = {
  keywords: [
    "losing",
    "loser",
    "lost",
    "surrender",
    "give up",
    "fail"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, nz = {
  keywords: [
    "pirate"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, sz = {
  keywords: [
    "flag",
    "rainbow",
    "pride",
    "gay",
    "lgbt",
    "glbt",
    "queer",
    "homosexual",
    "lesbian",
    "bisexual",
    "transgender"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, iz = {
  keywords: [
    "security",
    "privacy"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, oz = {
  keywords: [
    "security",
    "password",
    "padlock"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, cz = {
  keywords: [
    "privacy",
    "security"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, lz = {
  keywords: [
    "security",
    "secret"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, uz = {
  keywords: [
    "stationery",
    "writing",
    "write"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, fz = {
  keywords: [
    "stationery",
    "writing",
    "write"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, hz = {
  keywords: [
    "pen",
    "stationery",
    "writing",
    "write"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, dz = {
  keywords: [
    "write",
    "documents",
    "stationery",
    "pencil",
    "paper",
    "writing",
    "legal",
    "exam",
    "quiz",
    "test",
    "study",
    "compose"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, mz = {
  keywords: [
    "stationery",
    "write",
    "paper",
    "writing",
    "school",
    "study"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, pz = {
  keywords: [
    "drawing",
    "creativity"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, gz = {
  keywords: [
    "drawing",
    "creativity",
    "art"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, yz = {
  keywords: [
    "search",
    "zoom",
    "find",
    "detective"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, _z = {
  keywords: [
    "search",
    "zoom",
    "find",
    "detective"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "objects"
}, bz = {
  keywords: [
    "love",
    "like",
    "valentines"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, kz = {
  keywords: [
    "love",
    "like",
    "affection",
    "valentines"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, wz = {
  keywords: [
    "love",
    "like",
    "affection",
    "valentines"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, Ez = {
  keywords: [
    "love",
    "like",
    "affection",
    "valentines"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, Tz = {
  keywords: [
    "love",
    "like",
    "affection",
    "valentines"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, vz = {
  keywords: [
    "love",
    "like",
    "affection",
    "valentines"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, xz = {
  keywords: [
    "evil"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, Az = {
  keywords: [
    "sad",
    "sorry",
    "break",
    "heart",
    "heartbreak"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, Dz = {
  keywords: [
    "decoration",
    "love"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, Cz = {
  keywords: [
    "love",
    "like",
    "affection",
    "valentines",
    "heart"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, Sz = {
  keywords: [
    "love",
    "like",
    "affection",
    "valentines"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, zz = {
  keywords: [
    "love",
    "like",
    "affection",
    "valentines",
    "pink",
    "heart"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, Nz = {
  keywords: [
    "like",
    "love",
    "affection",
    "valentines",
    "pink"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, Iz = {
  keywords: [
    "love",
    "like",
    "affection",
    "valentines"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, Rz = {
  keywords: [
    "love",
    "like",
    "heart",
    "affection",
    "valentines"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, Fz = {
  keywords: [
    "love",
    "valentines"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, Oz = {
  keywords: [
    "purple-square",
    "love",
    "like"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, Lz = {
  keywords: [
    "hippie"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, Mz = {
  keywords: [
    "christianity"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, Bz = {
  keywords: [
    "islam"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, Pz = {
  keywords: [
    "hinduism",
    "buddhism",
    "sikhism",
    "jainism"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, Hz = {
  keywords: [
    "hinduism",
    "buddhism",
    "sikhism",
    "jainism"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, Uz = {
  keywords: [
    "judaism"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, jz = {
  keywords: [
    "purple-square",
    "religion",
    "jewish",
    "hexagram"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, qz = {
  keywords: [
    "hanukkah",
    "candles",
    "jewish"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, Yz = {
  keywords: [
    "balance"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, Vz = {
  keywords: [
    "suppedaneum",
    "religion"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, Gz = {
  keywords: [
    "religion",
    "church",
    "temple",
    "prayer"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, Wz = {
  keywords: [
    "sign",
    "purple-square",
    "constellation",
    "astrology"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, $z = {
  keywords: [
    "sign",
    "purple-square",
    "zodiac",
    "astrology"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, Xz = {
  keywords: [
    "purple-square",
    "sign",
    "zodiac",
    "astrology"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, Qz = {
  keywords: [
    "sign",
    "zodiac",
    "purple-square",
    "astrology"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, Kz = {
  keywords: [
    "sign",
    "zodiac",
    "purple-square",
    "astrology"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, Jz = {
  keywords: [
    "sign",
    "purple-square",
    "zodiac",
    "astrology"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, Zz = {
  keywords: [
    "sign",
    "zodiac",
    "purple-square",
    "astrology"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, eN = {
  keywords: [
    "sign",
    "purple-square",
    "zodiac",
    "astrology"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, tN = {
  keywords: [
    "sign",
    "zodiac",
    "purple-square",
    "astrology",
    "scorpio"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, aN = {
  keywords: [
    "sign",
    "zodiac",
    "purple-square",
    "astrology"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, rN = {
  keywords: [
    "sign",
    "zodiac",
    "purple-square",
    "astrology"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, nN = {
  keywords: [
    "sign",
    "purple-square",
    "zodiac",
    "astrology"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, sN = {
  keywords: [
    "purple-square",
    "sign",
    "zodiac",
    "astrology"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, iN = {
  keywords: [
    "purple-square",
    "words"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, oN = {
  keywords: [
    "science",
    "physics",
    "chemistry"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, cN = {
  keywords: [
    "kanji",
    "japanese",
    "chinese",
    "empty",
    "sky",
    "blue-square"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, lN = {
  keywords: [
    "cut",
    "divide",
    "chinese",
    "kanji",
    "pink-square"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, uN = {
  keywords: [
    "nuclear",
    "danger"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, fN = {
  keywords: [
    "danger"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, hN = {
  keywords: [
    "mute",
    "orange-square",
    "silence",
    "quiet"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, dN = {
  keywords: [
    "orange-square",
    "phone"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, mN = {
  keywords: [
    "orange-square",
    "chinese",
    "have",
    "kanji"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, pN = {
  keywords: [
    "nothing",
    "chinese",
    "kanji",
    "japanese",
    "orange-square"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, gN = {
  keywords: [
    "chinese",
    "japanese",
    "kanji",
    "orange-square"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, yN = {
  keywords: [
    "japanese",
    "opening hours",
    "orange-square"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, _N = {
  keywords: [
    "chinese",
    "month",
    "moon",
    "japanese",
    "orange-square",
    "kanji"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, bN = {
  keywords: [
    "orange-square",
    "shape",
    "polygon"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, kN = {
  keywords: [
    "words",
    "orange-square"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, wN = {
  keywords: [
    "ok",
    "good",
    "chinese",
    "kanji",
    "agree",
    "yes",
    "orange-circle"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, EN = {
  keywords: [
    "japanese",
    "spring"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, TN = {
  keywords: [
    "chinese",
    "kanji",
    "obtain",
    "get",
    "circle"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, vN = {
  keywords: [
    "privacy",
    "chinese",
    "sshh",
    "kanji",
    "red-circle"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, xN = {
  keywords: [
    "chinese",
    "kanji",
    "japanese",
    "red-circle"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, AN = {
  keywords: [
    "japanese",
    "chinese",
    "join",
    "kanji",
    "red-square"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, DN = {
  keywords: [
    "full",
    "chinese",
    "japanese",
    "red-square",
    "kanji"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, CN = {
  keywords: [
    "kanji",
    "japanese",
    "chinese",
    "forbidden",
    "limit",
    "restricted",
    "red-square"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, SN = {
  keywords: [
    "red-square",
    "alphabet",
    "letter"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, zN = {
  keywords: [
    "red-square",
    "alphabet",
    "letter"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, NN = {
  keywords: [
    "red-square",
    "alphabet"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, IN = {
  keywords: [
    "alphabet",
    "words",
    "red-square"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, RN = {
  keywords: [
    "alphabet",
    "red-square",
    "letter"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, FN = {
  keywords: [
    "help",
    "red-square",
    "words",
    "emergency",
    "911"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, ON = {
  keywords: [
    "limit",
    "security",
    "privacy",
    "bad",
    "denied",
    "stop",
    "circle"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, LN = {
  keywords: [
    "fire",
    "forbid"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, MN = {
  keywords: [
    "forbid",
    "stop",
    "limit",
    "denied",
    "disallow",
    "circle"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, BN = {
  keywords: [
    "no",
    "delete",
    "remove",
    "cancel",
    "red"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, PN = {
  keywords: [
    "circle",
    "round"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, HN = {
  keywords: [
    "stop"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, UN = {
  keywords: [
    "angry",
    "mad"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, jN = {
  keywords: [
    "bath",
    "warm",
    "relax"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, qN = {
  keywords: [
    "rules",
    "crossing",
    "walking",
    "circle"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, YN = {
  keywords: [
    "trash",
    "bin",
    "garbage",
    "circle"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, VN = {
  keywords: [
    "cyclist",
    "prohibited",
    "circle"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, GN = {
  keywords: [
    "18",
    "drink",
    "pub",
    "night",
    "minor",
    "circle"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, WN = {
  keywords: [
    "iphone",
    "mute",
    "circle"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, $N = {
  keywords: [
    "heavy_exclamation_mark",
    "danger",
    "surprise",
    "punctuation",
    "wow",
    "warning"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, XN = {
  keywords: [
    "surprise",
    "punctuation",
    "gray",
    "wow",
    "warning"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, QN = {
  keywords: [
    "doubt",
    "confused"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, KN = {
  keywords: [
    "doubts",
    "gray",
    "huh",
    "confused"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, JN = {
  keywords: [
    "exclamation",
    "surprise"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, ZN = {
  keywords: [
    "wat",
    "punctuation",
    "surprise"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, eI = {
  keywords: [
    "sun",
    "afternoon",
    "warm",
    "summer"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, tI = {
  keywords: [
    "sun",
    "light"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, aI = {
  keywords: [
    "weapon",
    "spear"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, rI = {
  keywords: [
    "decorative",
    "scout"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, nI = {
  keywords: [
    "graph",
    "presentation",
    "stats",
    "business",
    "economics",
    "bad"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, sI = {
  keywords: [
    "exclamation",
    "wip",
    "alert",
    "error",
    "problem",
    "issue"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, iI = {
  keywords: [
    "school",
    "warning",
    "danger",
    "sign",
    "driving",
    "yellow-diamond"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, oI = {
  keywords: [
    "badge",
    "shield"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, cI = {
  keywords: [
    "arrow",
    "environment",
    "garbage",
    "trash"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, lI = {
  keywords: [
    "chinese",
    "point",
    "green-square",
    "kanji"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, uI = {
  keywords: [
    "green-square",
    "graph",
    "presentation",
    "stats"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, fI = {
  keywords: [
    "stars",
    "green-square",
    "awesome",
    "good",
    "fireworks"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, hI = {
  keywords: [
    "star",
    "sparkle",
    "green-square"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, dI = {
  keywords: [
    "x",
    "green-square",
    "no",
    "deny"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, mI = {
  keywords: [
    "green-square",
    "ok",
    "agree",
    "vote",
    "election",
    "answer",
    "tick"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, pI = {
  keywords: [
    "jewel",
    "blue",
    "gem",
    "crystal",
    "fancy"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, gI = {
  keywords: [
    "weather",
    "swirl",
    "blue",
    "cloud",
    "vortex",
    "spiral",
    "whirlpool",
    "spin",
    "tornado",
    "hurricane",
    "typhoon"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, yI = {
  keywords: [
    "tape",
    "cassette"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, _I = {
  keywords: [
    "earth",
    "international",
    "world",
    "internet",
    "interweb",
    "i18n"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, bI = {
  keywords: [
    "alphabet",
    "blue-circle",
    "letter"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, kI = {
  keywords: [
    "money",
    "sales",
    "cash",
    "blue-square",
    "payment",
    "bank"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, wI = {
  keywords: [
    "japanese",
    "blue-square",
    "katakana"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, EI = {
  keywords: [
    "custom",
    "blue-square"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, TI = {
  keywords: [
    "passport",
    "border",
    "blue-square"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, vI = {
  keywords: [
    "blue-square",
    "airport",
    "transport"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, xI = {
  keywords: [
    "blue-square",
    "travel"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, AI = {
  keywords: [
    "blue-square",
    "disabled",
    "a11y",
    "accessibility"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, DI = {
  keywords: [
    "cigarette",
    "blue-square",
    "smell",
    "smoke"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, CI = {
  keywords: [
    "toilet",
    "restroom",
    "blue-square"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, SI = {
  keywords: [
    "cars",
    "blue-square",
    "alphabet",
    "letter"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, zI = {
  keywords: [
    "blue-square",
    "liquid",
    "restroom",
    "cleaning",
    "faucet"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, NI = {
  keywords: [
    "toilet",
    "restroom",
    "wc",
    "blue-square",
    "gender",
    "male"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, II = {
  keywords: [
    "purple-square",
    "woman",
    "female",
    "toilet",
    "loo",
    "restroom",
    "gender"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, RI = {
  keywords: [
    "orange-square",
    "child"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, FI = {
  keywords: [
    "blue-square",
    "toilet",
    "refresh",
    "wc",
    "gender"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, OI = {
  keywords: [
    "blue-square",
    "sign",
    "human",
    "info"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, LI = {
  keywords: [
    "blue-square",
    "record",
    "film",
    "movie",
    "curtain",
    "stage",
    "theater"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, MI = {
  keywords: [
    "blue-square",
    "reception",
    "phone",
    "internet",
    "connection",
    "wifi",
    "bluetooth",
    "bars"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, BI = {
  keywords: [
    "blue-square",
    "here",
    "katakana",
    "japanese",
    "destination"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, PI = {
  keywords: [
    "blue-square",
    "words",
    "shape",
    "icon"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, HI = {
  keywords: [
    "good",
    "agree",
    "yes",
    "blue-square"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, UI = {
  keywords: [
    "blue-square",
    "above",
    "high"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, jI = {
  keywords: [
    "words",
    "blue-square"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, qI = {
  keywords: [
    "blue-square",
    "words"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, YI = {
  keywords: [
    "0",
    "numbers",
    "blue-square",
    "null"
  ],
  char: "0",
  fitzpatrick_scale: !1,
  category: "symbols"
}, VI = {
  keywords: [
    "blue-square",
    "numbers",
    "1"
  ],
  char: "1",
  fitzpatrick_scale: !1,
  category: "symbols"
}, GI = {
  keywords: [
    "numbers",
    "2",
    "prime",
    "blue-square"
  ],
  char: "2",
  fitzpatrick_scale: !1,
  category: "symbols"
}, WI = {
  keywords: [
    "3",
    "numbers",
    "prime",
    "blue-square"
  ],
  char: "3",
  fitzpatrick_scale: !1,
  category: "symbols"
}, $I = {
  keywords: [
    "4",
    "numbers",
    "blue-square"
  ],
  char: "4",
  fitzpatrick_scale: !1,
  category: "symbols"
}, XI = {
  keywords: [
    "5",
    "numbers",
    "blue-square",
    "prime"
  ],
  char: "5",
  fitzpatrick_scale: !1,
  category: "symbols"
}, QI = {
  keywords: [
    "6",
    "numbers",
    "blue-square"
  ],
  char: "6",
  fitzpatrick_scale: !1,
  category: "symbols"
}, KI = {
  keywords: [
    "7",
    "numbers",
    "blue-square",
    "prime"
  ],
  char: "7",
  fitzpatrick_scale: !1,
  category: "symbols"
}, JI = {
  keywords: [
    "8",
    "blue-square",
    "numbers"
  ],
  char: "8",
  fitzpatrick_scale: !1,
  category: "symbols"
}, ZI = {
  keywords: [
    "blue-square",
    "numbers",
    "9"
  ],
  char: "9",
  fitzpatrick_scale: !1,
  category: "symbols"
}, eR = {
  keywords: [
    "numbers",
    "10",
    "blue-square"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, tR = {
  keywords: [
    "star",
    "keycap"
  ],
  char: "*",
  fitzpatrick_scale: !1,
  category: "symbols"
}, aR = {
  keywords: [
    "blue-square"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, rR = {
  keywords: [
    "blue-square",
    "right",
    "direction",
    "play"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, nR = {
  keywords: [
    "pause",
    "blue-square"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, sR = {
  keywords: [
    "forward",
    "next",
    "blue-square"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, iR = {
  keywords: [
    "blue-square"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, oR = {
  keywords: [
    "blue-square"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, cR = {
  keywords: [
    "blue-square",
    "play",
    "pause"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, lR = {
  keywords: [
    "backward"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, uR = {
  keywords: [
    "blue-square",
    "play",
    "speed",
    "continue"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, fR = {
  keywords: [
    "play",
    "blue-square"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, hR = {
  keywords: [
    "blue-square",
    "shuffle",
    "music",
    "random"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, dR = {
  keywords: [
    "loop",
    "record"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, mR = {
  keywords: [
    "blue-square",
    "loop"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, pR = {
  keywords: [
    "blue-square",
    "left",
    "direction"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, gR = {
  keywords: [
    "blue-square",
    "triangle",
    "direction",
    "point",
    "forward",
    "top"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, yR = {
  keywords: [
    "blue-square",
    "direction",
    "bottom"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, _R = {
  keywords: [
    "blue-square",
    "direction",
    "top"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, bR = {
  keywords: [
    "blue-square",
    "direction",
    "bottom"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, kR = {
  keywords: [
    "blue-square",
    "next"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, wR = {
  keywords: [
    "blue-square",
    "previous",
    "back"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, ER = {
  keywords: [
    "blue-square",
    "continue",
    "top",
    "direction"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, TR = {
  keywords: [
    "blue-square",
    "direction",
    "bottom"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, vR = {
  keywords: [
    "blue-square",
    "point",
    "direction",
    "diagonal",
    "northeast"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, xR = {
  keywords: [
    "blue-square",
    "direction",
    "diagonal",
    "southeast"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, AR = {
  keywords: [
    "blue-square",
    "direction",
    "diagonal",
    "southwest"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, DR = {
  keywords: [
    "blue-square",
    "point",
    "direction",
    "diagonal",
    "northwest"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, CR = {
  keywords: [
    "blue-square",
    "direction",
    "way",
    "vertical"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, SR = {
  keywords: [
    "shape",
    "direction",
    "horizontal",
    "sideways"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, zR = {
  keywords: [
    "blue-square",
    "sync",
    "cycle"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, NR = {
  keywords: [
    "blue-square",
    "return",
    "rotate",
    "direction"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, IR = {
  keywords: [
    "back",
    "return",
    "blue-square",
    "undo",
    "enter"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, RR = {
  keywords: [
    "blue-square",
    "direction",
    "top"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, FR = {
  keywords: [
    "blue-square",
    "direction",
    "bottom"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, OR = {
  keywords: [
    "symbol",
    "blue-square",
    "twitter"
  ],
  char: "#",
  fitzpatrick_scale: !1,
  category: "symbols"
}, LR = {
  keywords: [
    "blue-square",
    "alphabet",
    "letter"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, MR = {
  keywords: [
    "blue-square",
    "alphabet"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, BR = {
  keywords: [
    "blue-square",
    "alphabet"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, PR = {
  keywords: [
    "alphabet",
    "words",
    "blue-square"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, HR = {
  keywords: [
    "blue-square",
    "music",
    "note",
    "ampersand",
    "percent",
    "glyphs",
    "characters"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, UR = {
  keywords: [
    "score",
    "tone",
    "sound"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, jR = {
  keywords: [
    "music",
    "score"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, qR = {
  keywords: [
    "draw",
    "line",
    "moustache",
    "mustache",
    "squiggle",
    "scribble"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, YR = {
  keywords: [
    "scribble",
    "draw",
    "shape",
    "squiggle"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, VR = {
  keywords: [
    "ok",
    "nike",
    "answer",
    "yes",
    "tick"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, GR = {
  keywords: [
    "sync",
    "cycle",
    "round",
    "repeat"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, WR = {
  keywords: [
    "math",
    "calculation",
    "addition",
    "more",
    "increase"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, $R = {
  keywords: [
    "math",
    "calculation",
    "subtract",
    "less"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, XR = {
  keywords: [
    "divide",
    "math",
    "calculation"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, QR = {
  keywords: [
    "math",
    "calculation"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, KR = {
  keywords: [
    "forever"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, JR = {
  keywords: [
    "money",
    "sales",
    "payment",
    "currency",
    "buck"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, ZR = {
  keywords: [
    "money",
    "sales",
    "dollar",
    "travel"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, eF = {
  keywords: [
    "ip",
    "license",
    "circle",
    "law",
    "legal"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, tF = {
  keywords: [
    "alphabet",
    "circle"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, aF = {
  keywords: [
    "trademark",
    "brand",
    "law",
    "legal"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, rF = {
  keywords: [
    "words",
    "arrow"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, nF = {
  keywords: [
    "arrow",
    "words",
    "return"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, sF = {
  keywords: [
    "arrow",
    "words"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, iF = {
  keywords: [
    "words",
    "blue-square"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, oF = {
  keywords: [
    "arrow",
    "words"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, cF = {
  keywords: [
    "ok",
    "agree",
    "confirm",
    "black-square",
    "vote",
    "election",
    "yes",
    "tick"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, lF = {
  keywords: [
    "input",
    "old",
    "music",
    "circle"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, uF = {
  keywords: [
    "shape",
    "round"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, fF = {
  keywords: [
    "shape",
    "button",
    "round"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, hF = {
  keywords: [
    "shape",
    "error",
    "danger"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, dF = {
  keywords: [
    "shape",
    "icon",
    "button"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, mF = {
  keywords: [
    "shape",
    "jewel",
    "gem"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, pF = {
  keywords: [
    "shape",
    "jewel",
    "gem"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, gF = {
  keywords: [
    "shape",
    "jewel",
    "gem"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, yF = {
  keywords: [
    "shape",
    "jewel",
    "gem"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, _F = {
  keywords: [
    "shape",
    "direction",
    "up",
    "top"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, bF = {
  keywords: [
    "shape",
    "icon"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, kF = {
  keywords: [
    "shape",
    "icon"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, wF = {
  keywords: [
    "shape",
    "icon",
    "button"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, EF = {
  keywords: [
    "shape",
    "icon",
    "stone",
    "button"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, TF = {
  keywords: [
    "shape",
    "direction",
    "bottom"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, vF = {
  keywords: [
    "shape",
    "button",
    "icon"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, xF = {
  keywords: [
    "shape",
    "stone",
    "icon"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, AF = {
  keywords: [
    "icon",
    "shape",
    "button"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, DF = {
  keywords: [
    "shape",
    "stone",
    "icon",
    "button"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, CF = {
  keywords: [
    "shape",
    "input",
    "frame"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, SF = {
  keywords: [
    "shape",
    "input"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, zF = {
  keywords: [
    "sound",
    "volume",
    "silence",
    "broadcast"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, NF = {
  keywords: [
    "volume",
    "speaker",
    "broadcast"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, IF = {
  keywords: [
    "volume",
    "noise",
    "noisy",
    "speaker",
    "broadcast"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, RF = {
  keywords: [
    "sound",
    "volume",
    "silence",
    "quiet"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, FF = {
  keywords: [
    "sound",
    "speaker",
    "volume"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, OF = {
  keywords: [
    "volume",
    "sound"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, LF = {
  keywords: [
    "sound",
    "notification",
    "christmas",
    "xmas",
    "chime"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, MF = {
  keywords: [
    "sound",
    "volume",
    "mute",
    "quiet",
    "silent"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, BF = {
  keywords: [
    "poker",
    "cards",
    "game",
    "play",
    "magic"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, PF = {
  keywords: [
    "game",
    "play",
    "chinese",
    "kanji"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, HF = {
  keywords: [
    "poker",
    "cards",
    "suits",
    "magic"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, UF = {
  keywords: [
    "poker",
    "cards",
    "magic",
    "suits"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, jF = {
  keywords: [
    "poker",
    "cards",
    "magic",
    "suits"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, qF = {
  keywords: [
    "poker",
    "cards",
    "magic",
    "suits"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, YF = {
  keywords: [
    "game",
    "sunset",
    "red"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, VF = {
  keywords: [
    "bubble",
    "cloud",
    "speech",
    "thinking",
    "dream"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, GF = {
  keywords: [
    "caption",
    "speech",
    "thinking",
    "mad"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, WF = {
  keywords: [
    "bubble",
    "words",
    "message",
    "talk",
    "chatting"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, $F = {
  keywords: [
    "words",
    "message",
    "talk",
    "chatting"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, XF = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, QF = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, KF = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, JF = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, ZF = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, eO = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule",
    "dawn",
    "dusk"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, tO = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, aO = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, rO = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, nO = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, sO = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, iO = {
  keywords: [
    "time",
    "noon",
    "midnight",
    "midday",
    "late",
    "early",
    "schedule"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, oO = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, cO = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, lO = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, uO = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, fO = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, hO = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, dO = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, mO = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, pO = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, gO = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, yO = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, _O = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "symbols"
}, bO = {
  keywords: [
    "af",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, kO = {
  keywords: [
    "land",
    "islands",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, wO = {
  keywords: [
    "al",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, EO = {
  keywords: [
    "dz",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, TO = {
  keywords: [
    "american",
    "ws",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, vO = {
  keywords: [
    "ad",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, xO = {
  keywords: [
    "ao",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, AO = {
  keywords: [
    "ai",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, DO = {
  keywords: [
    "aq",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, CO = {
  keywords: [
    "antigua",
    "barbuda",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, SO = {
  keywords: [
    "ar",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, zO = {
  keywords: [
    "am",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, NO = {
  keywords: [
    "aw",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, IO = {
  keywords: [
    "au",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, RO = {
  keywords: [
    "at",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, FO = {
  keywords: [
    "az",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, OO = {
  keywords: [
    "bs",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, LO = {
  keywords: [
    "bh",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, MO = {
  keywords: [
    "bd",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, BO = {
  keywords: [
    "bb",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, PO = {
  keywords: [
    "by",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, HO = {
  keywords: [
    "be",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, UO = {
  keywords: [
    "bz",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, jO = {
  keywords: [
    "bj",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, qO = {
  keywords: [
    "bm",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, YO = {
  keywords: [
    "bt",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, VO = {
  keywords: [
    "bo",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, GO = {
  keywords: [
    "bonaire",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, WO = {
  keywords: [
    "bosnia",
    "herzegovina",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, $O = {
  keywords: [
    "bw",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, XO = {
  keywords: [
    "br",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, QO = {
  keywords: [
    "british",
    "indian",
    "ocean",
    "territory",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, KO = {
  keywords: [
    "british",
    "virgin",
    "islands",
    "bvi",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, JO = {
  keywords: [
    "bn",
    "darussalam",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, ZO = {
  keywords: [
    "bg",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, eL = {
  keywords: [
    "burkina",
    "faso",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, tL = {
  keywords: [
    "bi",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, aL = {
  keywords: [
    "cabo",
    "verde",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, rL = {
  keywords: [
    "kh",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, nL = {
  keywords: [
    "cm",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, sL = {
  keywords: [
    "ca",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, iL = {
  keywords: [
    "canary",
    "islands",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, oL = {
  keywords: [
    "cayman",
    "islands",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, cL = {
  keywords: [
    "central",
    "african",
    "republic",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, lL = {
  keywords: [
    "td",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, uL = {
  keywords: [
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, fL = {
  keywords: [
    "china",
    "chinese",
    "prc",
    "flag",
    "country",
    "nation",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, hL = {
  keywords: [
    "christmas",
    "island",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, dL = {
  keywords: [
    "cocos",
    "keeling",
    "islands",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, mL = {
  keywords: [
    "co",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, pL = {
  keywords: [
    "km",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, gL = {
  keywords: [
    "congo",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, yL = {
  keywords: [
    "congo",
    "democratic",
    "republic",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, _L = {
  keywords: [
    "cook",
    "islands",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, bL = {
  keywords: [
    "costa",
    "rica",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, kL = {
  keywords: [
    "hr",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, wL = {
  keywords: [
    "cu",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, EL = {
  keywords: [
    "curaao",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, TL = {
  keywords: [
    "cy",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, vL = {
  keywords: [
    "cz",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, xL = {
  keywords: [
    "dk",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, AL = {
  keywords: [
    "dj",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, DL = {
  keywords: [
    "dm",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, CL = {
  keywords: [
    "dominican",
    "republic",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, SL = {
  keywords: [
    "ec",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, zL = {
  keywords: [
    "eg",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, NL = {
  keywords: [
    "el",
    "salvador",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, IL = {
  keywords: [
    "equatorial",
    "gn",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, RL = {
  keywords: [
    "er",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, FL = {
  keywords: [
    "ee",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, OL = {
  keywords: [
    "et",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, LL = {
  keywords: [
    "european",
    "union",
    "flag",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, ML = {
  keywords: [
    "falkland",
    "islands",
    "malvinas",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, BL = {
  keywords: [
    "faroe",
    "islands",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, PL = {
  keywords: [
    "fj",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, HL = {
  keywords: [
    "fi",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, UL = {
  keywords: [
    "banner",
    "flag",
    "nation",
    "france",
    "french",
    "country"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, jL = {
  keywords: [
    "french",
    "guiana",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, qL = {
  keywords: [
    "french",
    "polynesia",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, YL = {
  keywords: [
    "french",
    "southern",
    "territories",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, VL = {
  keywords: [
    "ga",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, GL = {
  keywords: [
    "gm",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, WL = {
  keywords: [
    "ge",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, $L = {
  keywords: [
    "german",
    "nation",
    "flag",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, XL = {
  keywords: [
    "gh",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, QL = {
  keywords: [
    "gi",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, KL = {
  keywords: [
    "gr",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, JL = {
  keywords: [
    "gl",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, ZL = {
  keywords: [
    "gd",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, eM = {
  keywords: [
    "gp",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, tM = {
  keywords: [
    "gu",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, aM = {
  keywords: [
    "gt",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, rM = {
  keywords: [
    "gg",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, nM = {
  keywords: [
    "gn",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, sM = {
  keywords: [
    "gw",
    "bissau",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, iM = {
  keywords: [
    "gy",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, oM = {
  keywords: [
    "ht",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, cM = {
  keywords: [
    "hn",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, lM = {
  keywords: [
    "hong",
    "kong",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, uM = {
  keywords: [
    "hu",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, fM = {
  keywords: [
    "is",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, hM = {
  keywords: [
    "in",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, dM = {
  keywords: [
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, mM = {
  keywords: [
    "iran,",
    "islamic",
    "republic",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, pM = {
  keywords: [
    "iq",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, gM = {
  keywords: [
    "ie",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, yM = {
  keywords: [
    "isle",
    "man",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, _M = {
  keywords: [
    "il",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, bM = {
  keywords: [
    "italy",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, kM = {
  keywords: [
    "ivory",
    "coast",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, wM = {
  keywords: [
    "jm",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, EM = {
  keywords: [
    "japanese",
    "nation",
    "flag",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, TM = {
  keywords: [
    "je",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, vM = {
  keywords: [
    "jo",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, xM = {
  keywords: [
    "kz",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, AM = {
  keywords: [
    "ke",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, DM = {
  keywords: [
    "ki",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, CM = {
  keywords: [
    "xk",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, SM = {
  keywords: [
    "kw",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, zM = {
  keywords: [
    "kg",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, NM = {
  keywords: [
    "lao",
    "democratic",
    "republic",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, IM = {
  keywords: [
    "lv",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, RM = {
  keywords: [
    "lb",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, FM = {
  keywords: [
    "ls",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, OM = {
  keywords: [
    "lr",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, LM = {
  keywords: [
    "ly",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, MM = {
  keywords: [
    "li",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, BM = {
  keywords: [
    "lt",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, PM = {
  keywords: [
    "lu",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, HM = {
  keywords: [
    "macao",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, UM = {
  keywords: [
    "macedonia,",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, jM = {
  keywords: [
    "mg",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, qM = {
  keywords: [
    "mw",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, YM = {
  keywords: [
    "my",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, VM = {
  keywords: [
    "mv",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, GM = {
  keywords: [
    "ml",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, WM = {
  keywords: [
    "mt",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, $M = {
  keywords: [
    "marshall",
    "islands",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, XM = {
  keywords: [
    "mq",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, QM = {
  keywords: [
    "mr",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, KM = {
  keywords: [
    "mu",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, JM = {
  keywords: [
    "yt",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, ZM = {
  keywords: [
    "mx",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, eB = {
  keywords: [
    "micronesia,",
    "federated",
    "states",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, tB = {
  keywords: [
    "moldova,",
    "republic",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, aB = {
  keywords: [
    "mc",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, rB = {
  keywords: [
    "mn",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, nB = {
  keywords: [
    "me",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, sB = {
  keywords: [
    "ms",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, iB = {
  keywords: [
    "ma",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, oB = {
  keywords: [
    "mz",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, cB = {
  keywords: [
    "mm",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, lB = {
  keywords: [
    "na",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, uB = {
  keywords: [
    "nr",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, fB = {
  keywords: [
    "np",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, hB = {
  keywords: [
    "nl",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, dB = {
  keywords: [
    "new",
    "caledonia",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, mB = {
  keywords: [
    "new",
    "zealand",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, pB = {
  keywords: [
    "ni",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, gB = {
  keywords: [
    "ne",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, yB = {
  keywords: [
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, _B = {
  keywords: [
    "nu",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, bB = {
  keywords: [
    "norfolk",
    "island",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, kB = {
  keywords: [
    "northern",
    "mariana",
    "islands",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, wB = {
  keywords: [
    "north",
    "korea",
    "nation",
    "flag",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, EB = {
  keywords: [
    "no",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, TB = {
  keywords: [
    "om_symbol",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, vB = {
  keywords: [
    "pk",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, xB = {
  keywords: [
    "pw",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, AB = {
  keywords: [
    "palestine",
    "palestinian",
    "territories",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, DB = {
  keywords: [
    "pa",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, CB = {
  keywords: [
    "papua",
    "new",
    "guinea",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, SB = {
  keywords: [
    "py",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, zB = {
  keywords: [
    "pe",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, NB = {
  keywords: [
    "ph",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, IB = {
  keywords: [
    "pitcairn",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, RB = {
  keywords: [
    "pl",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, FB = {
  keywords: [
    "pt",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, OB = {
  keywords: [
    "puerto",
    "rico",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, LB = {
  keywords: [
    "qa",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, MB = {
  keywords: [
    "runion",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, BB = {
  keywords: [
    "ro",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, PB = {
  keywords: [
    "russian",
    "federation",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, HB = {
  keywords: [
    "rw",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, UB = {
  keywords: [
    "saint",
    "barthlemy",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, jB = {
  keywords: [
    "saint",
    "helena",
    "ascension",
    "tristan",
    "cunha",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, qB = {
  keywords: [
    "saint",
    "kitts",
    "nevis",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, YB = {
  keywords: [
    "saint",
    "lucia",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, VB = {
  keywords: [
    "saint",
    "pierre",
    "miquelon",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, GB = {
  keywords: [
    "saint",
    "vincent",
    "grenadines",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, WB = {
  keywords: [
    "ws",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, $B = {
  keywords: [
    "san",
    "marino",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, XB = {
  keywords: [
    "sao",
    "tome",
    "principe",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, QB = {
  keywords: [
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, KB = {
  keywords: [
    "sn",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, JB = {
  keywords: [
    "rs",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, ZB = {
  keywords: [
    "sc",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, eP = {
  keywords: [
    "sierra",
    "leone",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, tP = {
  keywords: [
    "sg",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, aP = {
  keywords: [
    "sint",
    "maarten",
    "dutch",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, rP = {
  keywords: [
    "sk",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, nP = {
  keywords: [
    "si",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, sP = {
  keywords: [
    "solomon",
    "islands",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, iP = {
  keywords: [
    "so",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, oP = {
  keywords: [
    "south",
    "africa",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, cP = {
  keywords: [
    "south",
    "georgia",
    "sandwich",
    "islands",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, lP = {
  keywords: [
    "south",
    "korea",
    "nation",
    "flag",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, uP = {
  keywords: [
    "south",
    "sd",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, fP = {
  keywords: [
    "spain",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, hP = {
  keywords: [
    "sri",
    "lanka",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, dP = {
  keywords: [
    "sd",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, mP = {
  keywords: [
    "sr",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, pP = {
  keywords: [
    "sz",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, gP = {
  keywords: [
    "se",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, yP = {
  keywords: [
    "ch",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, _P = {
  keywords: [
    "syrian",
    "arab",
    "republic",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, bP = {
  keywords: [
    "tw",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, kP = {
  keywords: [
    "tj",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, wP = {
  keywords: [
    "tanzania,",
    "united",
    "republic",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, EP = {
  keywords: [
    "th",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, TP = {
  keywords: [
    "timor",
    "leste",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, vP = {
  keywords: [
    "tg",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, xP = {
  keywords: [
    "tk",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, AP = {
  keywords: [
    "to",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, DP = {
  keywords: [
    "trinidad",
    "tobago",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, CP = {
  keywords: [
    "tn",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, SP = {
  keywords: [
    "turkey",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, zP = {
  keywords: [
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, NP = {
  keywords: [
    "turks",
    "caicos",
    "islands",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, IP = {
  keywords: [
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, RP = {
  keywords: [
    "ug",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, FP = {
  keywords: [
    "ua",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, OP = {
  keywords: [
    "united",
    "arab",
    "emirates",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, LP = {
  keywords: [
    "united",
    "kingdom",
    "great",
    "britain",
    "northern",
    "ireland",
    "flag",
    "nation",
    "country",
    "banner",
    "british",
    "UK",
    "english",
    "england",
    "union jack"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, MP = {
  keywords: [
    "flag",
    "english"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, BP = {
  keywords: [
    "flag",
    "scottish"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, PP = {
  keywords: [
    "flag",
    "welsh"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, HP = {
  keywords: [
    "united",
    "states",
    "america",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, UP = {
  keywords: [
    "virgin",
    "islands",
    "us",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, jP = {
  keywords: [
    "uy",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, qP = {
  keywords: [
    "uz",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, YP = {
  keywords: [
    "vu",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, VP = {
  keywords: [
    "vatican",
    "city",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, GP = {
  keywords: [
    "ve",
    "bolivarian",
    "republic",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, WP = {
  keywords: [
    "viet",
    "nam",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, $P = {
  keywords: [
    "wallis",
    "futuna",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, XP = {
  keywords: [
    "western",
    "sahara",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, QP = {
  keywords: [
    "ye",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, KP = {
  keywords: [
    "zm",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, JP = {
  keywords: [
    "zw",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, ZP = {
  keywords: [
    "un",
    "flag",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, eH = {
  keywords: [
    "skull",
    "crossbones",
    "flag",
    "banner"
  ],
  char: "",
  fitzpatrick_scale: !1,
  category: "flags"
}, tH = {
  100: {
    keywords: [
      "score",
      "perfect",
      "numbers",
      "century",
      "exam",
      "quiz",
      "test",
      "pass",
      "hundred"
    ],
    char: "",
    fitzpatrick_scale: !1,
    category: "symbols"
  },
  1234: {
    keywords: [
      "numbers",
      "blue-square"
    ],
    char: "",
    fitzpatrick_scale: !1,
    category: "symbols"
  },
  grinning: u2,
  grimacing: f2,
  grin: h2,
  joy: d2,
  rofl: m2,
  partying: p2,
  smiley: g2,
  smile: y2,
  sweat_smile: _2,
  laughing: b2,
  innocent: k2,
  wink: w2,
  blush: E2,
  slightly_smiling_face: T2,
  upside_down_face: v2,
  relaxed: x2,
  yum: A2,
  relieved: D2,
  heart_eyes: C2,
  smiling_face_with_three_hearts: S2,
  kissing_heart: z2,
  kissing: N2,
  kissing_smiling_eyes: I2,
  kissing_closed_eyes: R2,
  stuck_out_tongue_winking_eye: F2,
  zany: O2,
  raised_eyebrow: L2,
  monocle: M2,
  stuck_out_tongue_closed_eyes: B2,
  stuck_out_tongue: P2,
  money_mouth_face: H2,
  nerd_face: U2,
  sunglasses: j2,
  star_struck: q2,
  clown_face: Y2,
  cowboy_hat_face: V2,
  hugs: G2,
  smirk: W2,
  no_mouth: $2,
  neutral_face: X2,
  expressionless: Q2,
  unamused: K2,
  roll_eyes: J2,
  thinking: Z2,
  lying_face: e4,
  hand_over_mouth: t4,
  shushing: a4,
  symbols_over_mouth: r4,
  exploding_head: n4,
  flushed: s4,
  disappointed: i4,
  worried: o4,
  angry: c4,
  rage: l4,
  pensive: u4,
  confused: f4,
  slightly_frowning_face: h4,
  frowning_face: d4,
  persevere: m4,
  confounded: p4,
  tired_face: g4,
  weary: y4,
  pleading: _4,
  triumph: b4,
  open_mouth: k4,
  scream: w4,
  fearful: E4,
  cold_sweat: T4,
  hushed: v4,
  frowning: x4,
  anguished: A4,
  cry: D4,
  disappointed_relieved: C4,
  drooling_face: S4,
  sleepy: z4,
  sweat: N4,
  hot: I4,
  cold: R4,
  sob: F4,
  dizzy_face: O4,
  astonished: L4,
  zipper_mouth_face: M4,
  nauseated_face: B4,
  sneezing_face: P4,
  vomiting: H4,
  mask: U4,
  face_with_thermometer: j4,
  face_with_head_bandage: q4,
  woozy: Y4,
  sleeping: V4,
  zzz: G4,
  poop: W4,
  smiling_imp: $4,
  imp: X4,
  japanese_ogre: Q4,
  japanese_goblin: K4,
  skull: J4,
  ghost: Z4,
  alien: eb,
  robot: tb,
  smiley_cat: ab,
  smile_cat: rb,
  joy_cat: nb,
  heart_eyes_cat: sb,
  smirk_cat: ib,
  kissing_cat: ob,
  scream_cat: cb,
  crying_cat_face: lb,
  pouting_cat: ub,
  palms_up: fb,
  raised_hands: hb,
  clap: db,
  wave: mb,
  call_me_hand: pb,
  "+1": {
    keywords: [
      "thumbsup",
      "yes",
      "awesome",
      "good",
      "agree",
      "accept",
      "cool",
      "hand",
      "like"
    ],
    char: "",
    fitzpatrick_scale: !0,
    category: "people"
  },
  "-1": {
    keywords: [
      "thumbsdown",
      "no",
      "dislike",
      "hand"
    ],
    char: "",
    fitzpatrick_scale: !0,
    category: "people"
  },
  facepunch: gb,
  fist: yb,
  fist_left: _b,
  fist_right: bb,
  v: kb,
  ok_hand: wb,
  raised_hand: Eb,
  raised_back_of_hand: Tb,
  open_hands: vb,
  muscle: xb,
  pray: Ab,
  foot: Db,
  leg: Cb,
  handshake: Sb,
  point_up: zb,
  point_up_2: Nb,
  point_down: Ib,
  point_left: Rb,
  point_right: Fb,
  fu: Ob,
  raised_hand_with_fingers_splayed: Lb,
  love_you: Mb,
  metal: Bb,
  crossed_fingers: Pb,
  vulcan_salute: Hb,
  writing_hand: Ub,
  selfie: jb,
  nail_care: qb,
  lips: Yb,
  tooth: Vb,
  tongue: Gb,
  ear: Wb,
  nose: $b,
  eye: Xb,
  eyes: Qb,
  brain: Kb,
  bust_in_silhouette: Jb,
  busts_in_silhouette: Zb,
  speaking_head: e3,
  baby: t3,
  child: a3,
  boy: r3,
  girl: n3,
  adult: s3,
  man: i3,
  woman: o3,
  blonde_woman: c3,
  blonde_man: l3,
  bearded_person: u3,
  older_adult: f3,
  older_man: h3,
  older_woman: d3,
  man_with_gua_pi_mao: m3,
  woman_with_headscarf: p3,
  woman_with_turban: g3,
  man_with_turban: y3,
  policewoman: _3,
  policeman: b3,
  construction_worker_woman: k3,
  construction_worker_man: w3,
  guardswoman: E3,
  guardsman: T3,
  female_detective: v3,
  male_detective: x3,
  woman_health_worker: A3,
  man_health_worker: D3,
  woman_farmer: C3,
  man_farmer: S3,
  woman_cook: z3,
  man_cook: N3,
  woman_student: I3,
  man_student: R3,
  woman_singer: F3,
  man_singer: O3,
  woman_teacher: L3,
  man_teacher: M3,
  woman_factory_worker: B3,
  man_factory_worker: P3,
  woman_technologist: H3,
  man_technologist: U3,
  woman_office_worker: j3,
  man_office_worker: q3,
  woman_mechanic: Y3,
  man_mechanic: V3,
  woman_scientist: G3,
  man_scientist: W3,
  woman_artist: $3,
  man_artist: X3,
  woman_firefighter: Q3,
  man_firefighter: K3,
  woman_pilot: J3,
  man_pilot: Z3,
  woman_astronaut: ek,
  man_astronaut: tk,
  woman_judge: ak,
  man_judge: rk,
  woman_superhero: nk,
  man_superhero: sk,
  woman_supervillain: ik,
  man_supervillain: ok,
  mrs_claus: ck,
  santa: lk,
  sorceress: uk,
  wizard: fk,
  woman_elf: hk,
  man_elf: dk,
  woman_vampire: mk,
  man_vampire: pk,
  woman_zombie: gk,
  man_zombie: yk,
  woman_genie: _k,
  man_genie: bk,
  mermaid: kk,
  merman: wk,
  woman_fairy: Ek,
  man_fairy: Tk,
  angel: vk,
  pregnant_woman: xk,
  breastfeeding: Ak,
  princess: Dk,
  prince: Ck,
  bride_with_veil: Sk,
  man_in_tuxedo: zk,
  running_woman: Nk,
  running_man: Ik,
  walking_woman: Rk,
  walking_man: Fk,
  dancer: Ok,
  man_dancing: Lk,
  dancing_women: Mk,
  dancing_men: Bk,
  couple: Pk,
  two_men_holding_hands: Hk,
  two_women_holding_hands: Uk,
  bowing_woman: jk,
  bowing_man: qk,
  man_facepalming: Yk,
  woman_facepalming: Vk,
  woman_shrugging: Gk,
  man_shrugging: Wk,
  tipping_hand_woman: $k,
  tipping_hand_man: Xk,
  no_good_woman: Qk,
  no_good_man: Kk,
  ok_woman: Jk,
  ok_man: Zk,
  raising_hand_woman: e6,
  raising_hand_man: t6,
  pouting_woman: a6,
  pouting_man: r6,
  frowning_woman: n6,
  frowning_man: s6,
  haircut_woman: i6,
  haircut_man: o6,
  massage_woman: c6,
  massage_man: l6,
  woman_in_steamy_room: u6,
  man_in_steamy_room: f6,
  couple_with_heart_woman_man: h6,
  couple_with_heart_woman_woman: d6,
  couple_with_heart_man_man: m6,
  couplekiss_man_woman: p6,
  couplekiss_woman_woman: g6,
  couplekiss_man_man: y6,
  family_man_woman_boy: _6,
  family_man_woman_girl: b6,
  family_man_woman_girl_boy: k6,
  family_man_woman_boy_boy: w6,
  family_man_woman_girl_girl: E6,
  family_woman_woman_boy: T6,
  family_woman_woman_girl: v6,
  family_woman_woman_girl_boy: x6,
  family_woman_woman_boy_boy: A6,
  family_woman_woman_girl_girl: D6,
  family_man_man_boy: C6,
  family_man_man_girl: S6,
  family_man_man_girl_boy: z6,
  family_man_man_boy_boy: N6,
  family_man_man_girl_girl: I6,
  family_woman_boy: R6,
  family_woman_girl: F6,
  family_woman_girl_boy: O6,
  family_woman_boy_boy: L6,
  family_woman_girl_girl: M6,
  family_man_boy: B6,
  family_man_girl: P6,
  family_man_girl_boy: H6,
  family_man_boy_boy: U6,
  family_man_girl_girl: j6,
  yarn: q6,
  thread: Y6,
  coat: V6,
  labcoat: G6,
  womans_clothes: W6,
  tshirt: $6,
  jeans: X6,
  necktie: Q6,
  dress: K6,
  bikini: J6,
  kimono: Z6,
  lipstick: e5,
  kiss: t5,
  footprints: a5,
  flat_shoe: r5,
  high_heel: n5,
  sandal: s5,
  boot: i5,
  mans_shoe: o5,
  athletic_shoe: c5,
  hiking_boot: l5,
  socks: u5,
  gloves: f5,
  scarf: h5,
  womans_hat: d5,
  tophat: m5,
  billed_hat: p5,
  rescue_worker_helmet: g5,
  mortar_board: y5,
  crown: _5,
  school_satchel: b5,
  luggage: k5,
  pouch: w5,
  purse: E5,
  handbag: T5,
  briefcase: v5,
  eyeglasses: x5,
  dark_sunglasses: A5,
  goggles: D5,
  ring: C5,
  closed_umbrella: S5,
  dog: z5,
  cat: N5,
  mouse: I5,
  hamster: R5,
  rabbit: F5,
  fox_face: O5,
  bear: L5,
  panda_face: M5,
  koala: B5,
  tiger: P5,
  lion: H5,
  cow: U5,
  pig: j5,
  pig_nose: q5,
  frog: Y5,
  squid: V5,
  octopus: G5,
  shrimp: W5,
  monkey_face: $5,
  gorilla: X5,
  see_no_evil: Q5,
  hear_no_evil: K5,
  speak_no_evil: J5,
  monkey: Z5,
  chicken: e7,
  penguin: t7,
  bird: a7,
  baby_chick: r7,
  hatching_chick: n7,
  hatched_chick: s7,
  duck: i7,
  eagle: o7,
  owl: c7,
  bat: l7,
  wolf: u7,
  boar: f7,
  horse: h7,
  unicorn: d7,
  honeybee: m7,
  bug: p7,
  butterfly: g7,
  snail: y7,
  beetle: _7,
  ant: b7,
  grasshopper: k7,
  spider: w7,
  scorpion: E7,
  crab: T7,
  snake: v7,
  lizard: x7,
  "t-rex": {
    keywords: [
      "animal",
      "nature",
      "dinosaur",
      "tyrannosaurus",
      "extinct"
    ],
    char: "",
    fitzpatrick_scale: !1,
    category: "animals_and_nature"
  },
  sauropod: A7,
  turtle: D7,
  tropical_fish: C7,
  fish: S7,
  blowfish: z7,
  dolphin: N7,
  shark: I7,
  whale: R7,
  whale2: F7,
  crocodile: O7,
  leopard: L7,
  zebra: M7,
  tiger2: B7,
  water_buffalo: P7,
  ox: H7,
  cow2: U7,
  deer: j7,
  dromedary_camel: q7,
  camel: Y7,
  giraffe: V7,
  elephant: G7,
  rhinoceros: W7,
  goat: $7,
  ram: X7,
  sheep: Q7,
  racehorse: K7,
  pig2: J7,
  rat: Z7,
  mouse2: e8,
  rooster: t8,
  turkey: a8,
  dove: r8,
  dog2: n8,
  poodle: s8,
  cat2: i8,
  rabbit2: o8,
  chipmunk: c8,
  hedgehog: l8,
  raccoon: u8,
  llama: f8,
  hippopotamus: h8,
  kangaroo: d8,
  badger: m8,
  swan: p8,
  peacock: g8,
  parrot: y8,
  lobster: _8,
  mosquito: b8,
  paw_prints: k8,
  dragon: w8,
  dragon_face: E8,
  cactus: T8,
  christmas_tree: v8,
  evergreen_tree: x8,
  deciduous_tree: A8,
  palm_tree: D8,
  seedling: C8,
  herb: S8,
  shamrock: z8,
  four_leaf_clover: N8,
  bamboo: I8,
  tanabata_tree: R8,
  leaves: F8,
  fallen_leaf: O8,
  maple_leaf: L8,
  ear_of_rice: M8,
  hibiscus: B8,
  sunflower: P8,
  rose: H8,
  wilted_flower: U8,
  tulip: j8,
  blossom: q8,
  cherry_blossom: Y8,
  bouquet: V8,
  mushroom: G8,
  chestnut: W8,
  jack_o_lantern: $8,
  shell: X8,
  spider_web: Q8,
  earth_americas: K8,
  earth_africa: J8,
  earth_asia: Z8,
  full_moon: ew,
  waning_gibbous_moon: tw,
  last_quarter_moon: aw,
  waning_crescent_moon: rw,
  new_moon: nw,
  waxing_crescent_moon: sw,
  first_quarter_moon: iw,
  waxing_gibbous_moon: ow,
  new_moon_with_face: cw,
  full_moon_with_face: lw,
  first_quarter_moon_with_face: uw,
  last_quarter_moon_with_face: fw,
  sun_with_face: hw,
  crescent_moon: dw,
  star: mw,
  star2: pw,
  dizzy: gw,
  sparkles: yw,
  comet: _w,
  sunny: bw,
  sun_behind_small_cloud: kw,
  partly_sunny: ww,
  sun_behind_large_cloud: Ew,
  sun_behind_rain_cloud: Tw,
  cloud: vw,
  cloud_with_rain: xw,
  cloud_with_lightning_and_rain: Aw,
  cloud_with_lightning: Dw,
  zap: Cw,
  fire: Sw,
  boom: zw,
  snowflake: Nw,
  cloud_with_snow: Iw,
  snowman: Rw,
  snowman_with_snow: Fw,
  wind_face: Ow,
  dash: Lw,
  tornado: Mw,
  fog: Bw,
  open_umbrella: Pw,
  umbrella: Hw,
  droplet: Uw,
  sweat_drops: jw,
  ocean: qw,
  green_apple: Yw,
  apple: Vw,
  pear: Gw,
  tangerine: Ww,
  lemon: $w,
  banana: Xw,
  watermelon: Qw,
  grapes: Kw,
  strawberry: Jw,
  melon: Zw,
  cherries: e9,
  peach: t9,
  pineapple: a9,
  coconut: r9,
  kiwi_fruit: n9,
  mango: s9,
  avocado: i9,
  broccoli: o9,
  tomato: c9,
  eggplant: l9,
  cucumber: u9,
  carrot: f9,
  hot_pepper: h9,
  potato: d9,
  corn: m9,
  leafy_greens: p9,
  sweet_potato: g9,
  peanuts: y9,
  honey_pot: _9,
  croissant: b9,
  bread: k9,
  baguette_bread: w9,
  bagel: E9,
  pretzel: T9,
  cheese: v9,
  egg: x9,
  bacon: A9,
  steak: D9,
  pancakes: C9,
  poultry_leg: S9,
  meat_on_bone: z9,
  bone: N9,
  fried_shrimp: I9,
  fried_egg: R9,
  hamburger: F9,
  fries: O9,
  stuffed_flatbread: L9,
  hotdog: M9,
  pizza: B9,
  sandwich: P9,
  canned_food: H9,
  spaghetti: U9,
  taco: j9,
  burrito: q9,
  green_salad: Y9,
  shallow_pan_of_food: V9,
  ramen: G9,
  stew: W9,
  fish_cake: $9,
  fortune_cookie: X9,
  sushi: Q9,
  bento: K9,
  curry: J9,
  rice_ball: Z9,
  rice: eE,
  rice_cracker: tE,
  oden: aE,
  dango: rE,
  shaved_ice: nE,
  ice_cream: sE,
  icecream: iE,
  pie: oE,
  cake: cE,
  cupcake: lE,
  moon_cake: uE,
  birthday: fE,
  custard: hE,
  candy: dE,
  lollipop: mE,
  chocolate_bar: pE,
  popcorn: gE,
  dumpling: yE,
  doughnut: _E,
  cookie: bE,
  milk_glass: kE,
  beer: wE,
  beers: EE,
  clinking_glasses: TE,
  wine_glass: vE,
  tumbler_glass: xE,
  cocktail: AE,
  tropical_drink: DE,
  champagne: CE,
  sake: SE,
  tea: zE,
  cup_with_straw: NE,
  coffee: IE,
  baby_bottle: RE,
  salt: FE,
  spoon: OE,
  fork_and_knife: LE,
  plate_with_cutlery: ME,
  bowl_with_spoon: BE,
  takeout_box: PE,
  chopsticks: HE,
  soccer: UE,
  basketball: jE,
  football: qE,
  baseball: YE,
  softball: VE,
  tennis: GE,
  volleyball: WE,
  rugby_football: $E,
  flying_disc: XE,
  "8ball": {
    keywords: [
      "pool",
      "hobby",
      "game",
      "luck",
      "magic"
    ],
    char: "",
    fitzpatrick_scale: !1,
    category: "activity"
  },
  golf: QE,
  golfing_woman: KE,
  golfing_man: JE,
  ping_pong: ZE,
  badminton: eT,
  goal_net: tT,
  ice_hockey: aT,
  field_hockey: rT,
  lacrosse: nT,
  cricket: sT,
  ski: iT,
  skier: oT,
  snowboarder: cT,
  person_fencing: lT,
  women_wrestling: uT,
  men_wrestling: fT,
  woman_cartwheeling: hT,
  man_cartwheeling: dT,
  woman_playing_handball: mT,
  man_playing_handball: pT,
  ice_skate: gT,
  curling_stone: yT,
  skateboard: _T,
  sled: bT,
  bow_and_arrow: kT,
  fishing_pole_and_fish: wT,
  boxing_glove: ET,
  martial_arts_uniform: TT,
  rowing_woman: vT,
  rowing_man: xT,
  climbing_woman: AT,
  climbing_man: DT,
  swimming_woman: CT,
  swimming_man: ST,
  woman_playing_water_polo: zT,
  man_playing_water_polo: NT,
  woman_in_lotus_position: IT,
  man_in_lotus_position: RT,
  surfing_woman: FT,
  surfing_man: OT,
  bath: LT,
  basketball_woman: MT,
  basketball_man: BT,
  weight_lifting_woman: PT,
  weight_lifting_man: HT,
  biking_woman: UT,
  biking_man: jT,
  mountain_biking_woman: qT,
  mountain_biking_man: YT,
  horse_racing: VT,
  business_suit_levitating: GT,
  trophy: WT,
  running_shirt_with_sash: $T,
  medal_sports: XT,
  medal_military: QT,
  "1st_place_medal": {
    keywords: [
      "award",
      "winning",
      "first"
    ],
    char: "",
    fitzpatrick_scale: !1,
    category: "activity"
  },
  "2nd_place_medal": {
    keywords: [
      "award",
      "second"
    ],
    char: "",
    fitzpatrick_scale: !1,
    category: "activity"
  },
  "3rd_place_medal": {
    keywords: [
      "award",
      "third"
    ],
    char: "",
    fitzpatrick_scale: !1,
    category: "activity"
  },
  reminder_ribbon: KT,
  rosette: JT,
  ticket: ZT,
  tickets: ev,
  performing_arts: tv,
  art: av,
  circus_tent: rv,
  woman_juggling: nv,
  man_juggling: sv,
  microphone: iv,
  headphones: ov,
  musical_score: cv,
  musical_keyboard: lv,
  drum: uv,
  saxophone: fv,
  trumpet: hv,
  guitar: dv,
  violin: mv,
  clapper: pv,
  video_game: gv,
  space_invader: yv,
  dart: _v,
  game_die: bv,
  chess_pawn: kv,
  slot_machine: wv,
  jigsaw: Ev,
  bowling: Tv,
  red_car: vv,
  taxi: xv,
  blue_car: Av,
  bus: Dv,
  trolleybus: Cv,
  racing_car: Sv,
  police_car: zv,
  ambulance: Nv,
  fire_engine: Iv,
  minibus: Rv,
  truck: Fv,
  articulated_lorry: Ov,
  tractor: Lv,
  kick_scooter: Mv,
  motorcycle: Bv,
  bike: Pv,
  motor_scooter: Hv,
  rotating_light: Uv,
  oncoming_police_car: jv,
  oncoming_bus: qv,
  oncoming_automobile: Yv,
  oncoming_taxi: Vv,
  aerial_tramway: Gv,
  mountain_cableway: Wv,
  suspension_railway: $v,
  railway_car: Xv,
  train: Qv,
  monorail: Kv,
  bullettrain_side: Jv,
  bullettrain_front: Zv,
  light_rail: ex,
  mountain_railway: tx,
  steam_locomotive: ax,
  train2: rx,
  metro: nx,
  tram: sx,
  station: ix,
  flying_saucer: ox,
  helicopter: cx,
  small_airplane: lx,
  airplane: ux,
  flight_departure: fx,
  flight_arrival: hx,
  sailboat: dx,
  motor_boat: mx,
  speedboat: px,
  ferry: gx,
  passenger_ship: yx,
  rocket: _x,
  artificial_satellite: bx,
  seat: kx,
  canoe: wx,
  anchor: Ex,
  construction: Tx,
  fuelpump: vx,
  busstop: xx,
  vertical_traffic_light: Ax,
  traffic_light: Dx,
  checkered_flag: Cx,
  ship: Sx,
  ferris_wheel: zx,
  roller_coaster: Nx,
  carousel_horse: Ix,
  building_construction: Rx,
  foggy: Fx,
  tokyo_tower: Ox,
  factory: Lx,
  fountain: Mx,
  rice_scene: Bx,
  mountain: Px,
  mountain_snow: Hx,
  mount_fuji: Ux,
  volcano: jx,
  japan: qx,
  camping: Yx,
  tent: Vx,
  national_park: Gx,
  motorway: Wx,
  railway_track: $x,
  sunrise: Xx,
  sunrise_over_mountains: Qx,
  desert: Kx,
  beach_umbrella: Jx,
  desert_island: Zx,
  city_sunrise: eA,
  city_sunset: tA,
  cityscape: aA,
  night_with_stars: rA,
  bridge_at_night: nA,
  milky_way: sA,
  stars: iA,
  sparkler: oA,
  fireworks: cA,
  rainbow: lA,
  houses: uA,
  european_castle: fA,
  japanese_castle: hA,
  stadium: dA,
  statue_of_liberty: mA,
  house: pA,
  house_with_garden: gA,
  derelict_house: yA,
  office: _A,
  department_store: bA,
  post_office: kA,
  european_post_office: wA,
  hospital: EA,
  bank: TA,
  hotel: vA,
  convenience_store: xA,
  school: AA,
  love_hotel: DA,
  wedding: CA,
  classical_building: SA,
  church: zA,
  mosque: NA,
  synagogue: IA,
  kaaba: RA,
  shinto_shrine: FA,
  watch: OA,
  iphone: LA,
  calling: MA,
  computer: BA,
  keyboard: PA,
  desktop_computer: HA,
  printer: UA,
  computer_mouse: jA,
  trackball: qA,
  joystick: YA,
  clamp: VA,
  minidisc: GA,
  floppy_disk: WA,
  cd: $A,
  dvd: XA,
  vhs: QA,
  camera: KA,
  camera_flash: JA,
  video_camera: ZA,
  movie_camera: eD,
  film_projector: tD,
  film_strip: aD,
  telephone_receiver: rD,
  phone: nD,
  pager: sD,
  fax: iD,
  tv: oD,
  radio: cD,
  studio_microphone: lD,
  level_slider: uD,
  control_knobs: fD,
  compass: hD,
  stopwatch: dD,
  timer_clock: mD,
  alarm_clock: pD,
  mantelpiece_clock: gD,
  hourglass_flowing_sand: yD,
  hourglass: _D,
  satellite: bD,
  battery: kD,
  electric_plug: wD,
  bulb: ED,
  flashlight: TD,
  candle: vD,
  fire_extinguisher: xD,
  wastebasket: AD,
  oil_drum: DD,
  money_with_wings: CD,
  dollar: SD,
  yen: zD,
  euro: ND,
  pound: ID,
  moneybag: RD,
  credit_card: FD,
  gem: OD,
  balance_scale: LD,
  toolbox: MD,
  wrench: BD,
  hammer: PD,
  hammer_and_pick: HD,
  hammer_and_wrench: UD,
  pick: jD,
  nut_and_bolt: qD,
  gear: YD,
  brick: VD,
  chains: GD,
  magnet: WD,
  gun: $D,
  bomb: XD,
  firecracker: QD,
  hocho: KD,
  dagger: JD,
  crossed_swords: ZD,
  shield: eC,
  smoking: tC,
  skull_and_crossbones: aC,
  coffin: rC,
  funeral_urn: nC,
  amphora: sC,
  crystal_ball: iC,
  prayer_beads: oC,
  nazar_amulet: cC,
  barber: lC,
  alembic: uC,
  telescope: fC,
  microscope: hC,
  hole: dC,
  pill: mC,
  syringe: pC,
  dna: gC,
  microbe: yC,
  petri_dish: _C,
  test_tube: bC,
  thermometer: kC,
  broom: wC,
  basket: EC,
  toilet_paper: TC,
  label: vC,
  bookmark: xC,
  toilet: AC,
  shower: DC,
  bathtub: CC,
  soap: SC,
  sponge: zC,
  lotion_bottle: NC,
  key: IC,
  old_key: RC,
  couch_and_lamp: FC,
  sleeping_bed: OC,
  bed: LC,
  door: MC,
  bellhop_bell: BC,
  teddy_bear: PC,
  framed_picture: HC,
  world_map: UC,
  parasol_on_ground: jC,
  moyai: qC,
  shopping: YC,
  shopping_cart: VC,
  balloon: GC,
  flags: WC,
  ribbon: $C,
  gift: XC,
  confetti_ball: QC,
  tada: KC,
  dolls: JC,
  wind_chime: ZC,
  crossed_flags: eS,
  izakaya_lantern: tS,
  red_envelope: aS,
  email: rS,
  envelope_with_arrow: nS,
  incoming_envelope: sS,
  "e-mail": {
    keywords: [
      "communication",
      "inbox"
    ],
    char: "",
    fitzpatrick_scale: !1,
    category: "objects"
  },
  love_letter: iS,
  postbox: oS,
  mailbox_closed: cS,
  mailbox: lS,
  mailbox_with_mail: uS,
  mailbox_with_no_mail: fS,
  package: {
    keywords: [
      "mail",
      "gift",
      "cardboard",
      "box",
      "moving"
    ],
    char: "",
    fitzpatrick_scale: !1,
    category: "objects"
  },
  postal_horn: hS,
  inbox_tray: dS,
  outbox_tray: mS,
  scroll: pS,
  page_with_curl: gS,
  bookmark_tabs: yS,
  receipt: _S,
  bar_chart: bS,
  chart_with_upwards_trend: kS,
  chart_with_downwards_trend: wS,
  page_facing_up: ES,
  date: TS,
  calendar: vS,
  spiral_calendar: xS,
  card_index: AS,
  card_file_box: DS,
  ballot_box: CS,
  file_cabinet: SS,
  clipboard: zS,
  spiral_notepad: NS,
  file_folder: IS,
  open_file_folder: RS,
  card_index_dividers: FS,
  newspaper_roll: OS,
  newspaper: LS,
  notebook: MS,
  closed_book: BS,
  green_book: PS,
  blue_book: HS,
  orange_book: US,
  notebook_with_decorative_cover: jS,
  ledger: qS,
  books: YS,
  open_book: VS,
  safety_pin: GS,
  link: WS,
  paperclip: $S,
  paperclips: XS,
  scissors: QS,
  triangular_ruler: KS,
  straight_ruler: JS,
  abacus: ZS,
  pushpin: ez,
  round_pushpin: tz,
  triangular_flag_on_post: az,
  white_flag: rz,
  black_flag: nz,
  rainbow_flag: sz,
  closed_lock_with_key: iz,
  lock: oz,
  unlock: cz,
  lock_with_ink_pen: lz,
  pen: uz,
  fountain_pen: fz,
  black_nib: hz,
  memo: dz,
  pencil2: mz,
  crayon: pz,
  paintbrush: gz,
  mag: yz,
  mag_right: _z,
  heart: bz,
  orange_heart: kz,
  yellow_heart: wz,
  green_heart: Ez,
  blue_heart: Tz,
  purple_heart: vz,
  black_heart: xz,
  broken_heart: Az,
  heavy_heart_exclamation: Dz,
  two_hearts: Cz,
  revolving_hearts: Sz,
  heartbeat: zz,
  heartpulse: Nz,
  sparkling_heart: Iz,
  cupid: Rz,
  gift_heart: Fz,
  heart_decoration: Oz,
  peace_symbol: Lz,
  latin_cross: Mz,
  star_and_crescent: Bz,
  om: Pz,
  wheel_of_dharma: Hz,
  star_of_david: Uz,
  six_pointed_star: jz,
  menorah: qz,
  yin_yang: Yz,
  orthodox_cross: Vz,
  place_of_worship: Gz,
  ophiuchus: Wz,
  aries: $z,
  taurus: Xz,
  gemini: Qz,
  cancer: Kz,
  leo: Jz,
  virgo: Zz,
  libra: eN,
  scorpius: tN,
  sagittarius: aN,
  capricorn: rN,
  aquarius: nN,
  pisces: sN,
  id: iN,
  atom_symbol: oN,
  u7a7a: cN,
  u5272: lN,
  radioactive: uN,
  biohazard: fN,
  mobile_phone_off: hN,
  vibration_mode: dN,
  u6709: mN,
  u7121: pN,
  u7533: gN,
  u55b6: yN,
  u6708: _N,
  eight_pointed_black_star: bN,
  vs: kN,
  accept: wN,
  white_flower: EN,
  ideograph_advantage: TN,
  secret: vN,
  congratulations: xN,
  u5408: AN,
  u6e80: DN,
  u7981: CN,
  a: SN,
  b: zN,
  ab: NN,
  cl: IN,
  o2: RN,
  sos: FN,
  no_entry: ON,
  name_badge: LN,
  no_entry_sign: MN,
  x: BN,
  o: PN,
  stop_sign: HN,
  anger: UN,
  hotsprings: jN,
  no_pedestrians: qN,
  do_not_litter: YN,
  no_bicycles: VN,
  "non-potable_water": {
    keywords: [
      "drink",
      "faucet",
      "tap",
      "circle"
    ],
    char: "",
    fitzpatrick_scale: !1,
    category: "symbols"
  },
  underage: GN,
  no_mobile_phones: WN,
  exclamation: $N,
  grey_exclamation: XN,
  question: QN,
  grey_question: KN,
  bangbang: JN,
  interrobang: ZN,
  low_brightness: eI,
  high_brightness: tI,
  trident: aI,
  fleur_de_lis: rI,
  part_alternation_mark: nI,
  warning: sI,
  children_crossing: iI,
  beginner: oI,
  recycle: cI,
  u6307: lI,
  chart: uI,
  sparkle: fI,
  eight_spoked_asterisk: hI,
  negative_squared_cross_mark: dI,
  white_check_mark: mI,
  diamond_shape_with_a_dot_inside: pI,
  cyclone: gI,
  loop: yI,
  globe_with_meridians: _I,
  m: bI,
  atm: kI,
  sa: wI,
  passport_control: EI,
  customs: TI,
  baggage_claim: vI,
  left_luggage: xI,
  wheelchair: AI,
  no_smoking: DI,
  wc: CI,
  parking: SI,
  potable_water: zI,
  mens: NI,
  womens: II,
  baby_symbol: RI,
  restroom: FI,
  put_litter_in_its_place: OI,
  cinema: LI,
  signal_strength: MI,
  koko: BI,
  ng: PI,
  ok: HI,
  up: UI,
  cool: jI,
  new: {
    keywords: [
      "blue-square",
      "words",
      "start"
    ],
    char: "",
    fitzpatrick_scale: !1,
    category: "symbols"
  },
  free: qI,
  zero: YI,
  one: VI,
  two: GI,
  three: WI,
  four: $I,
  five: XI,
  six: QI,
  seven: KI,
  eight: JI,
  nine: ZI,
  keycap_ten: eR,
  asterisk: tR,
  eject_button: aR,
  arrow_forward: rR,
  pause_button: nR,
  next_track_button: sR,
  stop_button: iR,
  record_button: oR,
  play_or_pause_button: cR,
  previous_track_button: lR,
  fast_forward: uR,
  rewind: fR,
  twisted_rightwards_arrows: hR,
  repeat: dR,
  repeat_one: mR,
  arrow_backward: pR,
  arrow_up_small: gR,
  arrow_down_small: yR,
  arrow_double_up: _R,
  arrow_double_down: bR,
  arrow_right: kR,
  arrow_left: wR,
  arrow_up: ER,
  arrow_down: TR,
  arrow_upper_right: vR,
  arrow_lower_right: xR,
  arrow_lower_left: AR,
  arrow_upper_left: DR,
  arrow_up_down: CR,
  left_right_arrow: SR,
  arrows_counterclockwise: zR,
  arrow_right_hook: NR,
  leftwards_arrow_with_hook: IR,
  arrow_heading_up: RR,
  arrow_heading_down: FR,
  hash: OR,
  information_source: LR,
  abc: MR,
  abcd: BR,
  capital_abcd: PR,
  symbols: HR,
  musical_note: UR,
  notes: jR,
  wavy_dash: qR,
  curly_loop: YR,
  heavy_check_mark: VR,
  arrows_clockwise: GR,
  heavy_plus_sign: WR,
  heavy_minus_sign: $R,
  heavy_division_sign: XR,
  heavy_multiplication_x: QR,
  infinity: KR,
  heavy_dollar_sign: JR,
  currency_exchange: ZR,
  copyright: eF,
  registered: tF,
  tm: aF,
  end: rF,
  back: nF,
  on: sF,
  top: iF,
  soon: oF,
  ballot_box_with_check: cF,
  radio_button: lF,
  white_circle: uF,
  black_circle: fF,
  red_circle: hF,
  large_blue_circle: dF,
  small_orange_diamond: mF,
  small_blue_diamond: pF,
  large_orange_diamond: gF,
  large_blue_diamond: yF,
  small_red_triangle: _F,
  black_small_square: bF,
  white_small_square: kF,
  black_large_square: wF,
  white_large_square: EF,
  small_red_triangle_down: TF,
  black_medium_square: vF,
  white_medium_square: xF,
  black_medium_small_square: AF,
  white_medium_small_square: DF,
  black_square_button: CF,
  white_square_button: SF,
  speaker: zF,
  sound: NF,
  loud_sound: IF,
  mute: RF,
  mega: FF,
  loudspeaker: OF,
  bell: LF,
  no_bell: MF,
  black_joker: BF,
  mahjong: PF,
  spades: HF,
  clubs: UF,
  hearts: jF,
  diamonds: qF,
  flower_playing_cards: YF,
  thought_balloon: VF,
  right_anger_bubble: GF,
  speech_balloon: WF,
  left_speech_bubble: $F,
  clock1: XF,
  clock2: QF,
  clock3: KF,
  clock4: JF,
  clock5: ZF,
  clock6: eO,
  clock7: tO,
  clock8: aO,
  clock9: rO,
  clock10: nO,
  clock11: sO,
  clock12: iO,
  clock130: oO,
  clock230: cO,
  clock330: lO,
  clock430: uO,
  clock530: fO,
  clock630: hO,
  clock730: dO,
  clock830: mO,
  clock930: pO,
  clock1030: gO,
  clock1130: yO,
  clock1230: _O,
  afghanistan: bO,
  aland_islands: kO,
  albania: wO,
  algeria: EO,
  american_samoa: TO,
  andorra: vO,
  angola: xO,
  anguilla: AO,
  antarctica: DO,
  antigua_barbuda: CO,
  argentina: SO,
  armenia: zO,
  aruba: NO,
  australia: IO,
  austria: RO,
  azerbaijan: FO,
  bahamas: OO,
  bahrain: LO,
  bangladesh: MO,
  barbados: BO,
  belarus: PO,
  belgium: HO,
  belize: UO,
  benin: jO,
  bermuda: qO,
  bhutan: YO,
  bolivia: VO,
  caribbean_netherlands: GO,
  bosnia_herzegovina: WO,
  botswana: $O,
  brazil: XO,
  british_indian_ocean_territory: QO,
  british_virgin_islands: KO,
  brunei: JO,
  bulgaria: ZO,
  burkina_faso: eL,
  burundi: tL,
  cape_verde: aL,
  cambodia: rL,
  cameroon: nL,
  canada: sL,
  canary_islands: iL,
  cayman_islands: oL,
  central_african_republic: cL,
  chad: lL,
  chile: uL,
  cn: fL,
  christmas_island: hL,
  cocos_islands: dL,
  colombia: mL,
  comoros: pL,
  congo_brazzaville: gL,
  congo_kinshasa: yL,
  cook_islands: _L,
  costa_rica: bL,
  croatia: kL,
  cuba: wL,
  curacao: EL,
  cyprus: TL,
  czech_republic: vL,
  denmark: xL,
  djibouti: AL,
  dominica: DL,
  dominican_republic: CL,
  ecuador: SL,
  egypt: zL,
  el_salvador: NL,
  equatorial_guinea: IL,
  eritrea: RL,
  estonia: FL,
  ethiopia: OL,
  eu: LL,
  falkland_islands: ML,
  faroe_islands: BL,
  fiji: PL,
  finland: HL,
  fr: UL,
  french_guiana: jL,
  french_polynesia: qL,
  french_southern_territories: YL,
  gabon: VL,
  gambia: GL,
  georgia: WL,
  de: $L,
  ghana: XL,
  gibraltar: QL,
  greece: KL,
  greenland: JL,
  grenada: ZL,
  guadeloupe: eM,
  guam: tM,
  guatemala: aM,
  guernsey: rM,
  guinea: nM,
  guinea_bissau: sM,
  guyana: iM,
  haiti: oM,
  honduras: cM,
  hong_kong: lM,
  hungary: uM,
  iceland: fM,
  india: hM,
  indonesia: dM,
  iran: mM,
  iraq: pM,
  ireland: gM,
  isle_of_man: yM,
  israel: _M,
  it: bM,
  cote_divoire: kM,
  jamaica: wM,
  jp: EM,
  jersey: TM,
  jordan: vM,
  kazakhstan: xM,
  kenya: AM,
  kiribati: DM,
  kosovo: CM,
  kuwait: SM,
  kyrgyzstan: zM,
  laos: NM,
  latvia: IM,
  lebanon: RM,
  lesotho: FM,
  liberia: OM,
  libya: LM,
  liechtenstein: MM,
  lithuania: BM,
  luxembourg: PM,
  macau: HM,
  macedonia: UM,
  madagascar: jM,
  malawi: qM,
  malaysia: YM,
  maldives: VM,
  mali: GM,
  malta: WM,
  marshall_islands: $M,
  martinique: XM,
  mauritania: QM,
  mauritius: KM,
  mayotte: JM,
  mexico: ZM,
  micronesia: eB,
  moldova: tB,
  monaco: aB,
  mongolia: rB,
  montenegro: nB,
  montserrat: sB,
  morocco: iB,
  mozambique: oB,
  myanmar: cB,
  namibia: lB,
  nauru: uB,
  nepal: fB,
  netherlands: hB,
  new_caledonia: dB,
  new_zealand: mB,
  nicaragua: pB,
  niger: gB,
  nigeria: yB,
  niue: _B,
  norfolk_island: bB,
  northern_mariana_islands: kB,
  north_korea: wB,
  norway: EB,
  oman: TB,
  pakistan: vB,
  palau: xB,
  palestinian_territories: AB,
  panama: DB,
  papua_new_guinea: CB,
  paraguay: SB,
  peru: zB,
  philippines: NB,
  pitcairn_islands: IB,
  poland: RB,
  portugal: FB,
  puerto_rico: OB,
  qatar: LB,
  reunion: MB,
  romania: BB,
  ru: PB,
  rwanda: HB,
  st_barthelemy: UB,
  st_helena: jB,
  st_kitts_nevis: qB,
  st_lucia: YB,
  st_pierre_miquelon: VB,
  st_vincent_grenadines: GB,
  samoa: WB,
  san_marino: $B,
  sao_tome_principe: XB,
  saudi_arabia: QB,
  senegal: KB,
  serbia: JB,
  seychelles: ZB,
  sierra_leone: eP,
  singapore: tP,
  sint_maarten: aP,
  slovakia: rP,
  slovenia: nP,
  solomon_islands: sP,
  somalia: iP,
  south_africa: oP,
  south_georgia_south_sandwich_islands: cP,
  kr: lP,
  south_sudan: uP,
  es: fP,
  sri_lanka: hP,
  sudan: dP,
  suriname: mP,
  swaziland: pP,
  sweden: gP,
  switzerland: yP,
  syria: _P,
  taiwan: bP,
  tajikistan: kP,
  tanzania: wP,
  thailand: EP,
  timor_leste: TP,
  togo: vP,
  tokelau: xP,
  tonga: AP,
  trinidad_tobago: DP,
  tunisia: CP,
  tr: SP,
  turkmenistan: zP,
  turks_caicos_islands: NP,
  tuvalu: IP,
  uganda: RP,
  ukraine: FP,
  united_arab_emirates: OP,
  uk: LP,
  england: MP,
  scotland: BP,
  wales: PP,
  us: HP,
  us_virgin_islands: UP,
  uruguay: jP,
  uzbekistan: qP,
  vanuatu: YP,
  vatican_city: VP,
  venezuela: GP,
  vietnam: WP,
  wallis_futuna: $P,
  western_sahara: XP,
  yemen: QP,
  zambia: KP,
  zimbabwe: JP,
  united_nations: ZP,
  pirate_flag: eH
}, aH = [
  "grinning",
  "smiley",
  "smile",
  "grin",
  "laughing",
  "sweat_smile",
  "joy",
  "rofl",
  "relaxed",
  "blush",
  "innocent",
  "slightly_smiling_face",
  "upside_down_face",
  "wink",
  "relieved",
  "heart_eyes",
  "smiling_face_with_three_hearts",
  "kissing_heart",
  "kissing",
  "kissing_smiling_eyes",
  "kissing_closed_eyes",
  "yum",
  "stuck_out_tongue",
  "stuck_out_tongue_closed_eyes",
  "stuck_out_tongue_winking_eye",
  "zany",
  "raised_eyebrow",
  "monocle",
  "nerd_face",
  "sunglasses",
  "star_struck",
  "partying",
  "smirk",
  "unamused",
  "disappointed",
  "pensive",
  "worried",
  "confused",
  "slightly_frowning_face",
  "frowning_face",
  "persevere",
  "confounded",
  "tired_face",
  "weary",
  "pleading",
  "cry",
  "sob",
  "triumph",
  "angry",
  "rage",
  "symbols_over_mouth",
  "exploding_head",
  "flushed",
  "hot",
  "cold",
  "scream",
  "fearful",
  "cold_sweat",
  "disappointed_relieved",
  "sweat",
  "hugs",
  "thinking",
  "hand_over_mouth",
  "shushing",
  "lying_face",
  "no_mouth",
  "neutral_face",
  "expressionless",
  "grimacing",
  "roll_eyes",
  "hushed",
  "frowning",
  "anguished",
  "open_mouth",
  "astonished",
  "sleeping",
  "drooling_face",
  "sleepy",
  "dizzy_face",
  "zipper_mouth_face",
  "woozy",
  "nauseated_face",
  "vomiting",
  "sneezing_face",
  "mask",
  "face_with_thermometer",
  "face_with_head_bandage",
  "money_mouth_face",
  "cowboy_hat_face",
  "smiling_imp",
  "imp",
  "japanese_ogre",
  "japanese_goblin",
  "clown_face",
  "poop",
  "ghost",
  "skull",
  "skull_and_crossbones",
  "alien",
  "space_invader",
  "robot",
  "jack_o_lantern",
  "smiley_cat",
  "smile_cat",
  "joy_cat",
  "heart_eyes_cat",
  "smirk_cat",
  "kissing_cat",
  "scream_cat",
  "crying_cat_face",
  "pouting_cat",
  "palms_up",
  "open_hands",
  "raised_hands",
  "clap",
  "handshake",
  "+1",
  "-1",
  "facepunch",
  "fist",
  "fist_left",
  "fist_right",
  "crossed_fingers",
  "v",
  "love_you",
  "metal",
  "ok_hand",
  "point_left",
  "point_right",
  "point_up",
  "point_down",
  "point_up_2",
  "raised_hand",
  "raised_back_of_hand",
  "raised_hand_with_fingers_splayed",
  "vulcan_salute",
  "wave",
  "call_me_hand",
  "muscle",
  "fu",
  "writing_hand",
  "pray",
  "foot",
  "leg",
  "ring",
  "lipstick",
  "kiss",
  "lips",
  "tooth",
  "tongue",
  "ear",
  "nose",
  "footprints",
  "eye",
  "eyes",
  "brain",
  "speaking_head",
  "bust_in_silhouette",
  "busts_in_silhouette",
  "baby",
  "girl",
  "child",
  "boy",
  "woman",
  "adult",
  "man",
  "blonde_woman",
  "blonde_man",
  "bearded_person",
  "older_woman",
  "older_adult",
  "older_man",
  "man_with_gua_pi_mao",
  "woman_with_headscarf",
  "woman_with_turban",
  "man_with_turban",
  "policewoman",
  "policeman",
  "construction_worker_woman",
  "construction_worker_man",
  "guardswoman",
  "guardsman",
  "female_detective",
  "male_detective",
  "woman_health_worker",
  "man_health_worker",
  "woman_farmer",
  "man_farmer",
  "woman_cook",
  "man_cook",
  "woman_student",
  "man_student",
  "woman_singer",
  "man_singer",
  "woman_teacher",
  "man_teacher",
  "woman_factory_worker",
  "man_factory_worker",
  "woman_technologist",
  "man_technologist",
  "woman_office_worker",
  "man_office_worker",
  "woman_mechanic",
  "man_mechanic",
  "woman_scientist",
  "man_scientist",
  "woman_artist",
  "man_artist",
  "woman_firefighter",
  "man_firefighter",
  "woman_pilot",
  "man_pilot",
  "woman_astronaut",
  "man_astronaut",
  "woman_judge",
  "man_judge",
  "bride_with_veil",
  "man_in_tuxedo",
  "princess",
  "prince",
  "woman_superhero",
  "man_superhero",
  "woman_supervillain",
  "man_supervillain",
  "mrs_claus",
  "santa",
  "sorceress",
  "wizard",
  "woman_elf",
  "man_elf",
  "woman_vampire",
  "man_vampire",
  "woman_zombie",
  "man_zombie",
  "woman_genie",
  "man_genie",
  "mermaid",
  "merman",
  "woman_fairy",
  "man_fairy",
  "angel",
  "pregnant_woman",
  "breastfeeding",
  "bowing_woman",
  "bowing_man",
  "tipping_hand_woman",
  "tipping_hand_man",
  "no_good_woman",
  "no_good_man",
  "ok_woman",
  "ok_man",
  "raising_hand_woman",
  "raising_hand_man",
  "woman_facepalming",
  "man_facepalming",
  "woman_shrugging",
  "man_shrugging",
  "pouting_woman",
  "pouting_man",
  "frowning_woman",
  "frowning_man",
  "haircut_woman",
  "haircut_man",
  "massage_woman",
  "massage_man",
  "woman_in_steamy_room",
  "man_in_steamy_room",
  "nail_care",
  "selfie",
  "dancer",
  "man_dancing",
  "dancing_women",
  "dancing_men",
  "business_suit_levitating",
  "walking_woman",
  "walking_man",
  "running_woman",
  "running_man",
  "couple",
  "two_women_holding_hands",
  "two_men_holding_hands",
  "couple_with_heart_woman_man",
  "couple_with_heart_woman_woman",
  "couple_with_heart_man_man",
  "couplekiss_man_woman",
  "couplekiss_woman_woman",
  "couplekiss_man_man",
  "family_man_woman_boy",
  "family_man_woman_girl",
  "family_man_woman_girl_boy",
  "family_man_woman_boy_boy",
  "family_man_woman_girl_girl",
  "family_woman_woman_boy",
  "family_woman_woman_girl",
  "family_woman_woman_girl_boy",
  "family_woman_woman_boy_boy",
  "family_woman_woman_girl_girl",
  "family_man_man_boy",
  "family_man_man_girl",
  "family_man_man_girl_boy",
  "family_man_man_boy_boy",
  "family_man_man_girl_girl",
  "family_woman_boy",
  "family_woman_girl",
  "family_woman_girl_boy",
  "family_woman_boy_boy",
  "family_woman_girl_girl",
  "family_man_boy",
  "family_man_girl",
  "family_man_girl_boy",
  "family_man_boy_boy",
  "family_man_girl_girl",
  "yarn",
  "thread",
  "coat",
  "labcoat",
  "womans_clothes",
  "tshirt",
  "jeans",
  "necktie",
  "dress",
  "bikini",
  "kimono",
  "flat_shoe",
  "high_heel",
  "sandal",
  "boot",
  "mans_shoe",
  "athletic_shoe",
  "hiking_boot",
  "socks",
  "gloves",
  "scarf",
  "tophat",
  "billed_hat",
  "womans_hat",
  "mortar_board",
  "rescue_worker_helmet",
  "crown",
  "pouch",
  "purse",
  "handbag",
  "briefcase",
  "school_satchel",
  "luggage",
  "eyeglasses",
  "dark_sunglasses",
  "goggles",
  "closed_umbrella",
  "dog",
  "cat",
  "mouse",
  "hamster",
  "rabbit",
  "fox_face",
  "bear",
  "panda_face",
  "koala",
  "tiger",
  "lion",
  "cow",
  "pig",
  "pig_nose",
  "frog",
  "monkey_face",
  "see_no_evil",
  "hear_no_evil",
  "speak_no_evil",
  "monkey",
  "chicken",
  "penguin",
  "bird",
  "baby_chick",
  "hatching_chick",
  "hatched_chick",
  "duck",
  "eagle",
  "owl",
  "bat",
  "wolf",
  "boar",
  "horse",
  "unicorn",
  "honeybee",
  "bug",
  "butterfly",
  "snail",
  "shell",
  "beetle",
  "ant",
  "mosquito",
  "grasshopper",
  "spider",
  "spider_web",
  "scorpion",
  "turtle",
  "snake",
  "lizard",
  "t-rex",
  "sauropod",
  "octopus",
  "squid",
  "shrimp",
  "lobster",
  "crab",
  "blowfish",
  "tropical_fish",
  "fish",
  "dolphin",
  "whale",
  "whale2",
  "shark",
  "crocodile",
  "tiger2",
  "leopard",
  "zebra",
  "gorilla",
  "elephant",
  "hippopotamus",
  "rhinoceros",
  "dromedary_camel",
  "giraffe",
  "kangaroo",
  "camel",
  "water_buffalo",
  "ox",
  "cow2",
  "racehorse",
  "pig2",
  "ram",
  "sheep",
  "llama",
  "goat",
  "deer",
  "dog2",
  "poodle",
  "cat2",
  "rooster",
  "turkey",
  "peacock",
  "parrot",
  "swan",
  "dove",
  "rabbit2",
  "raccoon",
  "badger",
  "rat",
  "mouse2",
  "chipmunk",
  "hedgehog",
  "paw_prints",
  "dragon",
  "dragon_face",
  "cactus",
  "christmas_tree",
  "evergreen_tree",
  "deciduous_tree",
  "palm_tree",
  "seedling",
  "herb",
  "shamrock",
  "four_leaf_clover",
  "bamboo",
  "tanabata_tree",
  "leaves",
  "fallen_leaf",
  "maple_leaf",
  "ear_of_rice",
  "hibiscus",
  "sunflower",
  "rose",
  "wilted_flower",
  "tulip",
  "blossom",
  "cherry_blossom",
  "bouquet",
  "mushroom",
  "earth_americas",
  "earth_africa",
  "earth_asia",
  "full_moon",
  "waning_gibbous_moon",
  "last_quarter_moon",
  "waning_crescent_moon",
  "new_moon",
  "waxing_crescent_moon",
  "first_quarter_moon",
  "waxing_gibbous_moon",
  "new_moon_with_face",
  "full_moon_with_face",
  "first_quarter_moon_with_face",
  "last_quarter_moon_with_face",
  "sun_with_face",
  "crescent_moon",
  "star",
  "star2",
  "dizzy",
  "sparkles",
  "comet",
  "sunny",
  "sun_behind_small_cloud",
  "partly_sunny",
  "sun_behind_large_cloud",
  "sun_behind_rain_cloud",
  "cloud",
  "cloud_with_rain",
  "cloud_with_lightning_and_rain",
  "cloud_with_lightning",
  "zap",
  "fire",
  "boom",
  "snowflake",
  "cloud_with_snow",
  "snowman",
  "snowman_with_snow",
  "wind_face",
  "dash",
  "tornado",
  "fog",
  "open_umbrella",
  "umbrella",
  "droplet",
  "sweat_drops",
  "ocean",
  "green_apple",
  "apple",
  "pear",
  "tangerine",
  "lemon",
  "banana",
  "watermelon",
  "grapes",
  "strawberry",
  "melon",
  "cherries",
  "peach",
  "mango",
  "pineapple",
  "coconut",
  "kiwi_fruit",
  "tomato",
  "eggplant",
  "avocado",
  "broccoli",
  "leafy_greens",
  "cucumber",
  "hot_pepper",
  "corn",
  "carrot",
  "potato",
  "sweet_potato",
  "croissant",
  "bagel",
  "bread",
  "baguette_bread",
  "pretzel",
  "cheese",
  "egg",
  "fried_egg",
  "pancakes",
  "bacon",
  "steak",
  "poultry_leg",
  "meat_on_bone",
  "bone",
  "hotdog",
  "hamburger",
  "fries",
  "pizza",
  "sandwich",
  "stuffed_flatbread",
  "taco",
  "burrito",
  "green_salad",
  "shallow_pan_of_food",
  "canned_food",
  "spaghetti",
  "ramen",
  "stew",
  "curry",
  "sushi",
  "bento",
  "fried_shrimp",
  "rice_ball",
  "rice",
  "rice_cracker",
  "fish_cake",
  "fortune_cookie",
  "moon_cake",
  "oden",
  "dango",
  "shaved_ice",
  "ice_cream",
  "icecream",
  "pie",
  "cupcake",
  "cake",
  "birthday",
  "custard",
  "lollipop",
  "candy",
  "chocolate_bar",
  "popcorn",
  "doughnut",
  "dumpling",
  "cookie",
  "chestnut",
  "peanuts",
  "honey_pot",
  "milk_glass",
  "baby_bottle",
  "coffee",
  "tea",
  "cup_with_straw",
  "sake",
  "beer",
  "beers",
  "clinking_glasses",
  "wine_glass",
  "tumbler_glass",
  "cocktail",
  "tropical_drink",
  "champagne",
  "spoon",
  "fork_and_knife",
  "plate_with_cutlery",
  "bowl_with_spoon",
  "takeout_box",
  "chopsticks",
  "salt",
  "soccer",
  "basketball",
  "football",
  "baseball",
  "softball",
  "tennis",
  "volleyball",
  "rugby_football",
  "flying_disc",
  "8ball",
  "golf",
  "golfing_woman",
  "golfing_man",
  "ping_pong",
  "badminton",
  "goal_net",
  "ice_hockey",
  "field_hockey",
  "lacrosse",
  "cricket",
  "ski",
  "skier",
  "snowboarder",
  "person_fencing",
  "women_wrestling",
  "men_wrestling",
  "woman_cartwheeling",
  "man_cartwheeling",
  "woman_playing_handball",
  "man_playing_handball",
  "ice_skate",
  "curling_stone",
  "skateboard",
  "sled",
  "bow_and_arrow",
  "fishing_pole_and_fish",
  "boxing_glove",
  "martial_arts_uniform",
  "rowing_woman",
  "rowing_man",
  "climbing_woman",
  "climbing_man",
  "swimming_woman",
  "swimming_man",
  "woman_playing_water_polo",
  "man_playing_water_polo",
  "woman_in_lotus_position",
  "man_in_lotus_position",
  "surfing_woman",
  "surfing_man",
  "basketball_woman",
  "basketball_man",
  "weight_lifting_woman",
  "weight_lifting_man",
  "biking_woman",
  "biking_man",
  "mountain_biking_woman",
  "mountain_biking_man",
  "horse_racing",
  "trophy",
  "running_shirt_with_sash",
  "medal_sports",
  "medal_military",
  "1st_place_medal",
  "2nd_place_medal",
  "3rd_place_medal",
  "reminder_ribbon",
  "rosette",
  "ticket",
  "tickets",
  "performing_arts",
  "art",
  "circus_tent",
  "woman_juggling",
  "man_juggling",
  "microphone",
  "headphones",
  "musical_score",
  "musical_keyboard",
  "drum",
  "saxophone",
  "trumpet",
  "guitar",
  "violin",
  "clapper",
  "video_game",
  "dart",
  "game_die",
  "chess_pawn",
  "slot_machine",
  "jigsaw",
  "bowling",
  "red_car",
  "taxi",
  "blue_car",
  "bus",
  "trolleybus",
  "racing_car",
  "police_car",
  "ambulance",
  "fire_engine",
  "minibus",
  "truck",
  "articulated_lorry",
  "tractor",
  "kick_scooter",
  "motorcycle",
  "bike",
  "motor_scooter",
  "rotating_light",
  "oncoming_police_car",
  "oncoming_bus",
  "oncoming_automobile",
  "oncoming_taxi",
  "aerial_tramway",
  "mountain_cableway",
  "suspension_railway",
  "railway_car",
  "train",
  "monorail",
  "bullettrain_side",
  "bullettrain_front",
  "light_rail",
  "mountain_railway",
  "steam_locomotive",
  "train2",
  "metro",
  "tram",
  "station",
  "flying_saucer",
  "helicopter",
  "small_airplane",
  "airplane",
  "flight_departure",
  "flight_arrival",
  "sailboat",
  "motor_boat",
  "speedboat",
  "ferry",
  "passenger_ship",
  "rocket",
  "artificial_satellite",
  "seat",
  "canoe",
  "anchor",
  "construction",
  "fuelpump",
  "busstop",
  "vertical_traffic_light",
  "traffic_light",
  "ship",
  "ferris_wheel",
  "roller_coaster",
  "carousel_horse",
  "building_construction",
  "foggy",
  "tokyo_tower",
  "factory",
  "fountain",
  "rice_scene",
  "mountain",
  "mountain_snow",
  "mount_fuji",
  "volcano",
  "japan",
  "camping",
  "tent",
  "national_park",
  "motorway",
  "railway_track",
  "sunrise",
  "sunrise_over_mountains",
  "desert",
  "beach_umbrella",
  "desert_island",
  "city_sunrise",
  "city_sunset",
  "cityscape",
  "night_with_stars",
  "bridge_at_night",
  "milky_way",
  "stars",
  "sparkler",
  "fireworks",
  "rainbow",
  "houses",
  "european_castle",
  "japanese_castle",
  "stadium",
  "statue_of_liberty",
  "house",
  "house_with_garden",
  "derelict_house",
  "office",
  "department_store",
  "post_office",
  "european_post_office",
  "hospital",
  "bank",
  "hotel",
  "convenience_store",
  "school",
  "love_hotel",
  "wedding",
  "classical_building",
  "church",
  "mosque",
  "synagogue",
  "kaaba",
  "shinto_shrine",
  "watch",
  "iphone",
  "calling",
  "computer",
  "keyboard",
  "desktop_computer",
  "printer",
  "computer_mouse",
  "trackball",
  "joystick",
  "clamp",
  "minidisc",
  "floppy_disk",
  "cd",
  "dvd",
  "vhs",
  "camera",
  "camera_flash",
  "video_camera",
  "movie_camera",
  "film_projector",
  "film_strip",
  "telephone_receiver",
  "phone",
  "pager",
  "fax",
  "tv",
  "radio",
  "studio_microphone",
  "level_slider",
  "control_knobs",
  "compass",
  "stopwatch",
  "timer_clock",
  "alarm_clock",
  "mantelpiece_clock",
  "hourglass_flowing_sand",
  "hourglass",
  "satellite",
  "battery",
  "electric_plug",
  "bulb",
  "flashlight",
  "candle",
  "fire_extinguisher",
  "wastebasket",
  "oil_drum",
  "money_with_wings",
  "dollar",
  "yen",
  "euro",
  "pound",
  "moneybag",
  "credit_card",
  "gem",
  "balance_scale",
  "toolbox",
  "wrench",
  "hammer",
  "hammer_and_pick",
  "hammer_and_wrench",
  "pick",
  "nut_and_bolt",
  "gear",
  "brick",
  "chains",
  "magnet",
  "gun",
  "bomb",
  "firecracker",
  "hocho",
  "dagger",
  "crossed_swords",
  "shield",
  "smoking",
  "coffin",
  "funeral_urn",
  "amphora",
  "crystal_ball",
  "prayer_beads",
  "nazar_amulet",
  "barber",
  "alembic",
  "telescope",
  "microscope",
  "hole",
  "pill",
  "syringe",
  "dna",
  "microbe",
  "petri_dish",
  "test_tube",
  "thermometer",
  "broom",
  "basket",
  "toilet_paper",
  "label",
  "bookmark",
  "toilet",
  "shower",
  "bathtub",
  "bath",
  "soap",
  "sponge",
  "lotion_bottle",
  "key",
  "old_key",
  "couch_and_lamp",
  "sleeping_bed",
  "bed",
  "door",
  "bellhop_bell",
  "teddy_bear",
  "framed_picture",
  "world_map",
  "parasol_on_ground",
  "moyai",
  "shopping",
  "shopping_cart",
  "balloon",
  "flags",
  "ribbon",
  "gift",
  "confetti_ball",
  "tada",
  "dolls",
  "wind_chime",
  "crossed_flags",
  "izakaya_lantern",
  "red_envelope",
  "email",
  "envelope_with_arrow",
  "incoming_envelope",
  "e-mail",
  "love_letter",
  "postbox",
  "mailbox_closed",
  "mailbox",
  "mailbox_with_mail",
  "mailbox_with_no_mail",
  "package",
  "postal_horn",
  "inbox_tray",
  "outbox_tray",
  "scroll",
  "page_with_curl",
  "bookmark_tabs",
  "receipt",
  "bar_chart",
  "chart_with_upwards_trend",
  "chart_with_downwards_trend",
  "page_facing_up",
  "date",
  "calendar",
  "spiral_calendar",
  "card_index",
  "card_file_box",
  "ballot_box",
  "file_cabinet",
  "clipboard",
  "spiral_notepad",
  "file_folder",
  "open_file_folder",
  "card_index_dividers",
  "newspaper_roll",
  "newspaper",
  "notebook",
  "closed_book",
  "green_book",
  "blue_book",
  "orange_book",
  "notebook_with_decorative_cover",
  "ledger",
  "books",
  "open_book",
  "safety_pin",
  "link",
  "paperclip",
  "paperclips",
  "scissors",
  "triangular_ruler",
  "straight_ruler",
  "abacus",
  "pushpin",
  "round_pushpin",
  "closed_lock_with_key",
  "lock",
  "unlock",
  "lock_with_ink_pen",
  "pen",
  "fountain_pen",
  "black_nib",
  "memo",
  "pencil2",
  "crayon",
  "paintbrush",
  "mag",
  "mag_right",
  "heart",
  "orange_heart",
  "yellow_heart",
  "green_heart",
  "blue_heart",
  "purple_heart",
  "black_heart",
  "broken_heart",
  "heavy_heart_exclamation",
  "two_hearts",
  "revolving_hearts",
  "heartbeat",
  "heartpulse",
  "sparkling_heart",
  "cupid",
  "gift_heart",
  "heart_decoration",
  "peace_symbol",
  "latin_cross",
  "star_and_crescent",
  "om",
  "wheel_of_dharma",
  "star_of_david",
  "six_pointed_star",
  "menorah",
  "yin_yang",
  "orthodox_cross",
  "place_of_worship",
  "ophiuchus",
  "aries",
  "taurus",
  "gemini",
  "cancer",
  "leo",
  "virgo",
  "libra",
  "scorpius",
  "sagittarius",
  "capricorn",
  "aquarius",
  "pisces",
  "id",
  "atom_symbol",
  "u7a7a",
  "u5272",
  "radioactive",
  "biohazard",
  "mobile_phone_off",
  "vibration_mode",
  "u6709",
  "u7121",
  "u7533",
  "u55b6",
  "u6708",
  "eight_pointed_black_star",
  "vs",
  "accept",
  "white_flower",
  "ideograph_advantage",
  "secret",
  "congratulations",
  "u5408",
  "u6e80",
  "u7981",
  "a",
  "b",
  "ab",
  "cl",
  "o2",
  "sos",
  "no_entry",
  "name_badge",
  "no_entry_sign",
  "x",
  "o",
  "stop_sign",
  "anger",
  "hotsprings",
  "no_pedestrians",
  "do_not_litter",
  "no_bicycles",
  "non-potable_water",
  "underage",
  "no_mobile_phones",
  "exclamation",
  "grey_exclamation",
  "question",
  "grey_question",
  "bangbang",
  "interrobang",
  "100",
  "low_brightness",
  "high_brightness",
  "trident",
  "fleur_de_lis",
  "part_alternation_mark",
  "warning",
  "children_crossing",
  "beginner",
  "recycle",
  "u6307",
  "chart",
  "sparkle",
  "eight_spoked_asterisk",
  "negative_squared_cross_mark",
  "white_check_mark",
  "diamond_shape_with_a_dot_inside",
  "cyclone",
  "loop",
  "globe_with_meridians",
  "m",
  "atm",
  "zzz",
  "sa",
  "passport_control",
  "customs",
  "baggage_claim",
  "left_luggage",
  "wheelchair",
  "no_smoking",
  "wc",
  "parking",
  "potable_water",
  "mens",
  "womens",
  "baby_symbol",
  "restroom",
  "put_litter_in_its_place",
  "cinema",
  "signal_strength",
  "koko",
  "ng",
  "ok",
  "up",
  "cool",
  "new",
  "free",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "keycap_ten",
  "asterisk",
  "1234",
  "eject_button",
  "arrow_forward",
  "pause_button",
  "next_track_button",
  "stop_button",
  "record_button",
  "play_or_pause_button",
  "previous_track_button",
  "fast_forward",
  "rewind",
  "twisted_rightwards_arrows",
  "repeat",
  "repeat_one",
  "arrow_backward",
  "arrow_up_small",
  "arrow_down_small",
  "arrow_double_up",
  "arrow_double_down",
  "arrow_right",
  "arrow_left",
  "arrow_up",
  "arrow_down",
  "arrow_upper_right",
  "arrow_lower_right",
  "arrow_lower_left",
  "arrow_upper_left",
  "arrow_up_down",
  "left_right_arrow",
  "arrows_counterclockwise",
  "arrow_right_hook",
  "leftwards_arrow_with_hook",
  "arrow_heading_up",
  "arrow_heading_down",
  "hash",
  "information_source",
  "abc",
  "abcd",
  "capital_abcd",
  "symbols",
  "musical_note",
  "notes",
  "wavy_dash",
  "curly_loop",
  "heavy_check_mark",
  "arrows_clockwise",
  "heavy_plus_sign",
  "heavy_minus_sign",
  "heavy_division_sign",
  "heavy_multiplication_x",
  "infinity",
  "heavy_dollar_sign",
  "currency_exchange",
  "copyright",
  "registered",
  "tm",
  "end",
  "back",
  "on",
  "top",
  "soon",
  "ballot_box_with_check",
  "radio_button",
  "white_circle",
  "black_circle",
  "red_circle",
  "large_blue_circle",
  "small_orange_diamond",
  "small_blue_diamond",
  "large_orange_diamond",
  "large_blue_diamond",
  "small_red_triangle",
  "black_small_square",
  "white_small_square",
  "black_large_square",
  "white_large_square",
  "small_red_triangle_down",
  "black_medium_square",
  "white_medium_square",
  "black_medium_small_square",
  "white_medium_small_square",
  "black_square_button",
  "white_square_button",
  "speaker",
  "sound",
  "loud_sound",
  "mute",
  "mega",
  "loudspeaker",
  "bell",
  "no_bell",
  "black_joker",
  "mahjong",
  "spades",
  "clubs",
  "hearts",
  "diamonds",
  "flower_playing_cards",
  "thought_balloon",
  "right_anger_bubble",
  "speech_balloon",
  "left_speech_bubble",
  "clock1",
  "clock2",
  "clock3",
  "clock4",
  "clock5",
  "clock6",
  "clock7",
  "clock8",
  "clock9",
  "clock10",
  "clock11",
  "clock12",
  "clock130",
  "clock230",
  "clock330",
  "clock430",
  "clock530",
  "clock630",
  "clock730",
  "clock830",
  "clock930",
  "clock1030",
  "clock1130",
  "clock1230",
  "white_flag",
  "black_flag",
  "pirate_flag",
  "checkered_flag",
  "triangular_flag_on_post",
  "rainbow_flag",
  "united_nations",
  "afghanistan",
  "aland_islands",
  "albania",
  "algeria",
  "american_samoa",
  "andorra",
  "angola",
  "anguilla",
  "antarctica",
  "antigua_barbuda",
  "argentina",
  "armenia",
  "aruba",
  "australia",
  "austria",
  "azerbaijan",
  "bahamas",
  "bahrain",
  "bangladesh",
  "barbados",
  "belarus",
  "belgium",
  "belize",
  "benin",
  "bermuda",
  "bhutan",
  "bolivia",
  "caribbean_netherlands",
  "bosnia_herzegovina",
  "botswana",
  "brazil",
  "british_indian_ocean_territory",
  "british_virgin_islands",
  "brunei",
  "bulgaria",
  "burkina_faso",
  "burundi",
  "cape_verde",
  "cambodia",
  "cameroon",
  "canada",
  "canary_islands",
  "cayman_islands",
  "central_african_republic",
  "chad",
  "chile",
  "cn",
  "christmas_island",
  "cocos_islands",
  "colombia",
  "comoros",
  "congo_brazzaville",
  "congo_kinshasa",
  "cook_islands",
  "costa_rica",
  "croatia",
  "cuba",
  "curacao",
  "cyprus",
  "czech_republic",
  "denmark",
  "djibouti",
  "dominica",
  "dominican_republic",
  "ecuador",
  "egypt",
  "el_salvador",
  "equatorial_guinea",
  "eritrea",
  "estonia",
  "ethiopia",
  "eu",
  "falkland_islands",
  "faroe_islands",
  "fiji",
  "finland",
  "fr",
  "french_guiana",
  "french_polynesia",
  "french_southern_territories",
  "gabon",
  "gambia",
  "georgia",
  "de",
  "ghana",
  "gibraltar",
  "greece",
  "greenland",
  "grenada",
  "guadeloupe",
  "guam",
  "guatemala",
  "guernsey",
  "guinea",
  "guinea_bissau",
  "guyana",
  "haiti",
  "honduras",
  "hong_kong",
  "hungary",
  "iceland",
  "india",
  "indonesia",
  "iran",
  "iraq",
  "ireland",
  "isle_of_man",
  "israel",
  "it",
  "cote_divoire",
  "jamaica",
  "jp",
  "jersey",
  "jordan",
  "kazakhstan",
  "kenya",
  "kiribati",
  "kosovo",
  "kuwait",
  "kyrgyzstan",
  "laos",
  "latvia",
  "lebanon",
  "lesotho",
  "liberia",
  "libya",
  "liechtenstein",
  "lithuania",
  "luxembourg",
  "macau",
  "macedonia",
  "madagascar",
  "malawi",
  "malaysia",
  "maldives",
  "mali",
  "malta",
  "marshall_islands",
  "martinique",
  "mauritania",
  "mauritius",
  "mayotte",
  "mexico",
  "micronesia",
  "moldova",
  "monaco",
  "mongolia",
  "montenegro",
  "montserrat",
  "morocco",
  "mozambique",
  "myanmar",
  "namibia",
  "nauru",
  "nepal",
  "netherlands",
  "new_caledonia",
  "new_zealand",
  "nicaragua",
  "niger",
  "nigeria",
  "niue",
  "norfolk_island",
  "northern_mariana_islands",
  "north_korea",
  "norway",
  "oman",
  "pakistan",
  "palau",
  "palestinian_territories",
  "panama",
  "papua_new_guinea",
  "paraguay",
  "peru",
  "philippines",
  "pitcairn_islands",
  "poland",
  "portugal",
  "puerto_rico",
  "qatar",
  "reunion",
  "romania",
  "ru",
  "rwanda",
  "st_barthelemy",
  "st_helena",
  "st_kitts_nevis",
  "st_lucia",
  "st_pierre_miquelon",
  "st_vincent_grenadines",
  "samoa",
  "san_marino",
  "sao_tome_principe",
  "saudi_arabia",
  "senegal",
  "serbia",
  "seychelles",
  "sierra_leone",
  "singapore",
  "sint_maarten",
  "slovakia",
  "slovenia",
  "solomon_islands",
  "somalia",
  "south_africa",
  "south_georgia_south_sandwich_islands",
  "kr",
  "south_sudan",
  "es",
  "sri_lanka",
  "sudan",
  "suriname",
  "swaziland",
  "sweden",
  "switzerland",
  "syria",
  "taiwan",
  "tajikistan",
  "tanzania",
  "thailand",
  "timor_leste",
  "togo",
  "tokelau",
  "tonga",
  "trinidad_tobago",
  "tunisia",
  "tr",
  "turkmenistan",
  "turks_caicos_islands",
  "tuvalu",
  "uganda",
  "ukraine",
  "united_arab_emirates",
  "uk",
  "england",
  "scotland",
  "wales",
  "us",
  "us_virgin_islands",
  "uruguay",
  "uzbekistan",
  "vanuatu",
  "vatican_city",
  "venezuela",
  "vietnam",
  "wallis_futuna",
  "western_sahara",
  "yemen",
  "zambia",
  "zimbabwe"
];
var rH = {
  lib: tH,
  ordered: aH,
  fitzpatrick_scale_modifiers: ["", "", "", "", ""]
};
const nH = /* @__PURE__ */ bi(rH);
var sH = () => {
  const e = "\\ud800-\\udfff", i = "\\u0300-\\u036f" + "\\ufe20-\\ufe2f" + "\\u20d0-\\u20ff" + "\\u1ab0-\\u1aff" + "\\u1dc0-\\u1dff", o = "\\ufe0e\\ufe0f", c = "\\uD83D\\uDC69\\uD83C\\uDFFB\\u200D\\uD83C\\uDF93", u = `[${e}]`, d = `[${i}]`, m = "\\ud83c[\\udffb-\\udfff]", h = `(?:${d}|${m})`, y = `[^${e}]`, w = "(?:\\uD83C[\\uDDE6-\\uDDFF]){2}", v = "[\\ud800-\\udbff][\\udc00-\\udfff]", F = "\\u200d", z = "(?:\\ud83c\\udff4\\udb40\\udc67\\udb40\\udc62\\udb40(?:\\udc65|\\udc73|\\udc77)\\udb40(?:\\udc6e|\\udc63|\\udc6c)\\udb40(?:\\udc67|\\udc74|\\udc73)\\udb40\\udc7f)", C = `[${c}]`, U = `${h}?`, $ = `[${o}]?`, O = `(?:${F}(?:${[y, w, v].join("|")})${$ + U})*`, p = $ + U + O, te = `(?:${[`${y}${d}?`, d, w, v, u, C].join("|")})`;
  return new RegExp(`${z}|${m}(?=${m})|${te + p}`, "g");
};
const iH = /* @__PURE__ */ bi(sH);
iH();
var oH = "", cH = new RegExp(oH, "g");
function lH(e) {
  return e.replace(cH, "");
}
function uH(e) {
  return /:.+:/.test(e) ? e.slice(1, -1) : e;
}
var x0 = Object.entries(nH.lib).map(
  ([e, { char: t }]) => [e, t]
), fH = new Map(x0);
new Map(
  x0.map(([e, t]) => [lH(t), e])
);
var hH = (e) => (l2.assert.string(e), fH.get(uH(e)));
const Gc = [
  {
    description: "angry face",
    emoji: "",
    emoticons: [">:(", ">:[", ">:-(", ">:-[", ">=(", ">=[", ">=-(", ">=-["],
    name: "angry",
    tags: ["mad", "annoyed"]
  },
  {
    description: "smiling face with smiling eyes",
    emoji: "",
    emoticons: [
      ':")',
      ':"]',
      ':"D',
      ':-")',
      ':-"]',
      ':-"D',
      '=")',
      '="]',
      '="D',
      '=-")',
      '=-"]',
      '=-"D'
    ],
    name: "blush",
    tags: ["proud"]
  },
  {
    description: "broken heart",
    emoji: "",
    emoticons: ["<\\3", "</3"],
    name: "broken_heart",
    tags: []
  },
  {
    description: "confused face",
    emoji: "",
    emoticons: [":/", ":\\", ":-/", ":-\\", "=/", "=\\", "=-/", "=-\\"],
    name: "confused",
    tags: []
  },
  {
    description: "crying face",
    emoji: "",
    emoticons: [
      ":,(",
      ":,[",
      ":,|",
      ":,-(",
      ":,-[",
      ":,-|",
      ":'(",
      ":'[",
      ":'|",
      ":'-(",
      ":'-[",
      ":'-|",
      "=,(",
      "=,[",
      "=,|",
      "=,-(",
      "=,-[",
      "=,-|",
      "='(",
      "='[",
      "='|",
      "='-(",
      "='-[",
      "='-|",
      "T-T"
    ],
    name: "cry",
    tags: ["sad", "tear"]
  },
  {
    description: "frowning face with open mouth",
    emoji: "",
    emoticons: [":(", ":[", ":-(", ":-[", "=(", "=[", "=-(", "=-["],
    name: "frowning",
    tags: []
  },
  {
    description: "red heart",
    emoji: "",
    emoticons: ["<3"],
    name: "heart",
    tags: ["love"]
  },
  {
    description: "angry face with horns",
    emoji: "",
    emoticons: ["]:(", "]:[", "]:-(", "]:-[", "]=(", "]=[", "]=-(", "]=-["],
    name: "imp",
    tags: ["angry", "devil", "evil", "horns"]
  },
  {
    description: "smiling face with halo",
    emoji: "",
    emoticons: [
      "o:)",
      "o:]",
      "o:D",
      "o:-)",
      "o:-]",
      "o:-D",
      "o=)",
      "o=]",
      "o=D",
      "o=-)",
      "o=-]",
      "o=-D",
      "O:)",
      "O:]",
      "O:D",
      "O:-)",
      "O:-]",
      "O:-D",
      "O=)",
      "O=]",
      "O=D",
      "O=-)",
      "O=-]",
      "O=-D",
      "0:)",
      "0:]",
      "0:D",
      "0:-)",
      "0:-]",
      "0:-D",
      "0=)",
      "0=]",
      "0=D",
      "0=-)",
      "0=-]",
      "0=-D"
    ],
    name: "innocent",
    tags: ["angel"]
  },
  {
    description: "face with tears of joy",
    emoji: "",
    emoticons: [
      ":,)",
      ":,]",
      ":,D",
      ":,-)",
      ":,-]",
      ":,-D",
      ":')",
      ":']",
      ":'D",
      ":'-)",
      ":'-]",
      ":'-D",
      "=,)",
      "=,]",
      "=,D",
      "=,-)",
      "=,-]",
      "=,-D",
      "=')",
      "=']",
      "='D",
      "='-)",
      "='-]",
      "='-D"
    ],
    name: "joy",
    tags: ["tears"]
  },
  {
    description: "kissing face",
    emoji: "",
    emoticons: [":*", ":-*", "=*", "=-*"],
    name: "kissing",
    tags: []
  },
  {
    description: "grinning squinting face",
    emoji: "",
    emoticons: [
      "x)",
      "x]",
      "xD",
      "x-)",
      "x-]",
      "x-D",
      "X)",
      "X]",
      "X-)",
      "X-]",
      "X-D"
    ],
    name: "laughing",
    tags: ["happy", "haha"]
  },
  {
    description: "man",
    emoji: "",
    emoticons: [
      ":3",
      ":-3",
      "=3",
      "=-3",
      ";3",
      ";-3",
      "x3",
      "x-3",
      "X3",
      "X-3"
    ],
    name: "man",
    tags: ["mustache", "father", "dad"]
  },
  {
    description: "neutral face",
    emoji: "",
    emoticons: [":|", ":-|", "=|", "=-|"],
    name: "neutral_face",
    tags: ["meh"]
  },
  {
    description: "face without mouth",
    emoji: "",
    emoticons: [":-"],
    name: "no_mouth",
    tags: ["mute", "silence"]
  },
  {
    description: "face with open mouth",
    emoji: "",
    emoticons: [
      ":o",
      ":O",
      ":0",
      ":-o",
      ":-O",
      ":-0",
      "=o",
      "=O",
      "=0",
      "=-o",
      "=-O",
      "=-0"
    ],
    name: "open_mouth",
    tags: ["surprise", "impressed", "wow"]
  },
  {
    description: "enraged face",
    emoji: "",
    emoticons: [":@", ":-@", "=@", "=-@"],
    name: "rage",
    tags: ["angry"]
  },
  {
    description: "grinning face with smiling eyes",
    emoji: "",
    emoticons: [":D", ":-D", "=D", "=-D"],
    name: "smile",
    tags: ["happy", "joy", "laugh", "pleased"]
  },
  {
    description: "grinning face with big eyes",
    emoji: "",
    emoticons: [":)", ":]", ":-)", ":-]", "=)", "=]", "=-)", "=-]"],
    name: "smiley",
    tags: ["happy", "joy", "haha"]
  },
  {
    description: "smiling face with horns",
    emoji: "",
    emoticons: [
      "]:)",
      "]:]",
      "]:D",
      "]:-)",
      "]:-]",
      "]:-D",
      "]=)",
      "]=]",
      "]=D",
      "]=-)",
      "]=-]",
      "]=-D"
    ],
    name: "smiling_imp",
    tags: ["devil", "evil", "horns"]
  },
  {
    description: "loudly crying face",
    emoji: "",
    emoticons: [
      ":,'(",
      ":,'[",
      ":,'-(",
      ":,'-[",
      ":',(",
      ":',[",
      ":',-(",
      ":',-[",
      "=,'(",
      "=,'[",
      "=,'-(",
      "=,'-[",
      "=',(",
      "=',[",
      "=',-(",
      "=',-["
    ],
    name: "sob",
    tags: ["sad", "cry", "bawling"]
  },
  {
    description: "face with tongue",
    emoji: "",
    emoticons: [
      ":p",
      ":P",
      ":d",
      ":-p",
      ":-P",
      ":-d",
      "=p",
      "=P",
      "=d",
      "=-p",
      "=-P",
      "=-d"
    ],
    name: "stuck_out_tongue",
    tags: []
  },
  {
    description: "squinting face with tongue",
    emoji: "",
    emoticons: ["xP", "x-p", "x-P", "x-d", "Xp", "Xd", "X-p", "X-P", "X-d"],
    name: "stuck_out_tongue_closed_eyes",
    tags: ["prank"]
  },
  {
    description: "winking face with tongue",
    emoji: "",
    emoticons: [";p", ";P", ";d", ";-p", ";-P", ";-d"],
    name: "stuck_out_tongue_winking_eye",
    tags: ["prank", "silly"]
  },
  {
    description: "smiling face with sunglasses",
    emoji: "",
    emoticons: [
      "8)",
      "8]",
      "8D",
      "8-)",
      "8-]",
      "8-D",
      "B)",
      "B]",
      "B-)",
      "B-]",
      "B-D"
    ],
    name: "sunglasses",
    tags: ["cool"]
  },
  {
    description: "downcast face with sweat",
    emoji: "",
    emoticons: [
      ",:(",
      ",:[",
      ",:-(",
      ",:-[",
      ",=(",
      ",=[",
      ",=-(",
      ",=-[",
      "':(",
      "':[",
      "':-(",
      "':-[",
      "'=(",
      "'=[",
      "'=-(",
      "'=-["
    ],
    name: "sweat",
    tags: []
  },
  {
    description: "grinning face with sweat",
    emoji: "",
    emoticons: [
      ",:)",
      ",:]",
      ",:D",
      ",:-)",
      ",:-]",
      ",:-D",
      ",=)",
      ",=]",
      ",=D",
      ",=-)",
      ",=-]",
      ",=-D",
      "':)",
      "':]",
      "':D",
      "':-)",
      "':-]",
      "':-D",
      "'=)",
      "'=]",
      "'=D",
      "'=-)",
      "'=-]",
      "'=-D"
    ],
    name: "sweat_smile",
    tags: ["hot"]
  },
  {
    description: "unamused face",
    emoji: "",
    emoticons: [
      ":$",
      ":s",
      ":z",
      ":S",
      ":Z",
      ":-$",
      ":-s",
      ":-z",
      ":-S",
      ":-Z",
      "=$",
      "=s",
      "=z",
      "=S",
      "=Z",
      "=-$",
      "=-s",
      "=-z",
      "=-S",
      "=-Z"
    ],
    name: "unamused",
    tags: ["meh"]
  },
  {
    description: "winking face",
    emoji: "",
    emoticons: [";)", ";]", ";D", ";-)", ";-]", ";-D"],
    name: "wink",
    tags: ["flirt"]
  }
], dH = /:\+1:|:-1:|:[\w-]+:/g, mH = /[$@|*'",;.=:\-)([\]\\/<>038BOopPsSdDxXzZ]{2,5}/g, pH = /(?:_|-(?!1))/g, gH = {
  padSpaceAfter: !1,
  emoticon: !1,
  accessible: !1
}, yH = (e) => {
  const t = Object.assign({}, gH, e), a = !!t.padSpaceAfter, r = !!t.emoticon, n = !!t.accessible;
  function s(d, m) {
    return {
      type: "text",
      value: d,
      data: {
        hName: "span",
        hProperties: {
          role: "img",
          ariaLabel: m
        },
        hChildren: [{ type: "text", value: d }]
      }
    };
  }
  function i(d) {
    const m = Gc.find((z) => z.emoticons.includes(d)), h = Gc.find((z) => z.emoticons.includes(d.slice(0, -1))), y = m || h;
    if (!y)
      return !1;
    const w = !m && h ? d.slice(-1) : "", v = a ? " " : "", F = y.emoji + v + w;
    return n ? s(F, y.name + " emoticon") : F;
  }
  function o(d) {
    let m = hH(d);
    if (typeof m > "u")
      return !1;
    if (a && (m = m + " "), n) {
      const h = d.slice(1, -1).replace(pH, " ") + " emoji";
      return s(m, h);
    }
    return m;
  }
  const c = [[dH, o]];
  r && c.push([mH, i]);
  function u(d) {
    ru(d, c);
  }
  return u;
}, _H = /[\0-\x1F!-,\.\/:-@\[-\^`\{-\xA9\xAB-\xB4\xB6-\xB9\xBB-\xBF\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0378\u0379\u037E\u0380-\u0385\u0387\u038B\u038D\u03A2\u03F6\u0482\u0530\u0557\u0558\u055A-\u055F\u0589-\u0590\u05BE\u05C0\u05C3\u05C6\u05C8-\u05CF\u05EB-\u05EE\u05F3-\u060F\u061B-\u061F\u066A-\u066D\u06D4\u06DD\u06DE\u06E9\u06FD\u06FE\u0700-\u070F\u074B\u074C\u07B2-\u07BF\u07F6-\u07F9\u07FB\u07FC\u07FE\u07FF\u082E-\u083F\u085C-\u085F\u086B-\u089F\u08B5\u08C8-\u08D2\u08E2\u0964\u0965\u0970\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09F2-\u09FB\u09FD\u09FF\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF0-\u0AF8\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B54\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B70\u0B72-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BF0-\u0BFF\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B-\u0C5F\u0C64\u0C65\u0C70-\u0C7F\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0CFF\u0D0D\u0D11\u0D45\u0D49\u0D4F-\u0D53\u0D58-\u0D5E\u0D64\u0D65\u0D70-\u0D79\u0D80\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF4-\u0E00\u0E3B-\u0E3F\u0E4F\u0E5A-\u0E80\u0E83\u0E85\u0E8B\u0EA4\u0EA6\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F01-\u0F17\u0F1A-\u0F1F\u0F2A-\u0F34\u0F36\u0F38\u0F3A-\u0F3D\u0F48\u0F6D-\u0F70\u0F85\u0F98\u0FBD-\u0FC5\u0FC7-\u0FFF\u104A-\u104F\u109E\u109F\u10C6\u10C8-\u10CC\u10CE\u10CF\u10FB\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u1360-\u137F\u1390-\u139F\u13F6\u13F7\u13FE-\u1400\u166D\u166E\u1680\u169B-\u169F\u16EB-\u16ED\u16F9-\u16FF\u170D\u1715-\u171F\u1735-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17D4-\u17D6\u17D8-\u17DB\u17DE\u17DF\u17EA-\u180A\u180E\u180F\u181A-\u181F\u1879-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u1945\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DA-\u19FF\u1A1C-\u1A1F\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1AA6\u1AA8-\u1AAF\u1AC1-\u1AFF\u1B4C-\u1B4F\u1B5A-\u1B6A\u1B74-\u1B7F\u1BF4-\u1BFF\u1C38-\u1C3F\u1C4A-\u1C4C\u1C7E\u1C7F\u1C89-\u1C8F\u1CBB\u1CBC\u1CC0-\u1CCF\u1CD3\u1CFB-\u1CFF\u1DFA\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FBD\u1FBF-\u1FC1\u1FC5\u1FCD-\u1FCF\u1FD4\u1FD5\u1FDC-\u1FDF\u1FED-\u1FF1\u1FF5\u1FFD-\u203E\u2041-\u2053\u2055-\u2070\u2072-\u207E\u2080-\u208F\u209D-\u20CF\u20F1-\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F-\u215F\u2189-\u24B5\u24EA-\u2BFF\u2C2F\u2C5F\u2CE5-\u2CEA\u2CF4-\u2CFF\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D70-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E00-\u2E2E\u2E30-\u3004\u3008-\u3020\u3030\u3036\u3037\u303D-\u3040\u3097\u3098\u309B\u309C\u30A0\u30FB\u3100-\u3104\u3130\u318F-\u319F\u31C0-\u31EF\u3200-\u33FF\u4DC0-\u4DFF\u9FFD-\u9FFF\uA48D-\uA4CF\uA4FE\uA4FF\uA60D-\uA60F\uA62C-\uA63F\uA673\uA67E\uA6F2-\uA716\uA720\uA721\uA789\uA78A\uA7C0\uA7C1\uA7CB-\uA7F4\uA828-\uA82B\uA82D-\uA83F\uA874-\uA87F\uA8C6-\uA8CF\uA8DA-\uA8DF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA954-\uA95F\uA97D-\uA97F\uA9C1-\uA9CE\uA9DA-\uA9DF\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A-\uAA5F\uAA77-\uAA79\uAAC3-\uAADA\uAADE\uAADF\uAAF0\uAAF1\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB5B\uAB6A-\uAB6F\uABEB\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uD7FF\uE000-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB29\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBB2-\uFBD2\uFD3E-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFC-\uFDFF\uFE10-\uFE1F\uFE30-\uFE32\uFE35-\uFE4C\uFE50-\uFE6F\uFE75\uFEFD-\uFF0F\uFF1A-\uFF20\uFF3B-\uFF3E\uFF40\uFF5B-\uFF65\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFFF]|\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDD3F\uDD75-\uDDFC\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEE1-\uDEFF\uDF20-\uDF2C\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDF9F\uDFC4-\uDFC7\uDFD0\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56-\uDC5F\uDC77-\uDC7F\uDC9F-\uDCDF\uDCF3\uDCF6-\uDCFF\uDD16-\uDD1F\uDD3A-\uDD7F\uDDB8-\uDDBD\uDDC0-\uDDFF\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE36\uDE37\uDE3B-\uDE3E\uDE40-\uDE5F\uDE7D-\uDE7F\uDE9D-\uDEBF\uDEC8\uDEE7-\uDEFF\uDF36-\uDF3F\uDF56-\uDF5F\uDF73-\uDF7F\uDF92-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCFF\uDD28-\uDD2F\uDD3A-\uDE7F\uDEAA\uDEAD-\uDEAF\uDEB2-\uDEFF\uDF1D-\uDF26\uDF28-\uDF2F\uDF51-\uDFAF\uDFC5-\uDFDF\uDFF7-\uDFFF]|\uD804[\uDC47-\uDC65\uDC70-\uDC7E\uDCBB-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD40-\uDD43\uDD48-\uDD4F\uDD74\uDD75\uDD77-\uDD7F\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDFF\uDE12\uDE38-\uDE3D\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEA9-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC4B-\uDC4F\uDC5A-\uDC5D\uDC62-\uDC7F\uDCC6\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDC1-\uDDD7\uDDDE-\uDDFF\uDE41-\uDE43\uDE45-\uDE4F\uDE5A-\uDE7F\uDEB9-\uDEBF\uDECA-\uDEFF\uDF1B\uDF1C\uDF2C-\uDF2F\uDF3A-\uDFFF]|\uD806[\uDC3B-\uDC9F\uDCEA-\uDCFE\uDD07\uDD08\uDD0A\uDD0B\uDD14\uDD17\uDD36\uDD39\uDD3A\uDD44-\uDD4F\uDD5A-\uDD9F\uDDA8\uDDA9\uDDD8\uDDD9\uDDE2\uDDE5-\uDDFF\uDE3F-\uDE46\uDE48-\uDE4F\uDE9A-\uDE9C\uDE9E-\uDEBF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC41-\uDC4F\uDC5A-\uDC71\uDC90\uDC91\uDCA8\uDCB7-\uDCFF\uDD07\uDD0A\uDD37-\uDD39\uDD3B\uDD3E\uDD48-\uDD4F\uDD5A-\uDD5F\uDD66\uDD69\uDD8F\uDD92\uDD99-\uDD9F\uDDAA-\uDEDF\uDEF7-\uDFAF\uDFB1-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD824-\uD82B\uD82D\uD82E\uD830-\uD833\uD837\uD839\uD83D\uD83F\uD87B-\uD87D\uD87F\uD885-\uDB3F\uDB41-\uDBFF][\uDC00-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDECF\uDEEE\uDEEF\uDEF5-\uDEFF\uDF37-\uDF3F\uDF44-\uDF4F\uDF5A-\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDE3F\uDE80-\uDEFF\uDF4B-\uDF4E\uDF88-\uDF8E\uDFA0-\uDFDF\uDFE2\uDFE5-\uDFEF\uDFF2-\uDFFF]|\uD821[\uDFF8-\uDFFF]|\uD823[\uDCD6-\uDCFF\uDD09-\uDFFF]|\uD82C[\uDD1F-\uDD4F\uDD53-\uDD63\uDD68-\uDD6F\uDEFC-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A-\uDC9C\uDC9F-\uDFFF]|\uD834[\uDC00-\uDD64\uDD6A-\uDD6C\uDD73-\uDD7A\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDE41\uDE45-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3\uDFCC\uDFCD]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDCFF\uDD2D-\uDD2F\uDD3E\uDD3F\uDD4A-\uDD4D\uDD4F-\uDEBF\uDEFA-\uDFFF]|\uD83A[\uDCC5-\uDCCF\uDCD7-\uDCFF\uDD4C-\uDD4F\uDD5A-\uDFFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDFFF]|\uD83C[\uDC00-\uDD2F\uDD4A-\uDD4F\uDD6A-\uDD6F\uDD8A-\uDFFF]|\uD83E[\uDC00-\uDFEF\uDFFA-\uDFFF]|\uD869[\uDEDE-\uDEFF]|\uD86D[\uDF35-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDEAF]|\uD87A[\uDFE1-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uD884[\uDF4B-\uDFFF]|\uDB40[\uDC00-\uDCFF\uDDF0-\uDFFF]/g, bH = Object.hasOwnProperty;
class A0 {
  /**
   * Create a new slug class.
   */
  constructor() {
    this.occurrences, this.reset();
  }
  /**
   * Generate a unique slug.
  *
  * Tracks previously generated slugs: repeated calls with the same value
  * will result in different slugs.
  * Use the `slug` function to get same slugs.
   *
   * @param  {string} value
   *   String of text to slugify
   * @param  {boolean} [maintainCase=false]
   *   Keep the current case, otherwise make all lowercase
   * @return {string}
   *   A unique slug string
   */
  slug(t, a) {
    const r = this;
    let n = kH(t, a === !0);
    const s = n;
    for (; bH.call(r.occurrences, n); )
      r.occurrences[s]++, n = s + "-" + r.occurrences[s];
    return r.occurrences[n] = 0, n;
  }
  /**
   * Reset - Forget all previous slugs
   *
   * @return void
   */
  reset() {
    this.occurrences = /* @__PURE__ */ Object.create(null);
  }
}
function kH(e, t) {
  return typeof e != "string" ? "" : (t || (e = e.toLowerCase()), e.replace(_H, "").replace(/ /g, "-"));
}
function D0(e) {
  return new RegExp("^(" + e + ")$", "i");
}
const Wc = new A0();
function wH(e, t, a) {
  const r = "children" in e ? e.children.length : 0, n = a.skip ? D0(a.skip) : void 0, s = cr(
    a.parents || function(d) {
      return d === e;
    }
  ), i = [];
  let o, c, u;
  return Wc.reset(), lr(e, "heading", function(d, m, h) {
    const y = jn(d, { includeImageAlt: !1 }), w = d.data && d.data.hProperties && d.data.hProperties.id, v = Wc.slug(w || y);
    if (s(h)) {
      if (m !== void 0 && t && !o && t.test(y)) {
        o = m + 1, u = d;
        return;
      }
      m !== void 0 && u && !c && d.depth <= u.depth && (c = m), (c || !t) && (!a.minDepth || d.depth >= a.minDepth) && (!a.maxDepth || d.depth <= a.maxDepth) && (!n || !n.test(y)) && i.push({ depth: d.depth, children: d.children, id: v });
    }
  }), {
    index: o === void 0 ? -1 : o,
    endIndex: o === void 0 ? -1 : c || r,
    map: i
  };
}
function EH(e, t) {
  const { ordered: a = !1, tight: r = !1, prefix: n } = t, s = { type: "list", ordered: a, spread: !1, children: [] };
  let i = Number.POSITIVE_INFINITY, o = -1;
  for (; ++o < e.length; )
    e[o].depth < i && (i = e[o].depth);
  for (o = -1; ++o < e.length; )
    e[o].depth -= i - 1;
  for (o = -1; ++o < e.length; )
    Rr(e[o], s, { ordered: a, tight: r, prefix: n });
  return s;
}
function Rr(e, t, a) {
  let r = -1;
  const n = t.children[t.children.length - 1];
  if (t.type === "list")
    if (e.depth === 1)
      t.children.push({
        type: "listItem",
        spread: !1,
        children: [
          {
            type: "paragraph",
            children: [
              {
                type: "link",
                title: null,
                url: "#" + (a.prefix || "") + e.id,
                children: fi(e.children)
              }
            ]
          }
        ]
      });
    else if (t.children.length > 0) {
      const s = t.children[t.children.length - 1];
      Rr(e, s, a);
    } else {
      const s = { type: "listItem", spread: !1, children: [] };
      t.children.push(s), Rr(e, s, a);
    }
  else if (n && n.type === "list")
    e.depth--, Rr(e, n, a);
  else {
    const s = {
      type: "list",
      ordered: a.ordered,
      spread: !1,
      children: []
    };
    t.children.push(s), e.depth--, Rr(e, s, a);
  }
  if (t.type === "list" && !a.tight) {
    for (t.spread = !1; ++r < t.children.length; )
      if (t.children[r].children.length > 1) {
        t.spread = !0;
        break;
      }
  } else
    t.spread = !a.tight;
}
function fi(e) {
  const t = [];
  let a = -1;
  for (; ++a < e.length; ) {
    const r = TH(e[a]);
    Array.isArray(r) ? t.push(...r) : t.push(r);
  }
  return t;
}
function TH(e) {
  if (e.type === "footnoteReference")
    return [];
  if (e.type === "link" || e.type === "linkReference")
    return fi(e.children);
  if ("children" in e) {
    const { children: r, position: n, ...s } = e;
    return Object.assign(Da(s), {
      children: fi(e.children)
    });
  }
  const { position: t, ...a } = e;
  return Da(a);
}
function vH(e, t) {
  const a = t || {}, r = a.heading ? D0(a.heading) : void 0, n = wH(e, r, a);
  return {
    index: r ? n.index : void 0,
    endIndex: r ? n.endIndex : void 0,
    map: n.map.length > 0 ? EH(n.map, a) : void 0
  };
}
function xH(e) {
  const t = {
    ...e,
    heading: e && e.heading || "(table[ -]of[ -])?contents?|toc",
    tight: e && typeof e.tight == "boolean" ? e.tight : !0
  };
  return function(a) {
    const r = vH(a, t);
    r.endIndex === void 0 || r.endIndex === -1 || r.index === void 0 || r.index === -1 || !r.map || (a.children = [
      ...a.children.slice(0, r.index),
      r.map,
      ...a.children.slice(r.endIndex)
    ]);
  };
}
const $c = /[#.]/g;
function AH(e, t) {
  const a = e || "", r = {};
  let n = 0, s, i;
  for (; n < a.length; ) {
    $c.lastIndex = n;
    const o = $c.exec(a), c = a.slice(n, o ? o.index : a.length);
    c && (s ? s === "#" ? r.id = c : Array.isArray(r.className) ? r.className.push(c) : r.className = [c] : i = c, n += c.length), o && (s = o[0], n++);
  }
  return {
    type: "element",
    // @ts-expect-error: tag name is parsed.
    tagName: i || t || "div",
    properties: r,
    children: []
  };
}
const DH = /* @__PURE__ */ new Set(["button", "menu", "reset", "submit"]), hi = {}.hasOwnProperty;
function C0(e, t, a) {
  const r = a && NH(a);
  function n(s, i, ...o) {
    let c = -1, u;
    if (s == null) {
      u = { type: "root", children: [] };
      const d = (
        /** @type {Child} */
        i
      );
      o.unshift(d);
    } else if (u = AH(s, t), u.tagName = u.tagName.toLowerCase(), r && hi.call(r, u.tagName) && (u.tagName = r[u.tagName]), CH(i, u.tagName)) {
      let d;
      for (d in i)
        hi.call(i, d) && SH(e, u.properties, d, i[d]);
    } else
      o.unshift(i);
    for (; ++c < o.length; )
      di(u.children, o[c]);
    return u.type === "element" && u.tagName === "template" && (u.content = { type: "root", children: u.children }, u.children = []), u;
  }
  return n;
}
function CH(e, t) {
  return e == null || typeof e != "object" || Array.isArray(e) ? !1 : t === "input" || !e.type || typeof e.type != "string" ? !0 : "children" in e && Array.isArray(e.children) ? !1 : t === "button" ? DH.has(e.type.toLowerCase()) : !("value" in e);
}
function SH(e, t, a, r) {
  const n = Hn(e, a);
  let s = -1, i;
  if (r != null) {
    if (typeof r == "number") {
      if (Number.isNaN(r)) return;
      i = r;
    } else typeof r == "boolean" ? i = r : typeof r == "string" ? n.spaceSeparated ? i = yo(r) : n.commaSeparated ? i = fo(r) : n.commaOrSpaceSeparated ? i = yo(fo(r).join(" ")) : i = Xc(n, n.property, r) : Array.isArray(r) ? i = r.concat() : i = n.property === "style" ? zH(r) : String(r);
    if (Array.isArray(i)) {
      const o = [];
      for (; ++s < i.length; ) {
        const c = (
          /** @type {number | string} */
          Xc(n, n.property, i[s])
        );
        o[s] = c;
      }
      i = o;
    }
    if (n.property === "className" && Array.isArray(t.className)) {
      const o = (
        /** @type {number | string} */
        i
      );
      i = t.className.concat(o);
    }
    t[n.property] = i;
  }
}
function di(e, t) {
  let a = -1;
  if (t != null) if (typeof t == "string" || typeof t == "number")
    e.push({ type: "text", value: String(t) });
  else if (Array.isArray(t))
    for (; ++a < t.length; )
      di(e, t[a]);
  else if (typeof t == "object" && "type" in t)
    t.type === "root" ? di(e, t.children) : e.push(t);
  else
    throw new Error("Expected node, nodes, or string, got `" + t + "`");
}
function Xc(e, t, a) {
  if (typeof a == "string") {
    if (e.number && a && !Number.isNaN(Number(a)))
      return Number(a);
    if ((e.boolean || e.overloadedBoolean) && (a === "" || Vr(a) === Vr(t)))
      return !0;
  }
  return a;
}
function zH(e) {
  const t = [];
  let a;
  for (a in e)
    hi.call(e, a) && t.push([a, e[a]].join(": "));
  return t.join("; ");
}
function NH(e) {
  const t = {};
  let a = -1;
  for (; ++a < e.length; )
    t[e[a].toLowerCase()] = e[a];
  return t;
}
const IH = [
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "solidColor",
  "textArea",
  "textPath"
], S0 = C0(Kr, "div"), z0 = C0(Na, "g", IH), Zt = {
  html: "http://www.w3.org/1999/xhtml",
  mathml: "http://www.w3.org/1998/Math/MathML",
  svg: "http://www.w3.org/2000/svg",
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function RH(e, t) {
  return N0(e, {}) || { type: "root", children: [] };
}
function N0(e, t) {
  const a = FH(e, t);
  return a && t.afterTransform && t.afterTransform(e, a), a;
}
function FH(e, t) {
  switch (e.nodeType) {
    case 1:
      return BH(
        /** @type {Element} */
        e,
        t
      );
    case 3:
      return LH(
        /** @type {Text} */
        e
      );
    case 8:
      return MH(
        /** @type {Comment} */
        e
      );
    case 9:
      return Qc(
        /** @type {Document} */
        e,
        t
      );
    case 10:
      return OH();
    case 11:
      return Qc(
        /** @type {DocumentFragment} */
        e,
        t
      );
    default:
      return;
  }
}
function Qc(e, t) {
  return { type: "root", children: I0(e, t) };
}
function OH() {
  return { type: "doctype" };
}
function LH(e) {
  return { type: "text", value: e.nodeValue || "" };
}
function MH(e) {
  return { type: "comment", value: e.nodeValue || "" };
}
function BH(e, t) {
  const a = e.namespaceURI, r = a === Zt.svg ? z0 : S0, n = a === Zt.html ? e.tagName.toLowerCase() : e.tagName, s = (
    // @ts-expect-error: DOM types are wrong, content can exist.
    a === Zt.html && n === "template" ? e.content : e
  ), i = e.getAttributeNames(), o = {};
  let c = -1;
  for (; ++c < i.length; )
    o[i[c]] = e.getAttribute(i[c]) || "";
  return r(n, o, I0(s, t));
}
function I0(e, t) {
  const a = e.childNodes, r = [];
  let n = -1;
  for (; ++n < a.length; ) {
    const s = N0(a[n], t);
    s !== void 0 && r.push(s);
  }
  return r;
}
new DOMParser();
function PH(e, t) {
  const a = HH(e);
  return (
    /** @type {Root} */
    RH(a)
  );
}
function HH(e) {
  const t = document.createElement("template");
  return t.innerHTML = e, t.content;
}
const Kc = (
  // Note: overloads like this are needed to support optional generics.
  /**
   * @type {(
   *   (<Kind extends UnistParent, Check extends Test>(parent: Kind, index: Child<Kind> | number, test: Check) => Matches<Child<Kind>, Check> | undefined) &
   *   (<Kind extends UnistParent>(parent: Kind, index: Child<Kind> | number, test?: null | undefined) => Child<Kind> | undefined)
   * )}
   */
  /**
   * @param {UnistParent} parent
   * @param {UnistNode | number} index
   * @param {Test} [test]
   * @returns {UnistNode | undefined}
   */
  function(e, t, a) {
    const r = cr(a);
    if (!e || !e.type || !e.children)
      throw new Error("Expected parent node");
    if (typeof t == "number") {
      if (t < 0 || t === Number.POSITIVE_INFINITY)
        throw new Error("Expected positive finite number as index");
    } else if (t = e.children.indexOf(t), t < 0)
      throw new Error("Expected child node or index");
    for (; ++t < e.children.length; )
      if (r(e.children[t], t, e))
        return e.children[t];
  }
), $a = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends TestFunction>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &
   *   (<Condition extends string>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &
   *   ((test?: null | undefined) => (element?: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test | null | undefined} [test]
   * @returns {Check}
   */
  function(e) {
    if (e == null)
      return qH;
    if (typeof e == "string")
      return jH(e);
    if (typeof e == "object")
      return UH(e);
    if (typeof e == "function")
      return to(e);
    throw new Error("Expected function, string, or array as `test`");
  }
);
function UH(e) {
  const t = [];
  let a = -1;
  for (; ++a < e.length; )
    t[a] = $a(e[a]);
  return to(r);
  function r(...n) {
    let s = -1;
    for (; ++s < t.length; )
      if (t[s].apply(this, n)) return !0;
    return !1;
  }
}
function jH(e) {
  return to(t);
  function t(a) {
    return a.tagName === e;
  }
}
function to(e) {
  return t;
  function t(a, r, n) {
    return !!(YH(a) && e.call(
      this,
      a,
      typeof r == "number" ? r : void 0,
      n || void 0
    ));
  }
}
function qH(e) {
  return !!(e && typeof e == "object" && "type" in e && e.type === "element" && "tagName" in e && typeof e.tagName == "string");
}
function YH(e) {
  return e !== null && typeof e == "object" && "type" in e && "tagName" in e;
}
const Jc = /\n/g, Zc = /[\t ]+/g, mi = $a("br"), el = $a(JH), VH = $a("p"), tl = $a("tr"), GH = $a([
  // List from: <https://html.spec.whatwg.org/multipage/rendering.html#hidden-elements>
  "datalist",
  "head",
  "noembed",
  "noframes",
  "noscript",
  // Act as if we support scripting.
  "rp",
  "script",
  "style",
  "template",
  "title",
  // Hidden attribute.
  KH,
  // From: <https://html.spec.whatwg.org/multipage/rendering.html#flow-content-3>
  ZH
]), R0 = $a([
  "address",
  // Flow content
  "article",
  // Sections and headings
  "aside",
  // Sections and headings
  "blockquote",
  // Flow content
  "body",
  // Page
  "caption",
  // `table-caption`
  "center",
  // Flow content (legacy)
  "dd",
  // Lists
  "dialog",
  // Flow content
  "dir",
  // Lists (legacy)
  "dl",
  // Lists
  "dt",
  // Lists
  "div",
  // Flow content
  "figure",
  // Flow content
  "figcaption",
  // Flow content
  "footer",
  // Flow content
  "form,",
  // Flow content
  "h1",
  // Sections and headings
  "h2",
  // Sections and headings
  "h3",
  // Sections and headings
  "h4",
  // Sections and headings
  "h5",
  // Sections and headings
  "h6",
  // Sections and headings
  "header",
  // Flow content
  "hgroup",
  // Sections and headings
  "hr",
  // Flow content
  "html",
  // Page
  "legend",
  // Flow content
  "li",
  // Lists (as `display: list-item`)
  "listing",
  // Flow content (legacy)
  "main",
  // Flow content
  "menu",
  // Lists
  "nav",
  // Sections and headings
  "ol",
  // Lists
  "p",
  // Flow content
  "plaintext",
  // Flow content (legacy)
  "pre",
  // Flow content
  "section",
  // Sections and headings
  "ul",
  // Lists
  "xmp"
  // Flow content (legacy)
]);
function WH(e, t) {
  const a = t || {}, r = "children" in e ? e.children : [], n = R0(e), s = L0(e, {
    whitespace: a.whitespace || "normal",
    breakBefore: !1,
    breakAfter: !1
  }), i = [];
  (e.type === "text" || e.type === "comment") && i.push(
    ...O0(e, {
      whitespace: s,
      breakBefore: !0,
      breakAfter: !0
    })
  );
  let o = -1;
  for (; ++o < r.length; )
    i.push(
      ...F0(
        r[o],
        // @ts-expect-error: `tree` is a parent if were here.
        e,
        {
          whitespace: s,
          breakBefore: o ? void 0 : n,
          breakAfter: o < r.length - 1 ? mi(r[o + 1]) : n
        }
      )
    );
  const c = [];
  let u;
  for (o = -1; ++o < i.length; ) {
    const d = i[o];
    typeof d == "number" ? u !== void 0 && d > u && (u = d) : d && (u !== void 0 && u > -1 && c.push(`
`.repeat(u) || " "), u = -1, c.push(d));
  }
  return c.join("");
}
function F0(e, t, a) {
  return e.type === "element" ? $H(e, t, a) : e.type === "text" ? a.whitespace === "normal" ? O0(e, a) : XH(e) : [];
}
function $H(e, t, a) {
  const r = L0(e, a), n = e.children || [];
  let s = -1, i = [];
  if (GH(e))
    return i;
  let o, c;
  for (mi(e) || tl(e) && // @ts-expect-error: something up with types of parents.
  Kc(t, e, tl) ? c = `
` : VH(e) ? (o = 2, c = 2) : R0(e) && (o = 1, c = 1); ++s < n.length; )
    i = i.concat(
      F0(n[s], e, {
        whitespace: r,
        breakBefore: s ? void 0 : o,
        breakAfter: s < n.length - 1 ? mi(n[s + 1]) : c
      })
    );
  return el(e) && // @ts-expect-error: something up with types of parents.
  Kc(t, e, el) && i.push("	"), o && i.unshift(o), c && i.push(c), i;
}
function O0(e, t) {
  const a = String(e.value), r = [], n = [];
  let s = 0;
  for (; s <= a.length; ) {
    Jc.lastIndex = s;
    const c = Jc.exec(a), u = c && "index" in c ? c.index : a.length;
    r.push(
      // Any sequence of collapsible spaces and tabs immediately preceding or
      // following a segment break is removed.
      QH(
        // [] ignoring bidi formatting characters (characters with the
        // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if
        // they were not there.
        a.slice(s, u).replace(/[\u061C\u200E\u200F\u202A-\u202E\u2066-\u2069]/g, ""),
        s === 0 ? t.breakBefore : !0,
        u === a.length ? t.breakAfter : !0
      )
    ), s = u + 1;
  }
  let i = -1, o;
  for (; ++i < r.length; )
    r[i].charCodeAt(r[i].length - 1) === 8203 || i < r.length - 1 && r[i + 1].charCodeAt(0) === 8203 ? (n.push(r[i]), o = void 0) : r[i] ? (typeof o == "number" && n.push(o), n.push(r[i]), o = 0) : (i === 0 || i === r.length - 1) && n.push(0);
  return n;
}
function XH(e) {
  return [String(e.value)];
}
function QH(e, t, a) {
  const r = [];
  let n = 0, s;
  for (; n < e.length; ) {
    Zc.lastIndex = n;
    const i = Zc.exec(e);
    s = i ? i.index : e.length, !n && !s && i && !t && r.push(""), n !== s && r.push(e.slice(n, s)), n = i ? s + i[0].length : s;
  }
  return n !== s && !a && r.push(""), r.join(" ");
}
function L0(e, t) {
  if (e.type === "element") {
    const a = e.properties || {};
    switch (e.tagName) {
      case "listing":
      case "plaintext":
      case "xmp":
        return "pre";
      case "nobr":
        return "nowrap";
      case "pre":
        return a.wrap ? "pre-wrap" : "pre";
      case "td":
      case "th":
        return a.noWrap ? "nowrap" : t.whitespace;
      case "textarea":
        return "pre-wrap";
    }
  }
  return t.whitespace;
}
function KH(e) {
  return !!(e.properties || {}).hidden;
}
function JH(e) {
  return e.tagName === "td" || e.tagName === "th";
}
function ZH(e) {
  return e.tagName === "dialog" && !(e.properties || {}).open;
}
const eU = {}, tU = [];
function aU(e) {
  const t = e || eU;
  return function(a, r) {
    zi(a, "element", function(n, s) {
      const i = Array.isArray(n.properties.className) ? n.properties.className : tU, o = i.includes("language-math"), c = i.includes("math-display"), u = i.includes("math-inline");
      let d = c;
      if (!o && !c && !u)
        return;
      let m = s[s.length - 1], h = n;
      if (n.tagName === "code" && o && m && m.type === "element" && m.tagName === "pre" && (h = m, m = s[s.length - 2], d = !0), !m) return;
      const y = WH(h, { whitespace: "pre" });
      let w;
      try {
        w = Vc.renderToString(y, {
          ...t,
          displayMode: d,
          throwOnError: !0
        });
      } catch (F) {
        const z = (
          /** @type {Error} */
          F
        ), C = z.name.toLowerCase();
        r.message("Could not render math with KaTeX", {
          ancestors: [...s, n],
          cause: z,
          place: n.position,
          ruleId: C,
          source: "rehype-katex"
        });
        try {
          w = Vc.renderToString(y, {
            ...t,
            displayMode: d,
            strict: "ignore",
            throwOnError: !1
          });
        } catch {
          w = [
            {
              type: "element",
              tagName: "span",
              properties: {
                className: ["katex-error"],
                style: "color:" + (t.errorColor || "#cc0000"),
                title: String(F)
              },
              children: [{ type: "text", value: y }]
            }
          ];
        }
      }
      typeof w == "string" && (w = /** @type {Array<ElementContent>} */
      PH(w).children);
      const v = m.children.indexOf(h);
      return m.children.splice(v, 1, ...w), eu;
    });
  };
}
function rU(e) {
  const t = String(e), a = [];
  return { toOffset: n, toPoint: r };
  function r(s) {
    if (typeof s == "number" && s > -1 && s <= t.length) {
      let i = 0;
      for (; ; ) {
        let o = a[i];
        if (o === void 0) {
          const c = al(t, a[i - 1]);
          o = c === -1 ? t.length + 1 : c + 1, a[i] = o;
        }
        if (o > s)
          return {
            line: i + 1,
            column: s - (i > 0 ? a[i - 1] : 0) + 1,
            offset: s
          };
        i++;
      }
    }
  }
  function n(s) {
    if (s && typeof s.line == "number" && typeof s.column == "number" && !Number.isNaN(s.line) && !Number.isNaN(s.column)) {
      for (; a.length < s.line; ) {
        const o = a[a.length - 1], c = al(t, o), u = c === -1 ? t.length + 1 : c + 1;
        if (o === u) break;
        a.push(u);
      }
      const i = (s.line > 1 ? a[s.line - 2] : 0) + s.column - 1;
      if (i < a[s.line - 1]) return i;
    }
  }
}
function al(e, t) {
  const a = e.indexOf("\r", t), r = e.indexOf(`
`, t);
  return r === -1 ? a : a === -1 || a + 1 === r ? r : a < r ? a : r;
}
const M0 = {}.hasOwnProperty, nU = Object.prototype;
function sU(e, t) {
  const a = t || {};
  return ao(
    {
      file: a.file || void 0,
      location: !1,
      schema: a.space === "svg" ? Na : Kr,
      verbose: a.verbose || !1
    },
    e
  );
}
function ao(e, t) {
  let a;
  switch (t.nodeName) {
    case "#comment": {
      const r = (
        /** @type {P5Comment} */
        t
      );
      return a = { type: "comment", value: r.data }, An(e, r, a), a;
    }
    case "#document":
    case "#document-fragment": {
      const r = (
        /** @type {P5Document | P5DocumentFragment} */
        t
      ), n = "mode" in r ? r.mode === "quirks" || r.mode === "limited-quirks" : !1;
      if (a = {
        type: "root",
        children: B0(e, t.childNodes),
        data: { quirksMode: n }
      }, e.file && e.location) {
        const s = String(e.file), i = rU(s), o = i.toPoint(0), c = i.toPoint(s.length);
        a.position = { start: o, end: c };
      }
      return a;
    }
    case "#documentType": {
      const r = (
        /** @type {P5DocumentType} */
        t
      );
      return a = { type: "doctype" }, An(e, r, a), a;
    }
    case "#text": {
      const r = (
        /** @type {P5Text} */
        t
      );
      return a = { type: "text", value: r.value }, An(e, r, a), a;
    }
    default:
      return a = iU(
        e,
        /** @type {P5Element} */
        t
      ), a;
  }
}
function B0(e, t) {
  let a = -1;
  const r = [];
  for (; ++a < t.length; ) {
    const n = (
      /** @type {RootContent} */
      ao(e, t[a])
    );
    r.push(n);
  }
  return r;
}
function iU(e, t) {
  const a = e.schema;
  e.schema = t.namespaceURI === Zt.svg ? Na : Kr;
  let r = -1;
  const n = {};
  for (; ++r < t.attrs.length; ) {
    const o = t.attrs[r], c = (o.prefix ? o.prefix + ":" : "") + o.name;
    M0.call(nU, c) || (n[c] = o.value);
  }
  const i = (e.schema.space === "svg" ? z0 : S0)(t.tagName, n, B0(e, t.childNodes));
  if (An(e, t, i), i.tagName === "template") {
    const o = (
      /** @type {P5Template} */
      t
    ), c = o.sourceCodeLocation, u = c && c.startTag && tr(c.startTag), d = c && c.endTag && tr(c.endTag), m = (
      /** @type {Root} */
      ao(e, o.content)
    );
    u && d && e.file && (m.position = { start: u.end, end: d.start }), i.content = m;
  }
  return e.schema = a, i;
}
function An(e, t, a) {
  if ("sourceCodeLocation" in t && t.sourceCodeLocation && e.file) {
    const r = oU(e, a, t.sourceCodeLocation);
    r && (e.location = !0, a.position = r);
  }
}
function oU(e, t, a) {
  const r = tr(a);
  if (t.type === "element") {
    const n = t.children[t.children.length - 1];
    if (r && !a.endTag && n && n.position && n.position.end && (r.end = Object.assign({}, n.position.end)), e.verbose) {
      const s = {};
      let i;
      if (a.attrs)
        for (i in a.attrs)
          M0.call(a.attrs, i) && (s[Hn(e.schema, i).property] = tr(
            a.attrs[i]
          ));
      a.startTag;
      const o = tr(a.startTag), c = a.endTag ? tr(a.endTag) : void 0, u = { opening: o };
      c && (u.closing = c), u.properties = s, t.data = { position: u };
    }
  }
  return r;
}
function tr(e) {
  const t = rl({
    line: e.startLine,
    column: e.startCol,
    offset: e.startOffset
  }), a = rl({
    line: e.endLine,
    column: e.endCol,
    offset: e.endOffset
  });
  return t || a ? { start: t, end: a } : void 0;
}
function rl(e) {
  return e.line && e.column ? e : void 0;
}
const cU = {}, lU = {}.hasOwnProperty, P0 = ou("type", { handlers: { root: fU, element: gU, text: mU, comment: pU, doctype: dU } });
function uU(e, t) {
  const r = (t || cU).space;
  return P0(e, r === "svg" ? Na : Kr);
}
function fU(e, t) {
  const a = {
    nodeName: "#document",
    // @ts-expect-error: `parse5` uses enums, which are actually strings.
    mode: (e.data || {}).quirksMode ? "quirks" : "no-quirks",
    childNodes: []
  };
  return a.childNodes = ro(e.children, a, t), hr(e, a), a;
}
function hU(e, t) {
  const a = { nodeName: "#document-fragment", childNodes: [] };
  return a.childNodes = ro(e.children, a, t), hr(e, a), a;
}
function dU(e) {
  const t = {
    nodeName: "#documentType",
    name: "html",
    publicId: "",
    systemId: "",
    parentNode: null
  };
  return hr(e, t), t;
}
function mU(e) {
  const t = {
    nodeName: "#text",
    value: e.value,
    parentNode: null
  };
  return hr(e, t), t;
}
function pU(e) {
  const t = {
    nodeName: "#comment",
    data: e.value,
    parentNode: null
  };
  return hr(e, t), t;
}
function gU(e, t) {
  const a = t;
  let r = a;
  e.type === "element" && e.tagName.toLowerCase() === "svg" && a.space === "html" && (r = Na);
  const n = [];
  let s;
  if (e.properties) {
    for (s in e.properties)
      if (s !== "children" && lU.call(e.properties, s)) {
        const c = yU(
          r,
          s,
          e.properties[s]
        );
        c && n.push(c);
      }
  }
  const i = r.space, o = {
    nodeName: e.tagName,
    tagName: e.tagName,
    attrs: n,
    // @ts-expect-error: `parse5` types are wrong.
    namespaceURI: Zt[i],
    childNodes: [],
    parentNode: null
  };
  return o.childNodes = ro(e.children, o, r), hr(e, o), e.tagName === "template" && e.content && (o.content = hU(e.content, r)), o;
}
function yU(e, t, a) {
  const r = Hn(e, t);
  if (a === !1 || a === null || a === void 0 || typeof a == "number" && Number.isNaN(a) || !a && r.boolean)
    return;
  Array.isArray(a) && (a = r.commaSeparated ? _l(a) : Dl(a));
  const n = {
    name: r.attribute,
    value: a === !0 ? "" : String(a)
  };
  if (r.space && r.space !== "html" && r.space !== "svg") {
    const s = n.name.indexOf(":");
    s < 0 ? n.prefix = "" : (n.name = n.name.slice(s + 1), n.prefix = r.attribute.slice(0, s)), n.namespace = Zt[r.space];
  }
  return n;
}
function ro(e, t, a) {
  let r = -1;
  const n = [];
  if (e)
    for (; ++r < e.length; ) {
      const s = P0(e[r], a);
      s.parentNode = t, n.push(s);
    }
  return n;
}
function hr(e, t) {
  const a = e.position;
  a && a.start && a.end && (a.start.offset, a.end.offset, t.sourceCodeLocation = {
    startLine: a.start.line,
    startCol: a.start.column,
    startOffset: a.start.offset,
    endLine: a.end.line,
    endCol: a.end.column,
    endOffset: a.end.offset
  });
}
const _U = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
], bU = /* @__PURE__ */ new Set([
  65534,
  65535,
  131070,
  131071,
  196606,
  196607,
  262142,
  262143,
  327678,
  327679,
  393214,
  393215,
  458750,
  458751,
  524286,
  524287,
  589822,
  589823,
  655358,
  655359,
  720894,
  720895,
  786430,
  786431,
  851966,
  851967,
  917502,
  917503,
  983038,
  983039,
  1048574,
  1048575,
  1114110,
  1114111
]), qe = "";
var E;
(function(e) {
  e[e.EOF = -1] = "EOF", e[e.NULL = 0] = "NULL", e[e.TABULATION = 9] = "TABULATION", e[e.CARRIAGE_RETURN = 13] = "CARRIAGE_RETURN", e[e.LINE_FEED = 10] = "LINE_FEED", e[e.FORM_FEED = 12] = "FORM_FEED", e[e.SPACE = 32] = "SPACE", e[e.EXCLAMATION_MARK = 33] = "EXCLAMATION_MARK", e[e.QUOTATION_MARK = 34] = "QUOTATION_MARK", e[e.NUMBER_SIGN = 35] = "NUMBER_SIGN", e[e.AMPERSAND = 38] = "AMPERSAND", e[e.APOSTROPHE = 39] = "APOSTROPHE", e[e.HYPHEN_MINUS = 45] = "HYPHEN_MINUS", e[e.SOLIDUS = 47] = "SOLIDUS", e[e.DIGIT_0 = 48] = "DIGIT_0", e[e.DIGIT_9 = 57] = "DIGIT_9", e[e.SEMICOLON = 59] = "SEMICOLON", e[e.LESS_THAN_SIGN = 60] = "LESS_THAN_SIGN", e[e.EQUALS_SIGN = 61] = "EQUALS_SIGN", e[e.GREATER_THAN_SIGN = 62] = "GREATER_THAN_SIGN", e[e.QUESTION_MARK = 63] = "QUESTION_MARK", e[e.LATIN_CAPITAL_A = 65] = "LATIN_CAPITAL_A", e[e.LATIN_CAPITAL_F = 70] = "LATIN_CAPITAL_F", e[e.LATIN_CAPITAL_X = 88] = "LATIN_CAPITAL_X", e[e.LATIN_CAPITAL_Z = 90] = "LATIN_CAPITAL_Z", e[e.RIGHT_SQUARE_BRACKET = 93] = "RIGHT_SQUARE_BRACKET", e[e.GRAVE_ACCENT = 96] = "GRAVE_ACCENT", e[e.LATIN_SMALL_A = 97] = "LATIN_SMALL_A", e[e.LATIN_SMALL_F = 102] = "LATIN_SMALL_F", e[e.LATIN_SMALL_X = 120] = "LATIN_SMALL_X", e[e.LATIN_SMALL_Z = 122] = "LATIN_SMALL_Z", e[e.REPLACEMENT_CHARACTER = 65533] = "REPLACEMENT_CHARACTER";
})(E = E || (E = {}));
const kt = {
  DASH_DASH: "--",
  CDATA_START: "[CDATA[",
  DOCTYPE: "doctype",
  SCRIPT: "script",
  PUBLIC: "public",
  SYSTEM: "system"
};
function H0(e) {
  return e >= 55296 && e <= 57343;
}
function kU(e) {
  return e >= 56320 && e <= 57343;
}
function wU(e, t) {
  return (e - 55296) * 1024 + 9216 + t;
}
function U0(e) {
  return e !== 32 && e !== 10 && e !== 13 && e !== 9 && e !== 12 && e >= 1 && e <= 31 || e >= 127 && e <= 159;
}
function j0(e) {
  return e >= 64976 && e <= 65007 || bU.has(e);
}
var j;
(function(e) {
  e.controlCharacterInInputStream = "control-character-in-input-stream", e.noncharacterInInputStream = "noncharacter-in-input-stream", e.surrogateInInputStream = "surrogate-in-input-stream", e.nonVoidHtmlElementStartTagWithTrailingSolidus = "non-void-html-element-start-tag-with-trailing-solidus", e.endTagWithAttributes = "end-tag-with-attributes", e.endTagWithTrailingSolidus = "end-tag-with-trailing-solidus", e.unexpectedSolidusInTag = "unexpected-solidus-in-tag", e.unexpectedNullCharacter = "unexpected-null-character", e.unexpectedQuestionMarkInsteadOfTagName = "unexpected-question-mark-instead-of-tag-name", e.invalidFirstCharacterOfTagName = "invalid-first-character-of-tag-name", e.unexpectedEqualsSignBeforeAttributeName = "unexpected-equals-sign-before-attribute-name", e.missingEndTagName = "missing-end-tag-name", e.unexpectedCharacterInAttributeName = "unexpected-character-in-attribute-name", e.unknownNamedCharacterReference = "unknown-named-character-reference", e.missingSemicolonAfterCharacterReference = "missing-semicolon-after-character-reference", e.unexpectedCharacterAfterDoctypeSystemIdentifier = "unexpected-character-after-doctype-system-identifier", e.unexpectedCharacterInUnquotedAttributeValue = "unexpected-character-in-unquoted-attribute-value", e.eofBeforeTagName = "eof-before-tag-name", e.eofInTag = "eof-in-tag", e.missingAttributeValue = "missing-attribute-value", e.missingWhitespaceBetweenAttributes = "missing-whitespace-between-attributes", e.missingWhitespaceAfterDoctypePublicKeyword = "missing-whitespace-after-doctype-public-keyword", e.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers = "missing-whitespace-between-doctype-public-and-system-identifiers", e.missingWhitespaceAfterDoctypeSystemKeyword = "missing-whitespace-after-doctype-system-keyword", e.missingQuoteBeforeDoctypePublicIdentifier = "missing-quote-before-doctype-public-identifier", e.missingQuoteBeforeDoctypeSystemIdentifier = "missing-quote-before-doctype-system-identifier", e.missingDoctypePublicIdentifier = "missing-doctype-public-identifier", e.missingDoctypeSystemIdentifier = "missing-doctype-system-identifier", e.abruptDoctypePublicIdentifier = "abrupt-doctype-public-identifier", e.abruptDoctypeSystemIdentifier = "abrupt-doctype-system-identifier", e.cdataInHtmlContent = "cdata-in-html-content", e.incorrectlyOpenedComment = "incorrectly-opened-comment", e.eofInScriptHtmlCommentLikeText = "eof-in-script-html-comment-like-text", e.eofInDoctype = "eof-in-doctype", e.nestedComment = "nested-comment", e.abruptClosingOfEmptyComment = "abrupt-closing-of-empty-comment", e.eofInComment = "eof-in-comment", e.incorrectlyClosedComment = "incorrectly-closed-comment", e.eofInCdata = "eof-in-cdata", e.absenceOfDigitsInNumericCharacterReference = "absence-of-digits-in-numeric-character-reference", e.nullCharacterReference = "null-character-reference", e.surrogateCharacterReference = "surrogate-character-reference", e.characterReferenceOutsideUnicodeRange = "character-reference-outside-unicode-range", e.controlCharacterReference = "control-character-reference", e.noncharacterCharacterReference = "noncharacter-character-reference", e.missingWhitespaceBeforeDoctypeName = "missing-whitespace-before-doctype-name", e.missingDoctypeName = "missing-doctype-name", e.invalidCharacterSequenceAfterDoctypeName = "invalid-character-sequence-after-doctype-name", e.duplicateAttribute = "duplicate-attribute", e.nonConformingDoctype = "non-conforming-doctype", e.missingDoctype = "missing-doctype", e.misplacedDoctype = "misplaced-doctype", e.endTagWithoutMatchingOpenElement = "end-tag-without-matching-open-element", e.closingOfElementWithOpenChildElements = "closing-of-element-with-open-child-elements", e.disallowedContentInNoscriptInHead = "disallowed-content-in-noscript-in-head", e.openElementsLeftAfterEof = "open-elements-left-after-eof", e.abandonedHeadElementChild = "abandoned-head-element-child", e.misplacedStartTagForHeadElement = "misplaced-start-tag-for-head-element", e.nestedNoscriptInHead = "nested-noscript-in-head", e.eofInElementThatCanContainOnlyText = "eof-in-element-that-can-contain-only-text";
})(j = j || (j = {}));
const EU = 65536;
class TU {
  constructor(t) {
    this.handler = t, this.html = "", this.pos = -1, this.lastGapPos = -2, this.gapStack = [], this.skipNextNewLine = !1, this.lastChunkWritten = !1, this.endOfChunkHit = !1, this.bufferWaterline = EU, this.isEol = !1, this.lineStartPos = 0, this.droppedBufferSize = 0, this.line = 1, this.lastErrOffset = -1;
  }
  /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */
  get col() {
    return this.pos - this.lineStartPos + +(this.lastGapPos !== this.pos);
  }
  get offset() {
    return this.droppedBufferSize + this.pos;
  }
  getError(t) {
    const { line: a, col: r, offset: n } = this;
    return {
      code: t,
      startLine: a,
      endLine: a,
      startCol: r,
      endCol: r,
      startOffset: n,
      endOffset: n
    };
  }
  _err(t) {
    this.handler.onParseError && this.lastErrOffset !== this.offset && (this.lastErrOffset = this.offset, this.handler.onParseError(this.getError(t)));
  }
  _addGap() {
    this.gapStack.push(this.lastGapPos), this.lastGapPos = this.pos;
  }
  _processSurrogate(t) {
    if (this.pos !== this.html.length - 1) {
      const a = this.html.charCodeAt(this.pos + 1);
      if (kU(a))
        return this.pos++, this._addGap(), wU(t, a);
    } else if (!this.lastChunkWritten)
      return this.endOfChunkHit = !0, E.EOF;
    return this._err(j.surrogateInInputStream), t;
  }
  willDropParsedChunk() {
    return this.pos > this.bufferWaterline;
  }
  dropParsedChunk() {
    this.willDropParsedChunk() && (this.html = this.html.substring(this.pos), this.lineStartPos -= this.pos, this.droppedBufferSize += this.pos, this.pos = 0, this.lastGapPos = -2, this.gapStack.length = 0);
  }
  write(t, a) {
    this.html.length > 0 ? this.html += t : this.html = t, this.endOfChunkHit = !1, this.lastChunkWritten = a;
  }
  insertHtmlAtCurrentPos(t) {
    this.html = this.html.substring(0, this.pos + 1) + t + this.html.substring(this.pos + 1), this.endOfChunkHit = !1;
  }
  startsWith(t, a) {
    if (this.pos + t.length > this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, !1;
    if (a)
      return this.html.startsWith(t, this.pos);
    for (let r = 0; r < t.length; r++)
      if ((this.html.charCodeAt(this.pos + r) | 32) !== t.charCodeAt(r))
        return !1;
    return !0;
  }
  peek(t) {
    const a = this.pos + t;
    if (a >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, E.EOF;
    const r = this.html.charCodeAt(a);
    return r === E.CARRIAGE_RETURN ? E.LINE_FEED : r;
  }
  advance() {
    if (this.pos++, this.isEol && (this.isEol = !1, this.line++, this.lineStartPos = this.pos), this.pos >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, E.EOF;
    let t = this.html.charCodeAt(this.pos);
    return t === E.CARRIAGE_RETURN ? (this.isEol = !0, this.skipNextNewLine = !0, E.LINE_FEED) : t === E.LINE_FEED && (this.isEol = !0, this.skipNextNewLine) ? (this.line--, this.skipNextNewLine = !1, this._addGap(), this.advance()) : (this.skipNextNewLine = !1, H0(t) && (t = this._processSurrogate(t)), this.handler.onParseError === null || t > 31 && t < 127 || t === E.LINE_FEED || t === E.CARRIAGE_RETURN || t > 159 && t < 64976 || this._checkForProblematicCharacters(t), t);
  }
  _checkForProblematicCharacters(t) {
    U0(t) ? this._err(j.controlCharacterInInputStream) : j0(t) && this._err(j.noncharacterInInputStream);
  }
  retreat(t) {
    for (this.pos -= t; this.pos < this.lastGapPos; )
      this.lastGapPos = this.gapStack.pop(), this.pos--;
    this.isEol = !1;
  }
}
var ve;
(function(e) {
  e[e.CHARACTER = 0] = "CHARACTER", e[e.NULL_CHARACTER = 1] = "NULL_CHARACTER", e[e.WHITESPACE_CHARACTER = 2] = "WHITESPACE_CHARACTER", e[e.START_TAG = 3] = "START_TAG", e[e.END_TAG = 4] = "END_TAG", e[e.COMMENT = 5] = "COMMENT", e[e.DOCTYPE = 6] = "DOCTYPE", e[e.EOF = 7] = "EOF", e[e.HIBERNATION = 8] = "HIBERNATION";
})(ve = ve || (ve = {}));
function q0(e, t) {
  for (let a = e.attrs.length - 1; a >= 0; a--)
    if (e.attrs[a].name === t)
      return e.attrs[a].value;
  return null;
}
const Ta = new Uint16Array(
  // prettier-ignore
  '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map((e) => e.charCodeAt(0))
), vU = new Uint16Array(
  // prettier-ignore
  "aglq	\x1B\0\0p;os;t;t;uot;".split("").map((e) => e.charCodeAt(0))
);
var js;
const xU = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]), AU = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (js = String.fromCodePoint) !== null && js !== void 0 ? js : function(e) {
    let t = "";
    return e > 65535 && (e -= 65536, t += String.fromCharCode(e >>> 10 & 1023 | 55296), e = 56320 | e & 1023), t += String.fromCharCode(e), t;
  }
);
function DU(e) {
  var t;
  return e >= 55296 && e <= 57343 || e > 1114111 ? 65533 : (t = xU.get(e)) !== null && t !== void 0 ? t : e;
}
var ot;
(function(e) {
  e[e.NUM = 35] = "NUM", e[e.SEMI = 59] = "SEMI", e[e.EQUALS = 61] = "EQUALS", e[e.ZERO = 48] = "ZERO", e[e.NINE = 57] = "NINE", e[e.LOWER_A = 97] = "LOWER_A", e[e.LOWER_F = 102] = "LOWER_F", e[e.LOWER_X = 120] = "LOWER_X", e[e.LOWER_Z = 122] = "LOWER_Z", e[e.UPPER_A = 65] = "UPPER_A", e[e.UPPER_F = 70] = "UPPER_F", e[e.UPPER_Z = 90] = "UPPER_Z";
})(ot || (ot = {}));
const CU = 32;
var ea;
(function(e) {
  e[e.VALUE_LENGTH = 49152] = "VALUE_LENGTH", e[e.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", e[e.JUMP_TABLE = 127] = "JUMP_TABLE";
})(ea || (ea = {}));
function pi(e) {
  return e >= ot.ZERO && e <= ot.NINE;
}
function SU(e) {
  return e >= ot.UPPER_A && e <= ot.UPPER_F || e >= ot.LOWER_A && e <= ot.LOWER_F;
}
function zU(e) {
  return e >= ot.UPPER_A && e <= ot.UPPER_Z || e >= ot.LOWER_A && e <= ot.LOWER_Z || pi(e);
}
function NU(e) {
  return e === ot.EQUALS || zU(e);
}
var it;
(function(e) {
  e[e.EntityStart = 0] = "EntityStart", e[e.NumericStart = 1] = "NumericStart", e[e.NumericDecimal = 2] = "NumericDecimal", e[e.NumericHex = 3] = "NumericHex", e[e.NamedEntity = 4] = "NamedEntity";
})(it || (it = {}));
var Ya;
(function(e) {
  e[e.Legacy = 0] = "Legacy", e[e.Strict = 1] = "Strict", e[e.Attribute = 2] = "Attribute";
})(Ya || (Ya = {}));
class IU {
  constructor(t, a, r) {
    this.decodeTree = t, this.emitCodePoint = a, this.errors = r, this.state = it.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = Ya.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(t) {
    this.decodeMode = t, this.state = it.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(t, a) {
    switch (this.state) {
      case it.EntityStart:
        return t.charCodeAt(a) === ot.NUM ? (this.state = it.NumericStart, this.consumed += 1, this.stateNumericStart(t, a + 1)) : (this.state = it.NamedEntity, this.stateNamedEntity(t, a));
      case it.NumericStart:
        return this.stateNumericStart(t, a);
      case it.NumericDecimal:
        return this.stateNumericDecimal(t, a);
      case it.NumericHex:
        return this.stateNumericHex(t, a);
      case it.NamedEntity:
        return this.stateNamedEntity(t, a);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(t, a) {
    return a >= t.length ? -1 : (t.charCodeAt(a) | CU) === ot.LOWER_X ? (this.state = it.NumericHex, this.consumed += 1, this.stateNumericHex(t, a + 1)) : (this.state = it.NumericDecimal, this.stateNumericDecimal(t, a));
  }
  addToNumericResult(t, a, r, n) {
    if (a !== r) {
      const s = r - a;
      this.result = this.result * Math.pow(n, s) + parseInt(t.substr(a, s), n), this.consumed += s;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(t, a) {
    const r = a;
    for (; a < t.length; ) {
      const n = t.charCodeAt(a);
      if (pi(n) || SU(n))
        a += 1;
      else
        return this.addToNumericResult(t, r, a, 16), this.emitNumericEntity(n, 3);
    }
    return this.addToNumericResult(t, r, a, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(t, a) {
    const r = a;
    for (; a < t.length; ) {
      const n = t.charCodeAt(a);
      if (pi(n))
        a += 1;
      else
        return this.addToNumericResult(t, r, a, 10), this.emitNumericEntity(n, 2);
    }
    return this.addToNumericResult(t, r, a, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(t, a) {
    var r;
    if (this.consumed <= a)
      return (r = this.errors) === null || r === void 0 || r.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (t === ot.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === Ya.Strict)
      return 0;
    return this.emitCodePoint(DU(this.result), this.consumed), this.errors && (t !== ot.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(t, a) {
    const { decodeTree: r } = this;
    let n = r[this.treeIndex], s = (n & ea.VALUE_LENGTH) >> 14;
    for (; a < t.length; a++, this.excess++) {
      const i = t.charCodeAt(a);
      if (this.treeIndex = V0(r, n, this.treeIndex + Math.max(1, s), i), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === Ya.Attribute && // We shouldn't have consumed any characters after the entity,
        (s === 0 || // And there should be no invalid characters.
        NU(i)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (n = r[this.treeIndex], s = (n & ea.VALUE_LENGTH) >> 14, s !== 0) {
        if (i === ot.SEMI)
          return this.emitNamedEntityData(this.treeIndex, s, this.consumed + this.excess);
        this.decodeMode !== Ya.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var t;
    const { result: a, decodeTree: r } = this, n = (r[a] & ea.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(a, n, this.consumed), (t = this.errors) === null || t === void 0 || t.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(t, a, r) {
    const { decodeTree: n } = this;
    return this.emitCodePoint(a === 1 ? n[t] & ~ea.VALUE_LENGTH : n[t + 1], r), a === 3 && this.emitCodePoint(n[t + 2], r), r;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var t;
    switch (this.state) {
      case it.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== Ya.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      case it.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case it.NumericHex:
        return this.emitNumericEntity(0, 3);
      case it.NumericStart:
        return (t = this.errors) === null || t === void 0 || t.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case it.EntityStart:
        return 0;
    }
  }
}
function Y0(e) {
  let t = "";
  const a = new IU(e, (r) => t += AU(r));
  return function(n, s) {
    let i = 0, o = 0;
    for (; (o = n.indexOf("&", o)) >= 0; ) {
      t += n.slice(i, o), a.startEntity(s);
      const u = a.write(
        n,
        // Skip the "&"
        o + 1
      );
      if (u < 0) {
        i = o + a.end();
        break;
      }
      i = o + u, o = u === 0 ? i + 1 : i;
    }
    const c = t + n.slice(i);
    return t = "", c;
  };
}
function V0(e, t, a, r) {
  const n = (t & ea.BRANCH_LENGTH) >> 7, s = t & ea.JUMP_TABLE;
  if (n === 0)
    return s !== 0 && r === s ? a : -1;
  if (s) {
    const c = r - s;
    return c < 0 || c >= n ? -1 : e[a + c] - 1;
  }
  let i = a, o = i + n - 1;
  for (; i <= o; ) {
    const c = i + o >>> 1, u = e[c];
    if (u < r)
      i = c + 1;
    else if (u > r)
      o = c - 1;
    else
      return e[c + n];
  }
  return -1;
}
Y0(Ta);
Y0(vU);
var Y;
(function(e) {
  e.HTML = "http://www.w3.org/1999/xhtml", e.MATHML = "http://www.w3.org/1998/Math/MathML", e.SVG = "http://www.w3.org/2000/svg", e.XLINK = "http://www.w3.org/1999/xlink", e.XML = "http://www.w3.org/XML/1998/namespace", e.XMLNS = "http://www.w3.org/2000/xmlns/";
})(Y = Y || (Y = {}));
var Aa;
(function(e) {
  e.TYPE = "type", e.ACTION = "action", e.ENCODING = "encoding", e.PROMPT = "prompt", e.NAME = "name", e.COLOR = "color", e.FACE = "face", e.SIZE = "size";
})(Aa = Aa || (Aa = {}));
var Nt;
(function(e) {
  e.NO_QUIRKS = "no-quirks", e.QUIRKS = "quirks", e.LIMITED_QUIRKS = "limited-quirks";
})(Nt = Nt || (Nt = {}));
var L;
(function(e) {
  e.A = "a", e.ADDRESS = "address", e.ANNOTATION_XML = "annotation-xml", e.APPLET = "applet", e.AREA = "area", e.ARTICLE = "article", e.ASIDE = "aside", e.B = "b", e.BASE = "base", e.BASEFONT = "basefont", e.BGSOUND = "bgsound", e.BIG = "big", e.BLOCKQUOTE = "blockquote", e.BODY = "body", e.BR = "br", e.BUTTON = "button", e.CAPTION = "caption", e.CENTER = "center", e.CODE = "code", e.COL = "col", e.COLGROUP = "colgroup", e.DD = "dd", e.DESC = "desc", e.DETAILS = "details", e.DIALOG = "dialog", e.DIR = "dir", e.DIV = "div", e.DL = "dl", e.DT = "dt", e.EM = "em", e.EMBED = "embed", e.FIELDSET = "fieldset", e.FIGCAPTION = "figcaption", e.FIGURE = "figure", e.FONT = "font", e.FOOTER = "footer", e.FOREIGN_OBJECT = "foreignObject", e.FORM = "form", e.FRAME = "frame", e.FRAMESET = "frameset", e.H1 = "h1", e.H2 = "h2", e.H3 = "h3", e.H4 = "h4", e.H5 = "h5", e.H6 = "h6", e.HEAD = "head", e.HEADER = "header", e.HGROUP = "hgroup", e.HR = "hr", e.HTML = "html", e.I = "i", e.IMG = "img", e.IMAGE = "image", e.INPUT = "input", e.IFRAME = "iframe", e.KEYGEN = "keygen", e.LABEL = "label", e.LI = "li", e.LINK = "link", e.LISTING = "listing", e.MAIN = "main", e.MALIGNMARK = "malignmark", e.MARQUEE = "marquee", e.MATH = "math", e.MENU = "menu", e.META = "meta", e.MGLYPH = "mglyph", e.MI = "mi", e.MO = "mo", e.MN = "mn", e.MS = "ms", e.MTEXT = "mtext", e.NAV = "nav", e.NOBR = "nobr", e.NOFRAMES = "noframes", e.NOEMBED = "noembed", e.NOSCRIPT = "noscript", e.OBJECT = "object", e.OL = "ol", e.OPTGROUP = "optgroup", e.OPTION = "option", e.P = "p", e.PARAM = "param", e.PLAINTEXT = "plaintext", e.PRE = "pre", e.RB = "rb", e.RP = "rp", e.RT = "rt", e.RTC = "rtc", e.RUBY = "ruby", e.S = "s", e.SCRIPT = "script", e.SECTION = "section", e.SELECT = "select", e.SOURCE = "source", e.SMALL = "small", e.SPAN = "span", e.STRIKE = "strike", e.STRONG = "strong", e.STYLE = "style", e.SUB = "sub", e.SUMMARY = "summary", e.SUP = "sup", e.TABLE = "table", e.TBODY = "tbody", e.TEMPLATE = "template", e.TEXTAREA = "textarea", e.TFOOT = "tfoot", e.TD = "td", e.TH = "th", e.THEAD = "thead", e.TITLE = "title", e.TR = "tr", e.TRACK = "track", e.TT = "tt", e.U = "u", e.UL = "ul", e.SVG = "svg", e.VAR = "var", e.WBR = "wbr", e.XMP = "xmp";
})(L = L || (L = {}));
var l;
(function(e) {
  e[e.UNKNOWN = 0] = "UNKNOWN", e[e.A = 1] = "A", e[e.ADDRESS = 2] = "ADDRESS", e[e.ANNOTATION_XML = 3] = "ANNOTATION_XML", e[e.APPLET = 4] = "APPLET", e[e.AREA = 5] = "AREA", e[e.ARTICLE = 6] = "ARTICLE", e[e.ASIDE = 7] = "ASIDE", e[e.B = 8] = "B", e[e.BASE = 9] = "BASE", e[e.BASEFONT = 10] = "BASEFONT", e[e.BGSOUND = 11] = "BGSOUND", e[e.BIG = 12] = "BIG", e[e.BLOCKQUOTE = 13] = "BLOCKQUOTE", e[e.BODY = 14] = "BODY", e[e.BR = 15] = "BR", e[e.BUTTON = 16] = "BUTTON", e[e.CAPTION = 17] = "CAPTION", e[e.CENTER = 18] = "CENTER", e[e.CODE = 19] = "CODE", e[e.COL = 20] = "COL", e[e.COLGROUP = 21] = "COLGROUP", e[e.DD = 22] = "DD", e[e.DESC = 23] = "DESC", e[e.DETAILS = 24] = "DETAILS", e[e.DIALOG = 25] = "DIALOG", e[e.DIR = 26] = "DIR", e[e.DIV = 27] = "DIV", e[e.DL = 28] = "DL", e[e.DT = 29] = "DT", e[e.EM = 30] = "EM", e[e.EMBED = 31] = "EMBED", e[e.FIELDSET = 32] = "FIELDSET", e[e.FIGCAPTION = 33] = "FIGCAPTION", e[e.FIGURE = 34] = "FIGURE", e[e.FONT = 35] = "FONT", e[e.FOOTER = 36] = "FOOTER", e[e.FOREIGN_OBJECT = 37] = "FOREIGN_OBJECT", e[e.FORM = 38] = "FORM", e[e.FRAME = 39] = "FRAME", e[e.FRAMESET = 40] = "FRAMESET", e[e.H1 = 41] = "H1", e[e.H2 = 42] = "H2", e[e.H3 = 43] = "H3", e[e.H4 = 44] = "H4", e[e.H5 = 45] = "H5", e[e.H6 = 46] = "H6", e[e.HEAD = 47] = "HEAD", e[e.HEADER = 48] = "HEADER", e[e.HGROUP = 49] = "HGROUP", e[e.HR = 50] = "HR", e[e.HTML = 51] = "HTML", e[e.I = 52] = "I", e[e.IMG = 53] = "IMG", e[e.IMAGE = 54] = "IMAGE", e[e.INPUT = 55] = "INPUT", e[e.IFRAME = 56] = "IFRAME", e[e.KEYGEN = 57] = "KEYGEN", e[e.LABEL = 58] = "LABEL", e[e.LI = 59] = "LI", e[e.LINK = 60] = "LINK", e[e.LISTING = 61] = "LISTING", e[e.MAIN = 62] = "MAIN", e[e.MALIGNMARK = 63] = "MALIGNMARK", e[e.MARQUEE = 64] = "MARQUEE", e[e.MATH = 65] = "MATH", e[e.MENU = 66] = "MENU", e[e.META = 67] = "META", e[e.MGLYPH = 68] = "MGLYPH", e[e.MI = 69] = "MI", e[e.MO = 70] = "MO", e[e.MN = 71] = "MN", e[e.MS = 72] = "MS", e[e.MTEXT = 73] = "MTEXT", e[e.NAV = 74] = "NAV", e[e.NOBR = 75] = "NOBR", e[e.NOFRAMES = 76] = "NOFRAMES", e[e.NOEMBED = 77] = "NOEMBED", e[e.NOSCRIPT = 78] = "NOSCRIPT", e[e.OBJECT = 79] = "OBJECT", e[e.OL = 80] = "OL", e[e.OPTGROUP = 81] = "OPTGROUP", e[e.OPTION = 82] = "OPTION", e[e.P = 83] = "P", e[e.PARAM = 84] = "PARAM", e[e.PLAINTEXT = 85] = "PLAINTEXT", e[e.PRE = 86] = "PRE", e[e.RB = 87] = "RB", e[e.RP = 88] = "RP", e[e.RT = 89] = "RT", e[e.RTC = 90] = "RTC", e[e.RUBY = 91] = "RUBY", e[e.S = 92] = "S", e[e.SCRIPT = 93] = "SCRIPT", e[e.SECTION = 94] = "SECTION", e[e.SELECT = 95] = "SELECT", e[e.SOURCE = 96] = "SOURCE", e[e.SMALL = 97] = "SMALL", e[e.SPAN = 98] = "SPAN", e[e.STRIKE = 99] = "STRIKE", e[e.STRONG = 100] = "STRONG", e[e.STYLE = 101] = "STYLE", e[e.SUB = 102] = "SUB", e[e.SUMMARY = 103] = "SUMMARY", e[e.SUP = 104] = "SUP", e[e.TABLE = 105] = "TABLE", e[e.TBODY = 106] = "TBODY", e[e.TEMPLATE = 107] = "TEMPLATE", e[e.TEXTAREA = 108] = "TEXTAREA", e[e.TFOOT = 109] = "TFOOT", e[e.TD = 110] = "TD", e[e.TH = 111] = "TH", e[e.THEAD = 112] = "THEAD", e[e.TITLE = 113] = "TITLE", e[e.TR = 114] = "TR", e[e.TRACK = 115] = "TRACK", e[e.TT = 116] = "TT", e[e.U = 117] = "U", e[e.UL = 118] = "UL", e[e.SVG = 119] = "SVG", e[e.VAR = 120] = "VAR", e[e.WBR = 121] = "WBR", e[e.XMP = 122] = "XMP";
})(l = l || (l = {}));
const RU = /* @__PURE__ */ new Map([
  [L.A, l.A],
  [L.ADDRESS, l.ADDRESS],
  [L.ANNOTATION_XML, l.ANNOTATION_XML],
  [L.APPLET, l.APPLET],
  [L.AREA, l.AREA],
  [L.ARTICLE, l.ARTICLE],
  [L.ASIDE, l.ASIDE],
  [L.B, l.B],
  [L.BASE, l.BASE],
  [L.BASEFONT, l.BASEFONT],
  [L.BGSOUND, l.BGSOUND],
  [L.BIG, l.BIG],
  [L.BLOCKQUOTE, l.BLOCKQUOTE],
  [L.BODY, l.BODY],
  [L.BR, l.BR],
  [L.BUTTON, l.BUTTON],
  [L.CAPTION, l.CAPTION],
  [L.CENTER, l.CENTER],
  [L.CODE, l.CODE],
  [L.COL, l.COL],
  [L.COLGROUP, l.COLGROUP],
  [L.DD, l.DD],
  [L.DESC, l.DESC],
  [L.DETAILS, l.DETAILS],
  [L.DIALOG, l.DIALOG],
  [L.DIR, l.DIR],
  [L.DIV, l.DIV],
  [L.DL, l.DL],
  [L.DT, l.DT],
  [L.EM, l.EM],
  [L.EMBED, l.EMBED],
  [L.FIELDSET, l.FIELDSET],
  [L.FIGCAPTION, l.FIGCAPTION],
  [L.FIGURE, l.FIGURE],
  [L.FONT, l.FONT],
  [L.FOOTER, l.FOOTER],
  [L.FOREIGN_OBJECT, l.FOREIGN_OBJECT],
  [L.FORM, l.FORM],
  [L.FRAME, l.FRAME],
  [L.FRAMESET, l.FRAMESET],
  [L.H1, l.H1],
  [L.H2, l.H2],
  [L.H3, l.H3],
  [L.H4, l.H4],
  [L.H5, l.H5],
  [L.H6, l.H6],
  [L.HEAD, l.HEAD],
  [L.HEADER, l.HEADER],
  [L.HGROUP, l.HGROUP],
  [L.HR, l.HR],
  [L.HTML, l.HTML],
  [L.I, l.I],
  [L.IMG, l.IMG],
  [L.IMAGE, l.IMAGE],
  [L.INPUT, l.INPUT],
  [L.IFRAME, l.IFRAME],
  [L.KEYGEN, l.KEYGEN],
  [L.LABEL, l.LABEL],
  [L.LI, l.LI],
  [L.LINK, l.LINK],
  [L.LISTING, l.LISTING],
  [L.MAIN, l.MAIN],
  [L.MALIGNMARK, l.MALIGNMARK],
  [L.MARQUEE, l.MARQUEE],
  [L.MATH, l.MATH],
  [L.MENU, l.MENU],
  [L.META, l.META],
  [L.MGLYPH, l.MGLYPH],
  [L.MI, l.MI],
  [L.MO, l.MO],
  [L.MN, l.MN],
  [L.MS, l.MS],
  [L.MTEXT, l.MTEXT],
  [L.NAV, l.NAV],
  [L.NOBR, l.NOBR],
  [L.NOFRAMES, l.NOFRAMES],
  [L.NOEMBED, l.NOEMBED],
  [L.NOSCRIPT, l.NOSCRIPT],
  [L.OBJECT, l.OBJECT],
  [L.OL, l.OL],
  [L.OPTGROUP, l.OPTGROUP],
  [L.OPTION, l.OPTION],
  [L.P, l.P],
  [L.PARAM, l.PARAM],
  [L.PLAINTEXT, l.PLAINTEXT],
  [L.PRE, l.PRE],
  [L.RB, l.RB],
  [L.RP, l.RP],
  [L.RT, l.RT],
  [L.RTC, l.RTC],
  [L.RUBY, l.RUBY],
  [L.S, l.S],
  [L.SCRIPT, l.SCRIPT],
  [L.SECTION, l.SECTION],
  [L.SELECT, l.SELECT],
  [L.SOURCE, l.SOURCE],
  [L.SMALL, l.SMALL],
  [L.SPAN, l.SPAN],
  [L.STRIKE, l.STRIKE],
  [L.STRONG, l.STRONG],
  [L.STYLE, l.STYLE],
  [L.SUB, l.SUB],
  [L.SUMMARY, l.SUMMARY],
  [L.SUP, l.SUP],
  [L.TABLE, l.TABLE],
  [L.TBODY, l.TBODY],
  [L.TEMPLATE, l.TEMPLATE],
  [L.TEXTAREA, l.TEXTAREA],
  [L.TFOOT, l.TFOOT],
  [L.TD, l.TD],
  [L.TH, l.TH],
  [L.THEAD, l.THEAD],
  [L.TITLE, l.TITLE],
  [L.TR, l.TR],
  [L.TRACK, l.TRACK],
  [L.TT, l.TT],
  [L.U, l.U],
  [L.UL, l.UL],
  [L.SVG, l.SVG],
  [L.VAR, l.VAR],
  [L.WBR, l.WBR],
  [L.XMP, l.XMP]
]);
function dr(e) {
  var t;
  return (t = RU.get(e)) !== null && t !== void 0 ? t : l.UNKNOWN;
}
const G = l, FU = {
  [Y.HTML]: /* @__PURE__ */ new Set([
    G.ADDRESS,
    G.APPLET,
    G.AREA,
    G.ARTICLE,
    G.ASIDE,
    G.BASE,
    G.BASEFONT,
    G.BGSOUND,
    G.BLOCKQUOTE,
    G.BODY,
    G.BR,
    G.BUTTON,
    G.CAPTION,
    G.CENTER,
    G.COL,
    G.COLGROUP,
    G.DD,
    G.DETAILS,
    G.DIR,
    G.DIV,
    G.DL,
    G.DT,
    G.EMBED,
    G.FIELDSET,
    G.FIGCAPTION,
    G.FIGURE,
    G.FOOTER,
    G.FORM,
    G.FRAME,
    G.FRAMESET,
    G.H1,
    G.H2,
    G.H3,
    G.H4,
    G.H5,
    G.H6,
    G.HEAD,
    G.HEADER,
    G.HGROUP,
    G.HR,
    G.HTML,
    G.IFRAME,
    G.IMG,
    G.INPUT,
    G.LI,
    G.LINK,
    G.LISTING,
    G.MAIN,
    G.MARQUEE,
    G.MENU,
    G.META,
    G.NAV,
    G.NOEMBED,
    G.NOFRAMES,
    G.NOSCRIPT,
    G.OBJECT,
    G.OL,
    G.P,
    G.PARAM,
    G.PLAINTEXT,
    G.PRE,
    G.SCRIPT,
    G.SECTION,
    G.SELECT,
    G.SOURCE,
    G.STYLE,
    G.SUMMARY,
    G.TABLE,
    G.TBODY,
    G.TD,
    G.TEMPLATE,
    G.TEXTAREA,
    G.TFOOT,
    G.TH,
    G.THEAD,
    G.TITLE,
    G.TR,
    G.TRACK,
    G.UL,
    G.WBR,
    G.XMP
  ]),
  [Y.MATHML]: /* @__PURE__ */ new Set([G.MI, G.MO, G.MN, G.MS, G.MTEXT, G.ANNOTATION_XML]),
  [Y.SVG]: /* @__PURE__ */ new Set([G.TITLE, G.FOREIGN_OBJECT, G.DESC]),
  [Y.XLINK]: /* @__PURE__ */ new Set(),
  [Y.XML]: /* @__PURE__ */ new Set(),
  [Y.XMLNS]: /* @__PURE__ */ new Set()
};
function G0(e) {
  return e === G.H1 || e === G.H2 || e === G.H3 || e === G.H4 || e === G.H5 || e === G.H6;
}
L.STYLE, L.SCRIPT, L.XMP, L.IFRAME, L.NOEMBED, L.NOFRAMES, L.PLAINTEXT;
const OU = /* @__PURE__ */ new Map([
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var T;
(function(e) {
  e[e.DATA = 0] = "DATA", e[e.RCDATA = 1] = "RCDATA", e[e.RAWTEXT = 2] = "RAWTEXT", e[e.SCRIPT_DATA = 3] = "SCRIPT_DATA", e[e.PLAINTEXT = 4] = "PLAINTEXT", e[e.TAG_OPEN = 5] = "TAG_OPEN", e[e.END_TAG_OPEN = 6] = "END_TAG_OPEN", e[e.TAG_NAME = 7] = "TAG_NAME", e[e.RCDATA_LESS_THAN_SIGN = 8] = "RCDATA_LESS_THAN_SIGN", e[e.RCDATA_END_TAG_OPEN = 9] = "RCDATA_END_TAG_OPEN", e[e.RCDATA_END_TAG_NAME = 10] = "RCDATA_END_TAG_NAME", e[e.RAWTEXT_LESS_THAN_SIGN = 11] = "RAWTEXT_LESS_THAN_SIGN", e[e.RAWTEXT_END_TAG_OPEN = 12] = "RAWTEXT_END_TAG_OPEN", e[e.RAWTEXT_END_TAG_NAME = 13] = "RAWTEXT_END_TAG_NAME", e[e.SCRIPT_DATA_LESS_THAN_SIGN = 14] = "SCRIPT_DATA_LESS_THAN_SIGN", e[e.SCRIPT_DATA_END_TAG_OPEN = 15] = "SCRIPT_DATA_END_TAG_OPEN", e[e.SCRIPT_DATA_END_TAG_NAME = 16] = "SCRIPT_DATA_END_TAG_NAME", e[e.SCRIPT_DATA_ESCAPE_START = 17] = "SCRIPT_DATA_ESCAPE_START", e[e.SCRIPT_DATA_ESCAPE_START_DASH = 18] = "SCRIPT_DATA_ESCAPE_START_DASH", e[e.SCRIPT_DATA_ESCAPED = 19] = "SCRIPT_DATA_ESCAPED", e[e.SCRIPT_DATA_ESCAPED_DASH = 20] = "SCRIPT_DATA_ESCAPED_DASH", e[e.SCRIPT_DATA_ESCAPED_DASH_DASH = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH", e[e.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN", e[e.SCRIPT_DATA_ESCAPED_END_TAG_OPEN = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN", e[e.SCRIPT_DATA_ESCAPED_END_TAG_NAME = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME", e[e.SCRIPT_DATA_DOUBLE_ESCAPE_START = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START", e[e.SCRIPT_DATA_DOUBLE_ESCAPED = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN", e[e.SCRIPT_DATA_DOUBLE_ESCAPE_END = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END", e[e.BEFORE_ATTRIBUTE_NAME = 31] = "BEFORE_ATTRIBUTE_NAME", e[e.ATTRIBUTE_NAME = 32] = "ATTRIBUTE_NAME", e[e.AFTER_ATTRIBUTE_NAME = 33] = "AFTER_ATTRIBUTE_NAME", e[e.BEFORE_ATTRIBUTE_VALUE = 34] = "BEFORE_ATTRIBUTE_VALUE", e[e.ATTRIBUTE_VALUE_DOUBLE_QUOTED = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED", e[e.ATTRIBUTE_VALUE_SINGLE_QUOTED = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED", e[e.ATTRIBUTE_VALUE_UNQUOTED = 37] = "ATTRIBUTE_VALUE_UNQUOTED", e[e.AFTER_ATTRIBUTE_VALUE_QUOTED = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED", e[e.SELF_CLOSING_START_TAG = 39] = "SELF_CLOSING_START_TAG", e[e.BOGUS_COMMENT = 40] = "BOGUS_COMMENT", e[e.MARKUP_DECLARATION_OPEN = 41] = "MARKUP_DECLARATION_OPEN", e[e.COMMENT_START = 42] = "COMMENT_START", e[e.COMMENT_START_DASH = 43] = "COMMENT_START_DASH", e[e.COMMENT = 44] = "COMMENT", e[e.COMMENT_LESS_THAN_SIGN = 45] = "COMMENT_LESS_THAN_SIGN", e[e.COMMENT_LESS_THAN_SIGN_BANG = 46] = "COMMENT_LESS_THAN_SIGN_BANG", e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH", e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH", e[e.COMMENT_END_DASH = 49] = "COMMENT_END_DASH", e[e.COMMENT_END = 50] = "COMMENT_END", e[e.COMMENT_END_BANG = 51] = "COMMENT_END_BANG", e[e.DOCTYPE = 52] = "DOCTYPE", e[e.BEFORE_DOCTYPE_NAME = 53] = "BEFORE_DOCTYPE_NAME", e[e.DOCTYPE_NAME = 54] = "DOCTYPE_NAME", e[e.AFTER_DOCTYPE_NAME = 55] = "AFTER_DOCTYPE_NAME", e[e.AFTER_DOCTYPE_PUBLIC_KEYWORD = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD", e[e.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER", e[e.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED", e[e.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED", e[e.AFTER_DOCTYPE_PUBLIC_IDENTIFIER = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER", e[e.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS", e[e.AFTER_DOCTYPE_SYSTEM_KEYWORD = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD", e[e.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER", e[e.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED", e[e.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED", e[e.AFTER_DOCTYPE_SYSTEM_IDENTIFIER = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER", e[e.BOGUS_DOCTYPE = 67] = "BOGUS_DOCTYPE", e[e.CDATA_SECTION = 68] = "CDATA_SECTION", e[e.CDATA_SECTION_BRACKET = 69] = "CDATA_SECTION_BRACKET", e[e.CDATA_SECTION_END = 70] = "CDATA_SECTION_END", e[e.CHARACTER_REFERENCE = 71] = "CHARACTER_REFERENCE", e[e.NAMED_CHARACTER_REFERENCE = 72] = "NAMED_CHARACTER_REFERENCE", e[e.AMBIGUOUS_AMPERSAND = 73] = "AMBIGUOUS_AMPERSAND", e[e.NUMERIC_CHARACTER_REFERENCE = 74] = "NUMERIC_CHARACTER_REFERENCE", e[e.HEXADEMICAL_CHARACTER_REFERENCE_START = 75] = "HEXADEMICAL_CHARACTER_REFERENCE_START", e[e.HEXADEMICAL_CHARACTER_REFERENCE = 76] = "HEXADEMICAL_CHARACTER_REFERENCE", e[e.DECIMAL_CHARACTER_REFERENCE = 77] = "DECIMAL_CHARACTER_REFERENCE", e[e.NUMERIC_CHARACTER_REFERENCE_END = 78] = "NUMERIC_CHARACTER_REFERENCE_END";
})(T || (T = {}));
const Xe = {
  DATA: T.DATA,
  RCDATA: T.RCDATA,
  RAWTEXT: T.RAWTEXT,
  SCRIPT_DATA: T.SCRIPT_DATA,
  PLAINTEXT: T.PLAINTEXT,
  CDATA_SECTION: T.CDATA_SECTION
};
function Pr(e) {
  return e >= E.DIGIT_0 && e <= E.DIGIT_9;
}
function Fr(e) {
  return e >= E.LATIN_CAPITAL_A && e <= E.LATIN_CAPITAL_Z;
}
function LU(e) {
  return e >= E.LATIN_SMALL_A && e <= E.LATIN_SMALL_Z;
}
function va(e) {
  return LU(e) || Fr(e);
}
function gi(e) {
  return va(e) || Pr(e);
}
function W0(e) {
  return e >= E.LATIN_CAPITAL_A && e <= E.LATIN_CAPITAL_F;
}
function $0(e) {
  return e >= E.LATIN_SMALL_A && e <= E.LATIN_SMALL_F;
}
function MU(e) {
  return Pr(e) || W0(e) || $0(e);
}
function bn(e) {
  return e + 32;
}
function X0(e) {
  return e === E.SPACE || e === E.LINE_FEED || e === E.TABULATION || e === E.FORM_FEED;
}
function BU(e) {
  return e === E.EQUALS_SIGN || gi(e);
}
function nl(e) {
  return X0(e) || e === E.SOLIDUS || e === E.GREATER_THAN_SIGN;
}
class PU {
  constructor(t, a) {
    this.options = t, this.handler = a, this.paused = !1, this.inLoop = !1, this.inForeignNode = !1, this.lastStartTagName = "", this.active = !1, this.state = T.DATA, this.returnState = T.DATA, this.charRefCode = -1, this.consumedAfterSnapshot = -1, this.currentCharacterToken = null, this.currentToken = null, this.currentAttr = { name: "", value: "" }, this.preprocessor = new TU(a), this.currentLocation = this.getCurrentLocation(-1);
  }
  //Errors
  _err(t) {
    var a, r;
    (r = (a = this.handler).onParseError) === null || r === void 0 || r.call(a, this.preprocessor.getError(t));
  }
  // NOTE: `offset` may never run across line boundaries.
  getCurrentLocation(t) {
    return this.options.sourceCodeLocationInfo ? {
      startLine: this.preprocessor.line,
      startCol: this.preprocessor.col - t,
      startOffset: this.preprocessor.offset - t,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    } : null;
  }
  _runParsingLoop() {
    if (!this.inLoop) {
      for (this.inLoop = !0; this.active && !this.paused; ) {
        this.consumedAfterSnapshot = 0;
        const t = this._consume();
        this._ensureHibernation() || this._callState(t);
      }
      this.inLoop = !1;
    }
  }
  //API
  pause() {
    this.paused = !0;
  }
  resume(t) {
    if (!this.paused)
      throw new Error("Parser was already resumed");
    this.paused = !1, !this.inLoop && (this._runParsingLoop(), this.paused || t == null || t());
  }
  write(t, a, r) {
    this.active = !0, this.preprocessor.write(t, a), this._runParsingLoop(), this.paused || r == null || r();
  }
  insertHtmlAtCurrentPos(t) {
    this.active = !0, this.preprocessor.insertHtmlAtCurrentPos(t), this._runParsingLoop();
  }
  //Hibernation
  _ensureHibernation() {
    return this.preprocessor.endOfChunkHit ? (this._unconsume(this.consumedAfterSnapshot), this.active = !1, !0) : !1;
  }
  //Consumption
  _consume() {
    return this.consumedAfterSnapshot++, this.preprocessor.advance();
  }
  _unconsume(t) {
    this.consumedAfterSnapshot -= t, this.preprocessor.retreat(t);
  }
  _reconsumeInState(t, a) {
    this.state = t, this._callState(a);
  }
  _advanceBy(t) {
    this.consumedAfterSnapshot += t;
    for (let a = 0; a < t; a++)
      this.preprocessor.advance();
  }
  _consumeSequenceIfMatch(t, a) {
    return this.preprocessor.startsWith(t, a) ? (this._advanceBy(t.length - 1), !0) : !1;
  }
  //Token creation
  _createStartTagToken() {
    this.currentToken = {
      type: ve.START_TAG,
      tagName: "",
      tagID: l.UNKNOWN,
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: [],
      location: this.getCurrentLocation(1)
    };
  }
  _createEndTagToken() {
    this.currentToken = {
      type: ve.END_TAG,
      tagName: "",
      tagID: l.UNKNOWN,
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: [],
      location: this.getCurrentLocation(2)
    };
  }
  _createCommentToken(t) {
    this.currentToken = {
      type: ve.COMMENT,
      data: "",
      location: this.getCurrentLocation(t)
    };
  }
  _createDoctypeToken(t) {
    this.currentToken = {
      type: ve.DOCTYPE,
      name: t,
      forceQuirks: !1,
      publicId: null,
      systemId: null,
      location: this.currentLocation
    };
  }
  _createCharacterToken(t, a) {
    this.currentCharacterToken = {
      type: t,
      chars: a,
      location: this.currentLocation
    };
  }
  //Tag attributes
  _createAttr(t) {
    this.currentAttr = {
      name: t,
      value: ""
    }, this.currentLocation = this.getCurrentLocation(0);
  }
  _leaveAttrName() {
    var t, a;
    const r = this.currentToken;
    if (q0(r, this.currentAttr.name) === null) {
      if (r.attrs.push(this.currentAttr), r.location && this.currentLocation) {
        const n = (t = (a = r.location).attrs) !== null && t !== void 0 ? t : a.attrs = /* @__PURE__ */ Object.create(null);
        n[this.currentAttr.name] = this.currentLocation, this._leaveAttrValue();
      }
    } else
      this._err(j.duplicateAttribute);
  }
  _leaveAttrValue() {
    this.currentLocation && (this.currentLocation.endLine = this.preprocessor.line, this.currentLocation.endCol = this.preprocessor.col, this.currentLocation.endOffset = this.preprocessor.offset);
  }
  //Token emission
  prepareToken(t) {
    this._emitCurrentCharacterToken(t.location), this.currentToken = null, t.location && (t.location.endLine = this.preprocessor.line, t.location.endCol = this.preprocessor.col + 1, t.location.endOffset = this.preprocessor.offset + 1), this.currentLocation = this.getCurrentLocation(-1);
  }
  emitCurrentTagToken() {
    const t = this.currentToken;
    this.prepareToken(t), t.tagID = dr(t.tagName), t.type === ve.START_TAG ? (this.lastStartTagName = t.tagName, this.handler.onStartTag(t)) : (t.attrs.length > 0 && this._err(j.endTagWithAttributes), t.selfClosing && this._err(j.endTagWithTrailingSolidus), this.handler.onEndTag(t)), this.preprocessor.dropParsedChunk();
  }
  emitCurrentComment(t) {
    this.prepareToken(t), this.handler.onComment(t), this.preprocessor.dropParsedChunk();
  }
  emitCurrentDoctype(t) {
    this.prepareToken(t), this.handler.onDoctype(t), this.preprocessor.dropParsedChunk();
  }
  _emitCurrentCharacterToken(t) {
    if (this.currentCharacterToken) {
      switch (t && this.currentCharacterToken.location && (this.currentCharacterToken.location.endLine = t.startLine, this.currentCharacterToken.location.endCol = t.startCol, this.currentCharacterToken.location.endOffset = t.startOffset), this.currentCharacterToken.type) {
        case ve.CHARACTER: {
          this.handler.onCharacter(this.currentCharacterToken);
          break;
        }
        case ve.NULL_CHARACTER: {
          this.handler.onNullCharacter(this.currentCharacterToken);
          break;
        }
        case ve.WHITESPACE_CHARACTER: {
          this.handler.onWhitespaceCharacter(this.currentCharacterToken);
          break;
        }
      }
      this.currentCharacterToken = null;
    }
  }
  _emitEOFToken() {
    const t = this.getCurrentLocation(0);
    t && (t.endLine = t.startLine, t.endCol = t.startCol, t.endOffset = t.startOffset), this._emitCurrentCharacterToken(t), this.handler.onEof({ type: ve.EOF, location: t }), this.active = !1;
  }
  //Characters emission
  //OPTIMIZATION: specification uses only one type of character tokens (one token per character).
  //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
  //If we have a sequence of characters that belong to the same group, the parser can process it
  //as a single solid character token.
  //So, there are 3 types of character tokens in parse5:
  //1)TokenType.NULL_CHARACTER - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
  //2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
  //3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
  _appendCharToCurrentCharacterToken(t, a) {
    if (this.currentCharacterToken)
      if (this.currentCharacterToken.type !== t)
        this.currentLocation = this.getCurrentLocation(0), this._emitCurrentCharacterToken(this.currentLocation), this.preprocessor.dropParsedChunk();
      else {
        this.currentCharacterToken.chars += a;
        return;
      }
    this._createCharacterToken(t, a);
  }
  _emitCodePoint(t) {
    const a = X0(t) ? ve.WHITESPACE_CHARACTER : t === E.NULL ? ve.NULL_CHARACTER : ve.CHARACTER;
    this._appendCharToCurrentCharacterToken(a, String.fromCodePoint(t));
  }
  //NOTE: used when we emit characters explicitly.
  //This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.
  _emitChars(t) {
    this._appendCharToCurrentCharacterToken(ve.CHARACTER, t);
  }
  // Character reference helpers
  _matchNamedCharacterReference(t) {
    let a = null, r = 0, n = !1;
    for (let s = 0, i = Ta[0]; s >= 0 && (s = V0(Ta, i, s + 1, t), !(s < 0)); t = this._consume()) {
      r += 1, i = Ta[s];
      const o = i & ea.VALUE_LENGTH;
      if (o) {
        const c = (o >> 14) - 1;
        if (t !== E.SEMICOLON && this._isCharacterReferenceInAttribute() && BU(this.preprocessor.peek(1)) ? (a = [E.AMPERSAND], s += c) : (a = c === 0 ? [Ta[s] & ~ea.VALUE_LENGTH] : c === 1 ? [Ta[++s]] : [Ta[++s], Ta[++s]], r = 0, n = t !== E.SEMICOLON), c === 0) {
          this._consume();
          break;
        }
      }
    }
    return this._unconsume(r), n && !this.preprocessor.endOfChunkHit && this._err(j.missingSemicolonAfterCharacterReference), this._unconsume(1), a;
  }
  _isCharacterReferenceInAttribute() {
    return this.returnState === T.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === T.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === T.ATTRIBUTE_VALUE_UNQUOTED;
  }
  _flushCodePointConsumedAsCharacterReference(t) {
    this._isCharacterReferenceInAttribute() ? this.currentAttr.value += String.fromCodePoint(t) : this._emitCodePoint(t);
  }
  // Calling states this way turns out to be much faster than any other approach.
  _callState(t) {
    switch (this.state) {
      case T.DATA: {
        this._stateData(t);
        break;
      }
      case T.RCDATA: {
        this._stateRcdata(t);
        break;
      }
      case T.RAWTEXT: {
        this._stateRawtext(t);
        break;
      }
      case T.SCRIPT_DATA: {
        this._stateScriptData(t);
        break;
      }
      case T.PLAINTEXT: {
        this._statePlaintext(t);
        break;
      }
      case T.TAG_OPEN: {
        this._stateTagOpen(t);
        break;
      }
      case T.END_TAG_OPEN: {
        this._stateEndTagOpen(t);
        break;
      }
      case T.TAG_NAME: {
        this._stateTagName(t);
        break;
      }
      case T.RCDATA_LESS_THAN_SIGN: {
        this._stateRcdataLessThanSign(t);
        break;
      }
      case T.RCDATA_END_TAG_OPEN: {
        this._stateRcdataEndTagOpen(t);
        break;
      }
      case T.RCDATA_END_TAG_NAME: {
        this._stateRcdataEndTagName(t);
        break;
      }
      case T.RAWTEXT_LESS_THAN_SIGN: {
        this._stateRawtextLessThanSign(t);
        break;
      }
      case T.RAWTEXT_END_TAG_OPEN: {
        this._stateRawtextEndTagOpen(t);
        break;
      }
      case T.RAWTEXT_END_TAG_NAME: {
        this._stateRawtextEndTagName(t);
        break;
      }
      case T.SCRIPT_DATA_LESS_THAN_SIGN: {
        this._stateScriptDataLessThanSign(t);
        break;
      }
      case T.SCRIPT_DATA_END_TAG_OPEN: {
        this._stateScriptDataEndTagOpen(t);
        break;
      }
      case T.SCRIPT_DATA_END_TAG_NAME: {
        this._stateScriptDataEndTagName(t);
        break;
      }
      case T.SCRIPT_DATA_ESCAPE_START: {
        this._stateScriptDataEscapeStart(t);
        break;
      }
      case T.SCRIPT_DATA_ESCAPE_START_DASH: {
        this._stateScriptDataEscapeStartDash(t);
        break;
      }
      case T.SCRIPT_DATA_ESCAPED: {
        this._stateScriptDataEscaped(t);
        break;
      }
      case T.SCRIPT_DATA_ESCAPED_DASH: {
        this._stateScriptDataEscapedDash(t);
        break;
      }
      case T.SCRIPT_DATA_ESCAPED_DASH_DASH: {
        this._stateScriptDataEscapedDashDash(t);
        break;
      }
      case T.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataEscapedLessThanSign(t);
        break;
      }
      case T.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
        this._stateScriptDataEscapedEndTagOpen(t);
        break;
      }
      case T.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
        this._stateScriptDataEscapedEndTagName(t);
        break;
      }
      case T.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
        this._stateScriptDataDoubleEscapeStart(t);
        break;
      }
      case T.SCRIPT_DATA_DOUBLE_ESCAPED: {
        this._stateScriptDataDoubleEscaped(t);
        break;
      }
      case T.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
        this._stateScriptDataDoubleEscapedDash(t);
        break;
      }
      case T.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
        this._stateScriptDataDoubleEscapedDashDash(t);
        break;
      }
      case T.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataDoubleEscapedLessThanSign(t);
        break;
      }
      case T.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
        this._stateScriptDataDoubleEscapeEnd(t);
        break;
      }
      case T.BEFORE_ATTRIBUTE_NAME: {
        this._stateBeforeAttributeName(t);
        break;
      }
      case T.ATTRIBUTE_NAME: {
        this._stateAttributeName(t);
        break;
      }
      case T.AFTER_ATTRIBUTE_NAME: {
        this._stateAfterAttributeName(t);
        break;
      }
      case T.BEFORE_ATTRIBUTE_VALUE: {
        this._stateBeforeAttributeValue(t);
        break;
      }
      case T.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
        this._stateAttributeValueDoubleQuoted(t);
        break;
      }
      case T.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
        this._stateAttributeValueSingleQuoted(t);
        break;
      }
      case T.ATTRIBUTE_VALUE_UNQUOTED: {
        this._stateAttributeValueUnquoted(t);
        break;
      }
      case T.AFTER_ATTRIBUTE_VALUE_QUOTED: {
        this._stateAfterAttributeValueQuoted(t);
        break;
      }
      case T.SELF_CLOSING_START_TAG: {
        this._stateSelfClosingStartTag(t);
        break;
      }
      case T.BOGUS_COMMENT: {
        this._stateBogusComment(t);
        break;
      }
      case T.MARKUP_DECLARATION_OPEN: {
        this._stateMarkupDeclarationOpen(t);
        break;
      }
      case T.COMMENT_START: {
        this._stateCommentStart(t);
        break;
      }
      case T.COMMENT_START_DASH: {
        this._stateCommentStartDash(t);
        break;
      }
      case T.COMMENT: {
        this._stateComment(t);
        break;
      }
      case T.COMMENT_LESS_THAN_SIGN: {
        this._stateCommentLessThanSign(t);
        break;
      }
      case T.COMMENT_LESS_THAN_SIGN_BANG: {
        this._stateCommentLessThanSignBang(t);
        break;
      }
      case T.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
        this._stateCommentLessThanSignBangDash(t);
        break;
      }
      case T.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
        this._stateCommentLessThanSignBangDashDash(t);
        break;
      }
      case T.COMMENT_END_DASH: {
        this._stateCommentEndDash(t);
        break;
      }
      case T.COMMENT_END: {
        this._stateCommentEnd(t);
        break;
      }
      case T.COMMENT_END_BANG: {
        this._stateCommentEndBang(t);
        break;
      }
      case T.DOCTYPE: {
        this._stateDoctype(t);
        break;
      }
      case T.BEFORE_DOCTYPE_NAME: {
        this._stateBeforeDoctypeName(t);
        break;
      }
      case T.DOCTYPE_NAME: {
        this._stateDoctypeName(t);
        break;
      }
      case T.AFTER_DOCTYPE_NAME: {
        this._stateAfterDoctypeName(t);
        break;
      }
      case T.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
        this._stateAfterDoctypePublicKeyword(t);
        break;
      }
      case T.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateBeforeDoctypePublicIdentifier(t);
        break;
      }
      case T.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypePublicIdentifierDoubleQuoted(t);
        break;
      }
      case T.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypePublicIdentifierSingleQuoted(t);
        break;
      }
      case T.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateAfterDoctypePublicIdentifier(t);
        break;
      }
      case T.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
        this._stateBetweenDoctypePublicAndSystemIdentifiers(t);
        break;
      }
      case T.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
        this._stateAfterDoctypeSystemKeyword(t);
        break;
      }
      case T.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateBeforeDoctypeSystemIdentifier(t);
        break;
      }
      case T.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypeSystemIdentifierDoubleQuoted(t);
        break;
      }
      case T.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypeSystemIdentifierSingleQuoted(t);
        break;
      }
      case T.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateAfterDoctypeSystemIdentifier(t);
        break;
      }
      case T.BOGUS_DOCTYPE: {
        this._stateBogusDoctype(t);
        break;
      }
      case T.CDATA_SECTION: {
        this._stateCdataSection(t);
        break;
      }
      case T.CDATA_SECTION_BRACKET: {
        this._stateCdataSectionBracket(t);
        break;
      }
      case T.CDATA_SECTION_END: {
        this._stateCdataSectionEnd(t);
        break;
      }
      case T.CHARACTER_REFERENCE: {
        this._stateCharacterReference(t);
        break;
      }
      case T.NAMED_CHARACTER_REFERENCE: {
        this._stateNamedCharacterReference(t);
        break;
      }
      case T.AMBIGUOUS_AMPERSAND: {
        this._stateAmbiguousAmpersand(t);
        break;
      }
      case T.NUMERIC_CHARACTER_REFERENCE: {
        this._stateNumericCharacterReference(t);
        break;
      }
      case T.HEXADEMICAL_CHARACTER_REFERENCE_START: {
        this._stateHexademicalCharacterReferenceStart(t);
        break;
      }
      case T.HEXADEMICAL_CHARACTER_REFERENCE: {
        this._stateHexademicalCharacterReference(t);
        break;
      }
      case T.DECIMAL_CHARACTER_REFERENCE: {
        this._stateDecimalCharacterReference(t);
        break;
      }
      case T.NUMERIC_CHARACTER_REFERENCE_END: {
        this._stateNumericCharacterReferenceEnd(t);
        break;
      }
      default:
        throw new Error("Unknown state");
    }
  }
  // State machine
  // Data state
  //------------------------------------------------------------------
  _stateData(t) {
    switch (t) {
      case E.LESS_THAN_SIGN: {
        this.state = T.TAG_OPEN;
        break;
      }
      case E.AMPERSAND: {
        this.returnState = T.DATA, this.state = T.CHARACTER_REFERENCE;
        break;
      }
      case E.NULL: {
        this._err(j.unexpectedNullCharacter), this._emitCodePoint(t);
        break;
      }
      case E.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  //  RCDATA state
  //------------------------------------------------------------------
  _stateRcdata(t) {
    switch (t) {
      case E.AMPERSAND: {
        this.returnState = T.RCDATA, this.state = T.CHARACTER_REFERENCE;
        break;
      }
      case E.LESS_THAN_SIGN: {
        this.state = T.RCDATA_LESS_THAN_SIGN;
        break;
      }
      case E.NULL: {
        this._err(j.unexpectedNullCharacter), this._emitChars(qe);
        break;
      }
      case E.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // RAWTEXT state
  //------------------------------------------------------------------
  _stateRawtext(t) {
    switch (t) {
      case E.LESS_THAN_SIGN: {
        this.state = T.RAWTEXT_LESS_THAN_SIGN;
        break;
      }
      case E.NULL: {
        this._err(j.unexpectedNullCharacter), this._emitChars(qe);
        break;
      }
      case E.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data state
  //------------------------------------------------------------------
  _stateScriptData(t) {
    switch (t) {
      case E.LESS_THAN_SIGN: {
        this.state = T.SCRIPT_DATA_LESS_THAN_SIGN;
        break;
      }
      case E.NULL: {
        this._err(j.unexpectedNullCharacter), this._emitChars(qe);
        break;
      }
      case E.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // PLAINTEXT state
  //------------------------------------------------------------------
  _statePlaintext(t) {
    switch (t) {
      case E.NULL: {
        this._err(j.unexpectedNullCharacter), this._emitChars(qe);
        break;
      }
      case E.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Tag open state
  //------------------------------------------------------------------
  _stateTagOpen(t) {
    if (va(t))
      this._createStartTagToken(), this.state = T.TAG_NAME, this._stateTagName(t);
    else
      switch (t) {
        case E.EXCLAMATION_MARK: {
          this.state = T.MARKUP_DECLARATION_OPEN;
          break;
        }
        case E.SOLIDUS: {
          this.state = T.END_TAG_OPEN;
          break;
        }
        case E.QUESTION_MARK: {
          this._err(j.unexpectedQuestionMarkInsteadOfTagName), this._createCommentToken(1), this.state = T.BOGUS_COMMENT, this._stateBogusComment(t);
          break;
        }
        case E.EOF: {
          this._err(j.eofBeforeTagName), this._emitChars("<"), this._emitEOFToken();
          break;
        }
        default:
          this._err(j.invalidFirstCharacterOfTagName), this._emitChars("<"), this.state = T.DATA, this._stateData(t);
      }
  }
  // End tag open state
  //------------------------------------------------------------------
  _stateEndTagOpen(t) {
    if (va(t))
      this._createEndTagToken(), this.state = T.TAG_NAME, this._stateTagName(t);
    else
      switch (t) {
        case E.GREATER_THAN_SIGN: {
          this._err(j.missingEndTagName), this.state = T.DATA;
          break;
        }
        case E.EOF: {
          this._err(j.eofBeforeTagName), this._emitChars("</"), this._emitEOFToken();
          break;
        }
        default:
          this._err(j.invalidFirstCharacterOfTagName), this._createCommentToken(2), this.state = T.BOGUS_COMMENT, this._stateBogusComment(t);
      }
  }
  // Tag name state
  //------------------------------------------------------------------
  _stateTagName(t) {
    const a = this.currentToken;
    switch (t) {
      case E.SPACE:
      case E.LINE_FEED:
      case E.TABULATION:
      case E.FORM_FEED: {
        this.state = T.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case E.SOLIDUS: {
        this.state = T.SELF_CLOSING_START_TAG;
        break;
      }
      case E.GREATER_THAN_SIGN: {
        this.state = T.DATA, this.emitCurrentTagToken();
        break;
      }
      case E.NULL: {
        this._err(j.unexpectedNullCharacter), a.tagName += qe;
        break;
      }
      case E.EOF: {
        this._err(j.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        a.tagName += String.fromCodePoint(Fr(t) ? bn(t) : t);
    }
  }
  // RCDATA less-than sign state
  //------------------------------------------------------------------
  _stateRcdataLessThanSign(t) {
    t === E.SOLIDUS ? this.state = T.RCDATA_END_TAG_OPEN : (this._emitChars("<"), this.state = T.RCDATA, this._stateRcdata(t));
  }
  // RCDATA end tag open state
  //------------------------------------------------------------------
  _stateRcdataEndTagOpen(t) {
    va(t) ? (this.state = T.RCDATA_END_TAG_NAME, this._stateRcdataEndTagName(t)) : (this._emitChars("</"), this.state = T.RCDATA, this._stateRcdata(t));
  }
  handleSpecialEndTag(t) {
    if (!this.preprocessor.startsWith(this.lastStartTagName, !1))
      return !this._ensureHibernation();
    this._createEndTagToken();
    const a = this.currentToken;
    switch (a.tagName = this.lastStartTagName, this.preprocessor.peek(this.lastStartTagName.length)) {
      case E.SPACE:
      case E.LINE_FEED:
      case E.TABULATION:
      case E.FORM_FEED:
        return this._advanceBy(this.lastStartTagName.length), this.state = T.BEFORE_ATTRIBUTE_NAME, !1;
      case E.SOLIDUS:
        return this._advanceBy(this.lastStartTagName.length), this.state = T.SELF_CLOSING_START_TAG, !1;
      case E.GREATER_THAN_SIGN:
        return this._advanceBy(this.lastStartTagName.length), this.emitCurrentTagToken(), this.state = T.DATA, !1;
      default:
        return !this._ensureHibernation();
    }
  }
  // RCDATA end tag name state
  //------------------------------------------------------------------
  _stateRcdataEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = T.RCDATA, this._stateRcdata(t));
  }
  // RAWTEXT less-than sign state
  //------------------------------------------------------------------
  _stateRawtextLessThanSign(t) {
    t === E.SOLIDUS ? this.state = T.RAWTEXT_END_TAG_OPEN : (this._emitChars("<"), this.state = T.RAWTEXT, this._stateRawtext(t));
  }
  // RAWTEXT end tag open state
  //------------------------------------------------------------------
  _stateRawtextEndTagOpen(t) {
    va(t) ? (this.state = T.RAWTEXT_END_TAG_NAME, this._stateRawtextEndTagName(t)) : (this._emitChars("</"), this.state = T.RAWTEXT, this._stateRawtext(t));
  }
  // RAWTEXT end tag name state
  //------------------------------------------------------------------
  _stateRawtextEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = T.RAWTEXT, this._stateRawtext(t));
  }
  // Script data less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataLessThanSign(t) {
    switch (t) {
      case E.SOLIDUS: {
        this.state = T.SCRIPT_DATA_END_TAG_OPEN;
        break;
      }
      case E.EXCLAMATION_MARK: {
        this.state = T.SCRIPT_DATA_ESCAPE_START, this._emitChars("<!");
        break;
      }
      default:
        this._emitChars("<"), this.state = T.SCRIPT_DATA, this._stateScriptData(t);
    }
  }
  // Script data end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEndTagOpen(t) {
    va(t) ? (this.state = T.SCRIPT_DATA_END_TAG_NAME, this._stateScriptDataEndTagName(t)) : (this._emitChars("</"), this.state = T.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = T.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escape start state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStart(t) {
    t === E.HYPHEN_MINUS ? (this.state = T.SCRIPT_DATA_ESCAPE_START_DASH, this._emitChars("-")) : (this.state = T.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escape start dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStartDash(t) {
    t === E.HYPHEN_MINUS ? (this.state = T.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-")) : (this.state = T.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escaped state
  //------------------------------------------------------------------
  _stateScriptDataEscaped(t) {
    switch (t) {
      case E.HYPHEN_MINUS: {
        this.state = T.SCRIPT_DATA_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case E.LESS_THAN_SIGN: {
        this.state = T.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case E.NULL: {
        this._err(j.unexpectedNullCharacter), this._emitChars(qe);
        break;
      }
      case E.EOF: {
        this._err(j.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDash(t) {
    switch (t) {
      case E.HYPHEN_MINUS: {
        this.state = T.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case E.LESS_THAN_SIGN: {
        this.state = T.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case E.NULL: {
        this._err(j.unexpectedNullCharacter), this.state = T.SCRIPT_DATA_ESCAPED, this._emitChars(qe);
        break;
      }
      case E.EOF: {
        this._err(j.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = T.SCRIPT_DATA_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDashDash(t) {
    switch (t) {
      case E.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case E.LESS_THAN_SIGN: {
        this.state = T.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case E.GREATER_THAN_SIGN: {
        this.state = T.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case E.NULL: {
        this._err(j.unexpectedNullCharacter), this.state = T.SCRIPT_DATA_ESCAPED, this._emitChars(qe);
        break;
      }
      case E.EOF: {
        this._err(j.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = T.SCRIPT_DATA_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataEscapedLessThanSign(t) {
    t === E.SOLIDUS ? this.state = T.SCRIPT_DATA_ESCAPED_END_TAG_OPEN : va(t) ? (this._emitChars("<"), this.state = T.SCRIPT_DATA_DOUBLE_ESCAPE_START, this._stateScriptDataDoubleEscapeStart(t)) : (this._emitChars("<"), this.state = T.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data escaped end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagOpen(t) {
    va(t) ? (this.state = T.SCRIPT_DATA_ESCAPED_END_TAG_NAME, this._stateScriptDataEscapedEndTagName(t)) : (this._emitChars("</"), this.state = T.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data escaped end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = T.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data double escape start state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeStart(t) {
    if (this.preprocessor.startsWith(kt.SCRIPT, !1) && nl(this.preprocessor.peek(kt.SCRIPT.length))) {
      this._emitCodePoint(t);
      for (let a = 0; a < kt.SCRIPT.length; a++)
        this._emitCodePoint(this._consume());
      this.state = T.SCRIPT_DATA_DOUBLE_ESCAPED;
    } else this._ensureHibernation() || (this.state = T.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data double escaped state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscaped(t) {
    switch (t) {
      case E.HYPHEN_MINUS: {
        this.state = T.SCRIPT_DATA_DOUBLE_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case E.LESS_THAN_SIGN: {
        this.state = T.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case E.NULL: {
        this._err(j.unexpectedNullCharacter), this._emitChars(qe);
        break;
      }
      case E.EOF: {
        this._err(j.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data double escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDash(t) {
    switch (t) {
      case E.HYPHEN_MINUS: {
        this.state = T.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case E.LESS_THAN_SIGN: {
        this.state = T.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case E.NULL: {
        this._err(j.unexpectedNullCharacter), this.state = T.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(qe);
        break;
      }
      case E.EOF: {
        this._err(j.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = T.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data double escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDashDash(t) {
    switch (t) {
      case E.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case E.LESS_THAN_SIGN: {
        this.state = T.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case E.GREATER_THAN_SIGN: {
        this.state = T.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case E.NULL: {
        this._err(j.unexpectedNullCharacter), this.state = T.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(qe);
        break;
      }
      case E.EOF: {
        this._err(j.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = T.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data double escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedLessThanSign(t) {
    t === E.SOLIDUS ? (this.state = T.SCRIPT_DATA_DOUBLE_ESCAPE_END, this._emitChars("/")) : (this.state = T.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(t));
  }
  // Script data double escape end state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeEnd(t) {
    if (this.preprocessor.startsWith(kt.SCRIPT, !1) && nl(this.preprocessor.peek(kt.SCRIPT.length))) {
      this._emitCodePoint(t);
      for (let a = 0; a < kt.SCRIPT.length; a++)
        this._emitCodePoint(this._consume());
      this.state = T.SCRIPT_DATA_ESCAPED;
    } else this._ensureHibernation() || (this.state = T.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(t));
  }
  // Before attribute name state
  //------------------------------------------------------------------
  _stateBeforeAttributeName(t) {
    switch (t) {
      case E.SPACE:
      case E.LINE_FEED:
      case E.TABULATION:
      case E.FORM_FEED:
        break;
      case E.SOLIDUS:
      case E.GREATER_THAN_SIGN:
      case E.EOF: {
        this.state = T.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(t);
        break;
      }
      case E.EQUALS_SIGN: {
        this._err(j.unexpectedEqualsSignBeforeAttributeName), this._createAttr("="), this.state = T.ATTRIBUTE_NAME;
        break;
      }
      default:
        this._createAttr(""), this.state = T.ATTRIBUTE_NAME, this._stateAttributeName(t);
    }
  }
  // Attribute name state
  //------------------------------------------------------------------
  _stateAttributeName(t) {
    switch (t) {
      case E.SPACE:
      case E.LINE_FEED:
      case E.TABULATION:
      case E.FORM_FEED:
      case E.SOLIDUS:
      case E.GREATER_THAN_SIGN:
      case E.EOF: {
        this._leaveAttrName(), this.state = T.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(t);
        break;
      }
      case E.EQUALS_SIGN: {
        this._leaveAttrName(), this.state = T.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case E.QUOTATION_MARK:
      case E.APOSTROPHE:
      case E.LESS_THAN_SIGN: {
        this._err(j.unexpectedCharacterInAttributeName), this.currentAttr.name += String.fromCodePoint(t);
        break;
      }
      case E.NULL: {
        this._err(j.unexpectedNullCharacter), this.currentAttr.name += qe;
        break;
      }
      default:
        this.currentAttr.name += String.fromCodePoint(Fr(t) ? bn(t) : t);
    }
  }
  // After attribute name state
  //------------------------------------------------------------------
  _stateAfterAttributeName(t) {
    switch (t) {
      case E.SPACE:
      case E.LINE_FEED:
      case E.TABULATION:
      case E.FORM_FEED:
        break;
      case E.SOLIDUS: {
        this.state = T.SELF_CLOSING_START_TAG;
        break;
      }
      case E.EQUALS_SIGN: {
        this.state = T.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case E.GREATER_THAN_SIGN: {
        this.state = T.DATA, this.emitCurrentTagToken();
        break;
      }
      case E.EOF: {
        this._err(j.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._createAttr(""), this.state = T.ATTRIBUTE_NAME, this._stateAttributeName(t);
    }
  }
  // Before attribute value state
  //------------------------------------------------------------------
  _stateBeforeAttributeValue(t) {
    switch (t) {
      case E.SPACE:
      case E.LINE_FEED:
      case E.TABULATION:
      case E.FORM_FEED:
        break;
      case E.QUOTATION_MARK: {
        this.state = T.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
        break;
      }
      case E.APOSTROPHE: {
        this.state = T.ATTRIBUTE_VALUE_SINGLE_QUOTED;
        break;
      }
      case E.GREATER_THAN_SIGN: {
        this._err(j.missingAttributeValue), this.state = T.DATA, this.emitCurrentTagToken();
        break;
      }
      default:
        this.state = T.ATTRIBUTE_VALUE_UNQUOTED, this._stateAttributeValueUnquoted(t);
    }
  }
  // Attribute value (double-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueDoubleQuoted(t) {
    switch (t) {
      case E.QUOTATION_MARK: {
        this.state = T.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case E.AMPERSAND: {
        this.returnState = T.ATTRIBUTE_VALUE_DOUBLE_QUOTED, this.state = T.CHARACTER_REFERENCE;
        break;
      }
      case E.NULL: {
        this._err(j.unexpectedNullCharacter), this.currentAttr.value += qe;
        break;
      }
      case E.EOF: {
        this._err(j.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // Attribute value (single-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueSingleQuoted(t) {
    switch (t) {
      case E.APOSTROPHE: {
        this.state = T.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case E.AMPERSAND: {
        this.returnState = T.ATTRIBUTE_VALUE_SINGLE_QUOTED, this.state = T.CHARACTER_REFERENCE;
        break;
      }
      case E.NULL: {
        this._err(j.unexpectedNullCharacter), this.currentAttr.value += qe;
        break;
      }
      case E.EOF: {
        this._err(j.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // Attribute value (unquoted) state
  //------------------------------------------------------------------
  _stateAttributeValueUnquoted(t) {
    switch (t) {
      case E.SPACE:
      case E.LINE_FEED:
      case E.TABULATION:
      case E.FORM_FEED: {
        this._leaveAttrValue(), this.state = T.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case E.AMPERSAND: {
        this.returnState = T.ATTRIBUTE_VALUE_UNQUOTED, this.state = T.CHARACTER_REFERENCE;
        break;
      }
      case E.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = T.DATA, this.emitCurrentTagToken();
        break;
      }
      case E.NULL: {
        this._err(j.unexpectedNullCharacter), this.currentAttr.value += qe;
        break;
      }
      case E.QUOTATION_MARK:
      case E.APOSTROPHE:
      case E.LESS_THAN_SIGN:
      case E.EQUALS_SIGN:
      case E.GRAVE_ACCENT: {
        this._err(j.unexpectedCharacterInUnquotedAttributeValue), this.currentAttr.value += String.fromCodePoint(t);
        break;
      }
      case E.EOF: {
        this._err(j.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // After attribute value (quoted) state
  //------------------------------------------------------------------
  _stateAfterAttributeValueQuoted(t) {
    switch (t) {
      case E.SPACE:
      case E.LINE_FEED:
      case E.TABULATION:
      case E.FORM_FEED: {
        this._leaveAttrValue(), this.state = T.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case E.SOLIDUS: {
        this._leaveAttrValue(), this.state = T.SELF_CLOSING_START_TAG;
        break;
      }
      case E.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = T.DATA, this.emitCurrentTagToken();
        break;
      }
      case E.EOF: {
        this._err(j.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(j.missingWhitespaceBetweenAttributes), this.state = T.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(t);
    }
  }
  // Self-closing start tag state
  //------------------------------------------------------------------
  _stateSelfClosingStartTag(t) {
    switch (t) {
      case E.GREATER_THAN_SIGN: {
        const a = this.currentToken;
        a.selfClosing = !0, this.state = T.DATA, this.emitCurrentTagToken();
        break;
      }
      case E.EOF: {
        this._err(j.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(j.unexpectedSolidusInTag), this.state = T.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(t);
    }
  }
  // Bogus comment state
  //------------------------------------------------------------------
  _stateBogusComment(t) {
    const a = this.currentToken;
    switch (t) {
      case E.GREATER_THAN_SIGN: {
        this.state = T.DATA, this.emitCurrentComment(a);
        break;
      }
      case E.EOF: {
        this.emitCurrentComment(a), this._emitEOFToken();
        break;
      }
      case E.NULL: {
        this._err(j.unexpectedNullCharacter), a.data += qe;
        break;
      }
      default:
        a.data += String.fromCodePoint(t);
    }
  }
  // Markup declaration open state
  //------------------------------------------------------------------
  _stateMarkupDeclarationOpen(t) {
    this._consumeSequenceIfMatch(kt.DASH_DASH, !0) ? (this._createCommentToken(kt.DASH_DASH.length + 1), this.state = T.COMMENT_START) : this._consumeSequenceIfMatch(kt.DOCTYPE, !1) ? (this.currentLocation = this.getCurrentLocation(kt.DOCTYPE.length + 1), this.state = T.DOCTYPE) : this._consumeSequenceIfMatch(kt.CDATA_START, !0) ? this.inForeignNode ? this.state = T.CDATA_SECTION : (this._err(j.cdataInHtmlContent), this._createCommentToken(kt.CDATA_START.length + 1), this.currentToken.data = "[CDATA[", this.state = T.BOGUS_COMMENT) : this._ensureHibernation() || (this._err(j.incorrectlyOpenedComment), this._createCommentToken(2), this.state = T.BOGUS_COMMENT, this._stateBogusComment(t));
  }
  // Comment start state
  //------------------------------------------------------------------
  _stateCommentStart(t) {
    switch (t) {
      case E.HYPHEN_MINUS: {
        this.state = T.COMMENT_START_DASH;
        break;
      }
      case E.GREATER_THAN_SIGN: {
        this._err(j.abruptClosingOfEmptyComment), this.state = T.DATA;
        const a = this.currentToken;
        this.emitCurrentComment(a);
        break;
      }
      default:
        this.state = T.COMMENT, this._stateComment(t);
    }
  }
  // Comment start dash state
  //------------------------------------------------------------------
  _stateCommentStartDash(t) {
    const a = this.currentToken;
    switch (t) {
      case E.HYPHEN_MINUS: {
        this.state = T.COMMENT_END;
        break;
      }
      case E.GREATER_THAN_SIGN: {
        this._err(j.abruptClosingOfEmptyComment), this.state = T.DATA, this.emitCurrentComment(a);
        break;
      }
      case E.EOF: {
        this._err(j.eofInComment), this.emitCurrentComment(a), this._emitEOFToken();
        break;
      }
      default:
        a.data += "-", this.state = T.COMMENT, this._stateComment(t);
    }
  }
  // Comment state
  //------------------------------------------------------------------
  _stateComment(t) {
    const a = this.currentToken;
    switch (t) {
      case E.HYPHEN_MINUS: {
        this.state = T.COMMENT_END_DASH;
        break;
      }
      case E.LESS_THAN_SIGN: {
        a.data += "<", this.state = T.COMMENT_LESS_THAN_SIGN;
        break;
      }
      case E.NULL: {
        this._err(j.unexpectedNullCharacter), a.data += qe;
        break;
      }
      case E.EOF: {
        this._err(j.eofInComment), this.emitCurrentComment(a), this._emitEOFToken();
        break;
      }
      default:
        a.data += String.fromCodePoint(t);
    }
  }
  // Comment less-than sign state
  //------------------------------------------------------------------
  _stateCommentLessThanSign(t) {
    const a = this.currentToken;
    switch (t) {
      case E.EXCLAMATION_MARK: {
        a.data += "!", this.state = T.COMMENT_LESS_THAN_SIGN_BANG;
        break;
      }
      case E.LESS_THAN_SIGN: {
        a.data += "<";
        break;
      }
      default:
        this.state = T.COMMENT, this._stateComment(t);
    }
  }
  // Comment less-than sign bang state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBang(t) {
    t === E.HYPHEN_MINUS ? this.state = T.COMMENT_LESS_THAN_SIGN_BANG_DASH : (this.state = T.COMMENT, this._stateComment(t));
  }
  // Comment less-than sign bang dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDash(t) {
    t === E.HYPHEN_MINUS ? this.state = T.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH : (this.state = T.COMMENT_END_DASH, this._stateCommentEndDash(t));
  }
  // Comment less-than sign bang dash dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDashDash(t) {
    t !== E.GREATER_THAN_SIGN && t !== E.EOF && this._err(j.nestedComment), this.state = T.COMMENT_END, this._stateCommentEnd(t);
  }
  // Comment end dash state
  //------------------------------------------------------------------
  _stateCommentEndDash(t) {
    const a = this.currentToken;
    switch (t) {
      case E.HYPHEN_MINUS: {
        this.state = T.COMMENT_END;
        break;
      }
      case E.EOF: {
        this._err(j.eofInComment), this.emitCurrentComment(a), this._emitEOFToken();
        break;
      }
      default:
        a.data += "-", this.state = T.COMMENT, this._stateComment(t);
    }
  }
  // Comment end state
  //------------------------------------------------------------------
  _stateCommentEnd(t) {
    const a = this.currentToken;
    switch (t) {
      case E.GREATER_THAN_SIGN: {
        this.state = T.DATA, this.emitCurrentComment(a);
        break;
      }
      case E.EXCLAMATION_MARK: {
        this.state = T.COMMENT_END_BANG;
        break;
      }
      case E.HYPHEN_MINUS: {
        a.data += "-";
        break;
      }
      case E.EOF: {
        this._err(j.eofInComment), this.emitCurrentComment(a), this._emitEOFToken();
        break;
      }
      default:
        a.data += "--", this.state = T.COMMENT, this._stateComment(t);
    }
  }
  // Comment end bang state
  //------------------------------------------------------------------
  _stateCommentEndBang(t) {
    const a = this.currentToken;
    switch (t) {
      case E.HYPHEN_MINUS: {
        a.data += "--!", this.state = T.COMMENT_END_DASH;
        break;
      }
      case E.GREATER_THAN_SIGN: {
        this._err(j.incorrectlyClosedComment), this.state = T.DATA, this.emitCurrentComment(a);
        break;
      }
      case E.EOF: {
        this._err(j.eofInComment), this.emitCurrentComment(a), this._emitEOFToken();
        break;
      }
      default:
        a.data += "--!", this.state = T.COMMENT, this._stateComment(t);
    }
  }
  // DOCTYPE state
  //------------------------------------------------------------------
  _stateDoctype(t) {
    switch (t) {
      case E.SPACE:
      case E.LINE_FEED:
      case E.TABULATION:
      case E.FORM_FEED: {
        this.state = T.BEFORE_DOCTYPE_NAME;
        break;
      }
      case E.GREATER_THAN_SIGN: {
        this.state = T.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(t);
        break;
      }
      case E.EOF: {
        this._err(j.eofInDoctype), this._createDoctypeToken(null);
        const a = this.currentToken;
        a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        this._err(j.missingWhitespaceBeforeDoctypeName), this.state = T.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(t);
    }
  }
  // Before DOCTYPE name state
  //------------------------------------------------------------------
  _stateBeforeDoctypeName(t) {
    if (Fr(t))
      this._createDoctypeToken(String.fromCharCode(bn(t))), this.state = T.DOCTYPE_NAME;
    else
      switch (t) {
        case E.SPACE:
        case E.LINE_FEED:
        case E.TABULATION:
        case E.FORM_FEED:
          break;
        case E.NULL: {
          this._err(j.unexpectedNullCharacter), this._createDoctypeToken(qe), this.state = T.DOCTYPE_NAME;
          break;
        }
        case E.GREATER_THAN_SIGN: {
          this._err(j.missingDoctypeName), this._createDoctypeToken(null);
          const a = this.currentToken;
          a.forceQuirks = !0, this.emitCurrentDoctype(a), this.state = T.DATA;
          break;
        }
        case E.EOF: {
          this._err(j.eofInDoctype), this._createDoctypeToken(null);
          const a = this.currentToken;
          a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
          break;
        }
        default:
          this._createDoctypeToken(String.fromCodePoint(t)), this.state = T.DOCTYPE_NAME;
      }
  }
  // DOCTYPE name state
  //------------------------------------------------------------------
  _stateDoctypeName(t) {
    const a = this.currentToken;
    switch (t) {
      case E.SPACE:
      case E.LINE_FEED:
      case E.TABULATION:
      case E.FORM_FEED: {
        this.state = T.AFTER_DOCTYPE_NAME;
        break;
      }
      case E.GREATER_THAN_SIGN: {
        this.state = T.DATA, this.emitCurrentDoctype(a);
        break;
      }
      case E.NULL: {
        this._err(j.unexpectedNullCharacter), a.name += qe;
        break;
      }
      case E.EOF: {
        this._err(j.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        a.name += String.fromCodePoint(Fr(t) ? bn(t) : t);
    }
  }
  // After DOCTYPE name state
  //------------------------------------------------------------------
  _stateAfterDoctypeName(t) {
    const a = this.currentToken;
    switch (t) {
      case E.SPACE:
      case E.LINE_FEED:
      case E.TABULATION:
      case E.FORM_FEED:
        break;
      case E.GREATER_THAN_SIGN: {
        this.state = T.DATA, this.emitCurrentDoctype(a);
        break;
      }
      case E.EOF: {
        this._err(j.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        this._consumeSequenceIfMatch(kt.PUBLIC, !1) ? this.state = T.AFTER_DOCTYPE_PUBLIC_KEYWORD : this._consumeSequenceIfMatch(kt.SYSTEM, !1) ? this.state = T.AFTER_DOCTYPE_SYSTEM_KEYWORD : this._ensureHibernation() || (this._err(j.invalidCharacterSequenceAfterDoctypeName), a.forceQuirks = !0, this.state = T.BOGUS_DOCTYPE, this._stateBogusDoctype(t));
    }
  }
  // After DOCTYPE public keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicKeyword(t) {
    const a = this.currentToken;
    switch (t) {
      case E.SPACE:
      case E.LINE_FEED:
      case E.TABULATION:
      case E.FORM_FEED: {
        this.state = T.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case E.QUOTATION_MARK: {
        this._err(j.missingWhitespaceAfterDoctypePublicKeyword), a.publicId = "", this.state = T.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case E.APOSTROPHE: {
        this._err(j.missingWhitespaceAfterDoctypePublicKeyword), a.publicId = "", this.state = T.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case E.GREATER_THAN_SIGN: {
        this._err(j.missingDoctypePublicIdentifier), a.forceQuirks = !0, this.state = T.DATA, this.emitCurrentDoctype(a);
        break;
      }
      case E.EOF: {
        this._err(j.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        this._err(j.missingQuoteBeforeDoctypePublicIdentifier), a.forceQuirks = !0, this.state = T.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Before DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypePublicIdentifier(t) {
    const a = this.currentToken;
    switch (t) {
      case E.SPACE:
      case E.LINE_FEED:
      case E.TABULATION:
      case E.FORM_FEED:
        break;
      case E.QUOTATION_MARK: {
        a.publicId = "", this.state = T.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case E.APOSTROPHE: {
        a.publicId = "", this.state = T.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case E.GREATER_THAN_SIGN: {
        this._err(j.missingDoctypePublicIdentifier), a.forceQuirks = !0, this.state = T.DATA, this.emitCurrentDoctype(a);
        break;
      }
      case E.EOF: {
        this._err(j.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        this._err(j.missingQuoteBeforeDoctypePublicIdentifier), a.forceQuirks = !0, this.state = T.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // DOCTYPE public identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierDoubleQuoted(t) {
    const a = this.currentToken;
    switch (t) {
      case E.QUOTATION_MARK: {
        this.state = T.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case E.NULL: {
        this._err(j.unexpectedNullCharacter), a.publicId += qe;
        break;
      }
      case E.GREATER_THAN_SIGN: {
        this._err(j.abruptDoctypePublicIdentifier), a.forceQuirks = !0, this.emitCurrentDoctype(a), this.state = T.DATA;
        break;
      }
      case E.EOF: {
        this._err(j.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        a.publicId += String.fromCodePoint(t);
    }
  }
  // DOCTYPE public identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierSingleQuoted(t) {
    const a = this.currentToken;
    switch (t) {
      case E.APOSTROPHE: {
        this.state = T.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case E.NULL: {
        this._err(j.unexpectedNullCharacter), a.publicId += qe;
        break;
      }
      case E.GREATER_THAN_SIGN: {
        this._err(j.abruptDoctypePublicIdentifier), a.forceQuirks = !0, this.emitCurrentDoctype(a), this.state = T.DATA;
        break;
      }
      case E.EOF: {
        this._err(j.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        a.publicId += String.fromCodePoint(t);
    }
  }
  // After DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicIdentifier(t) {
    const a = this.currentToken;
    switch (t) {
      case E.SPACE:
      case E.LINE_FEED:
      case E.TABULATION:
      case E.FORM_FEED: {
        this.state = T.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
        break;
      }
      case E.GREATER_THAN_SIGN: {
        this.state = T.DATA, this.emitCurrentDoctype(a);
        break;
      }
      case E.QUOTATION_MARK: {
        this._err(j.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), a.systemId = "", this.state = T.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case E.APOSTROPHE: {
        this._err(j.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), a.systemId = "", this.state = T.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case E.EOF: {
        this._err(j.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        this._err(j.missingQuoteBeforeDoctypeSystemIdentifier), a.forceQuirks = !0, this.state = T.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Between DOCTYPE public and system identifiers state
  //------------------------------------------------------------------
  _stateBetweenDoctypePublicAndSystemIdentifiers(t) {
    const a = this.currentToken;
    switch (t) {
      case E.SPACE:
      case E.LINE_FEED:
      case E.TABULATION:
      case E.FORM_FEED:
        break;
      case E.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(a), this.state = T.DATA;
        break;
      }
      case E.QUOTATION_MARK: {
        a.systemId = "", this.state = T.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case E.APOSTROPHE: {
        a.systemId = "", this.state = T.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case E.EOF: {
        this._err(j.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        this._err(j.missingQuoteBeforeDoctypeSystemIdentifier), a.forceQuirks = !0, this.state = T.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // After DOCTYPE system keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemKeyword(t) {
    const a = this.currentToken;
    switch (t) {
      case E.SPACE:
      case E.LINE_FEED:
      case E.TABULATION:
      case E.FORM_FEED: {
        this.state = T.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case E.QUOTATION_MARK: {
        this._err(j.missingWhitespaceAfterDoctypeSystemKeyword), a.systemId = "", this.state = T.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case E.APOSTROPHE: {
        this._err(j.missingWhitespaceAfterDoctypeSystemKeyword), a.systemId = "", this.state = T.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case E.GREATER_THAN_SIGN: {
        this._err(j.missingDoctypeSystemIdentifier), a.forceQuirks = !0, this.state = T.DATA, this.emitCurrentDoctype(a);
        break;
      }
      case E.EOF: {
        this._err(j.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        this._err(j.missingQuoteBeforeDoctypeSystemIdentifier), a.forceQuirks = !0, this.state = T.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Before DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypeSystemIdentifier(t) {
    const a = this.currentToken;
    switch (t) {
      case E.SPACE:
      case E.LINE_FEED:
      case E.TABULATION:
      case E.FORM_FEED:
        break;
      case E.QUOTATION_MARK: {
        a.systemId = "", this.state = T.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case E.APOSTROPHE: {
        a.systemId = "", this.state = T.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case E.GREATER_THAN_SIGN: {
        this._err(j.missingDoctypeSystemIdentifier), a.forceQuirks = !0, this.state = T.DATA, this.emitCurrentDoctype(a);
        break;
      }
      case E.EOF: {
        this._err(j.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        this._err(j.missingQuoteBeforeDoctypeSystemIdentifier), a.forceQuirks = !0, this.state = T.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // DOCTYPE system identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierDoubleQuoted(t) {
    const a = this.currentToken;
    switch (t) {
      case E.QUOTATION_MARK: {
        this.state = T.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case E.NULL: {
        this._err(j.unexpectedNullCharacter), a.systemId += qe;
        break;
      }
      case E.GREATER_THAN_SIGN: {
        this._err(j.abruptDoctypeSystemIdentifier), a.forceQuirks = !0, this.emitCurrentDoctype(a), this.state = T.DATA;
        break;
      }
      case E.EOF: {
        this._err(j.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        a.systemId += String.fromCodePoint(t);
    }
  }
  // DOCTYPE system identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierSingleQuoted(t) {
    const a = this.currentToken;
    switch (t) {
      case E.APOSTROPHE: {
        this.state = T.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case E.NULL: {
        this._err(j.unexpectedNullCharacter), a.systemId += qe;
        break;
      }
      case E.GREATER_THAN_SIGN: {
        this._err(j.abruptDoctypeSystemIdentifier), a.forceQuirks = !0, this.emitCurrentDoctype(a), this.state = T.DATA;
        break;
      }
      case E.EOF: {
        this._err(j.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        a.systemId += String.fromCodePoint(t);
    }
  }
  // After DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemIdentifier(t) {
    const a = this.currentToken;
    switch (t) {
      case E.SPACE:
      case E.LINE_FEED:
      case E.TABULATION:
      case E.FORM_FEED:
        break;
      case E.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(a), this.state = T.DATA;
        break;
      }
      case E.EOF: {
        this._err(j.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        this._err(j.unexpectedCharacterAfterDoctypeSystemIdentifier), this.state = T.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Bogus DOCTYPE state
  //------------------------------------------------------------------
  _stateBogusDoctype(t) {
    const a = this.currentToken;
    switch (t) {
      case E.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(a), this.state = T.DATA;
        break;
      }
      case E.NULL: {
        this._err(j.unexpectedNullCharacter);
        break;
      }
      case E.EOF: {
        this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
    }
  }
  // CDATA section state
  //------------------------------------------------------------------
  _stateCdataSection(t) {
    switch (t) {
      case E.RIGHT_SQUARE_BRACKET: {
        this.state = T.CDATA_SECTION_BRACKET;
        break;
      }
      case E.EOF: {
        this._err(j.eofInCdata), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // CDATA section bracket state
  //------------------------------------------------------------------
  _stateCdataSectionBracket(t) {
    t === E.RIGHT_SQUARE_BRACKET ? this.state = T.CDATA_SECTION_END : (this._emitChars("]"), this.state = T.CDATA_SECTION, this._stateCdataSection(t));
  }
  // CDATA section end state
  //------------------------------------------------------------------
  _stateCdataSectionEnd(t) {
    switch (t) {
      case E.GREATER_THAN_SIGN: {
        this.state = T.DATA;
        break;
      }
      case E.RIGHT_SQUARE_BRACKET: {
        this._emitChars("]");
        break;
      }
      default:
        this._emitChars("]]"), this.state = T.CDATA_SECTION, this._stateCdataSection(t);
    }
  }
  // Character reference state
  //------------------------------------------------------------------
  _stateCharacterReference(t) {
    t === E.NUMBER_SIGN ? this.state = T.NUMERIC_CHARACTER_REFERENCE : gi(t) ? (this.state = T.NAMED_CHARACTER_REFERENCE, this._stateNamedCharacterReference(t)) : (this._flushCodePointConsumedAsCharacterReference(E.AMPERSAND), this._reconsumeInState(this.returnState, t));
  }
  // Named character reference state
  //------------------------------------------------------------------
  _stateNamedCharacterReference(t) {
    const a = this._matchNamedCharacterReference(t);
    if (!this._ensureHibernation()) if (a) {
      for (let r = 0; r < a.length; r++)
        this._flushCodePointConsumedAsCharacterReference(a[r]);
      this.state = this.returnState;
    } else
      this._flushCodePointConsumedAsCharacterReference(E.AMPERSAND), this.state = T.AMBIGUOUS_AMPERSAND;
  }
  // Ambiguos ampersand state
  //------------------------------------------------------------------
  _stateAmbiguousAmpersand(t) {
    gi(t) ? this._flushCodePointConsumedAsCharacterReference(t) : (t === E.SEMICOLON && this._err(j.unknownNamedCharacterReference), this._reconsumeInState(this.returnState, t));
  }
  // Numeric character reference state
  //------------------------------------------------------------------
  _stateNumericCharacterReference(t) {
    this.charRefCode = 0, t === E.LATIN_SMALL_X || t === E.LATIN_CAPITAL_X ? this.state = T.HEXADEMICAL_CHARACTER_REFERENCE_START : Pr(t) ? (this.state = T.DECIMAL_CHARACTER_REFERENCE, this._stateDecimalCharacterReference(t)) : (this._err(j.absenceOfDigitsInNumericCharacterReference), this._flushCodePointConsumedAsCharacterReference(E.AMPERSAND), this._flushCodePointConsumedAsCharacterReference(E.NUMBER_SIGN), this._reconsumeInState(this.returnState, t));
  }
  // Hexademical character reference start state
  //------------------------------------------------------------------
  _stateHexademicalCharacterReferenceStart(t) {
    MU(t) ? (this.state = T.HEXADEMICAL_CHARACTER_REFERENCE, this._stateHexademicalCharacterReference(t)) : (this._err(j.absenceOfDigitsInNumericCharacterReference), this._flushCodePointConsumedAsCharacterReference(E.AMPERSAND), this._flushCodePointConsumedAsCharacterReference(E.NUMBER_SIGN), this._unconsume(2), this.state = this.returnState);
  }
  // Hexademical character reference state
  //------------------------------------------------------------------
  _stateHexademicalCharacterReference(t) {
    W0(t) ? this.charRefCode = this.charRefCode * 16 + t - 55 : $0(t) ? this.charRefCode = this.charRefCode * 16 + t - 87 : Pr(t) ? this.charRefCode = this.charRefCode * 16 + t - 48 : t === E.SEMICOLON ? this.state = T.NUMERIC_CHARACTER_REFERENCE_END : (this._err(j.missingSemicolonAfterCharacterReference), this.state = T.NUMERIC_CHARACTER_REFERENCE_END, this._stateNumericCharacterReferenceEnd(t));
  }
  // Decimal character reference state
  //------------------------------------------------------------------
  _stateDecimalCharacterReference(t) {
    Pr(t) ? this.charRefCode = this.charRefCode * 10 + t - 48 : t === E.SEMICOLON ? this.state = T.NUMERIC_CHARACTER_REFERENCE_END : (this._err(j.missingSemicolonAfterCharacterReference), this.state = T.NUMERIC_CHARACTER_REFERENCE_END, this._stateNumericCharacterReferenceEnd(t));
  }
  // Numeric character reference end state
  //------------------------------------------------------------------
  _stateNumericCharacterReferenceEnd(t) {
    if (this.charRefCode === E.NULL)
      this._err(j.nullCharacterReference), this.charRefCode = E.REPLACEMENT_CHARACTER;
    else if (this.charRefCode > 1114111)
      this._err(j.characterReferenceOutsideUnicodeRange), this.charRefCode = E.REPLACEMENT_CHARACTER;
    else if (H0(this.charRefCode))
      this._err(j.surrogateCharacterReference), this.charRefCode = E.REPLACEMENT_CHARACTER;
    else if (j0(this.charRefCode))
      this._err(j.noncharacterCharacterReference);
    else if (U0(this.charRefCode) || this.charRefCode === E.CARRIAGE_RETURN) {
      this._err(j.controlCharacterReference);
      const a = OU.get(this.charRefCode);
      a !== void 0 && (this.charRefCode = a);
    }
    this._flushCodePointConsumedAsCharacterReference(this.charRefCode), this._reconsumeInState(this.returnState, t);
  }
}
const Q0 = /* @__PURE__ */ new Set([l.DD, l.DT, l.LI, l.OPTGROUP, l.OPTION, l.P, l.RB, l.RP, l.RT, l.RTC]), sl = /* @__PURE__ */ new Set([
  ...Q0,
  l.CAPTION,
  l.COLGROUP,
  l.TBODY,
  l.TD,
  l.TFOOT,
  l.TH,
  l.THEAD,
  l.TR
]), kn = /* @__PURE__ */ new Map([
  [l.APPLET, Y.HTML],
  [l.CAPTION, Y.HTML],
  [l.HTML, Y.HTML],
  [l.MARQUEE, Y.HTML],
  [l.OBJECT, Y.HTML],
  [l.TABLE, Y.HTML],
  [l.TD, Y.HTML],
  [l.TEMPLATE, Y.HTML],
  [l.TH, Y.HTML],
  [l.ANNOTATION_XML, Y.MATHML],
  [l.MI, Y.MATHML],
  [l.MN, Y.MATHML],
  [l.MO, Y.MATHML],
  [l.MS, Y.MATHML],
  [l.MTEXT, Y.MATHML],
  [l.DESC, Y.SVG],
  [l.FOREIGN_OBJECT, Y.SVG],
  [l.TITLE, Y.SVG]
]), HU = [l.H1, l.H2, l.H3, l.H4, l.H5, l.H6], UU = [l.TR, l.TEMPLATE, l.HTML], jU = [l.TBODY, l.TFOOT, l.THEAD, l.TEMPLATE, l.HTML], qU = [l.TABLE, l.TEMPLATE, l.HTML], YU = [l.TD, l.TH];
class VU {
  get currentTmplContentOrNode() {
    return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
  }
  constructor(t, a, r) {
    this.treeAdapter = a, this.handler = r, this.items = [], this.tagIDs = [], this.stackTop = -1, this.tmplCount = 0, this.currentTagId = l.UNKNOWN, this.current = t;
  }
  //Index of element
  _indexOf(t) {
    return this.items.lastIndexOf(t, this.stackTop);
  }
  //Update current element
  _isInTemplate() {
    return this.currentTagId === l.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === Y.HTML;
  }
  _updateCurrentElement() {
    this.current = this.items[this.stackTop], this.currentTagId = this.tagIDs[this.stackTop];
  }
  //Mutations
  push(t, a) {
    this.stackTop++, this.items[this.stackTop] = t, this.current = t, this.tagIDs[this.stackTop] = a, this.currentTagId = a, this._isInTemplate() && this.tmplCount++, this.handler.onItemPush(t, a, !0);
  }
  pop() {
    const t = this.current;
    this.tmplCount > 0 && this._isInTemplate() && this.tmplCount--, this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(t, !0);
  }
  replace(t, a) {
    const r = this._indexOf(t);
    this.items[r] = a, r === this.stackTop && (this.current = a);
  }
  insertAfter(t, a, r) {
    const n = this._indexOf(t) + 1;
    this.items.splice(n, 0, a), this.tagIDs.splice(n, 0, r), this.stackTop++, n === this.stackTop && this._updateCurrentElement(), this.handler.onItemPush(this.current, this.currentTagId, n === this.stackTop);
  }
  popUntilTagNamePopped(t) {
    let a = this.stackTop + 1;
    do
      a = this.tagIDs.lastIndexOf(t, a - 1);
    while (a > 0 && this.treeAdapter.getNamespaceURI(this.items[a]) !== Y.HTML);
    this.shortenToLength(a < 0 ? 0 : a);
  }
  shortenToLength(t) {
    for (; this.stackTop >= t; ) {
      const a = this.current;
      this.tmplCount > 0 && this._isInTemplate() && (this.tmplCount -= 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(a, this.stackTop < t);
    }
  }
  popUntilElementPopped(t) {
    const a = this._indexOf(t);
    this.shortenToLength(a < 0 ? 0 : a);
  }
  popUntilPopped(t, a) {
    const r = this._indexOfTagNames(t, a);
    this.shortenToLength(r < 0 ? 0 : r);
  }
  popUntilNumberedHeaderPopped() {
    this.popUntilPopped(HU, Y.HTML);
  }
  popUntilTableCellPopped() {
    this.popUntilPopped(YU, Y.HTML);
  }
  popAllUpToHtmlElement() {
    this.tmplCount = 0, this.shortenToLength(1);
  }
  _indexOfTagNames(t, a) {
    for (let r = this.stackTop; r >= 0; r--)
      if (t.includes(this.tagIDs[r]) && this.treeAdapter.getNamespaceURI(this.items[r]) === a)
        return r;
    return -1;
  }
  clearBackTo(t, a) {
    const r = this._indexOfTagNames(t, a);
    this.shortenToLength(r + 1);
  }
  clearBackToTableContext() {
    this.clearBackTo(qU, Y.HTML);
  }
  clearBackToTableBodyContext() {
    this.clearBackTo(jU, Y.HTML);
  }
  clearBackToTableRowContext() {
    this.clearBackTo(UU, Y.HTML);
  }
  remove(t) {
    const a = this._indexOf(t);
    a >= 0 && (a === this.stackTop ? this.pop() : (this.items.splice(a, 1), this.tagIDs.splice(a, 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(t, !1)));
  }
  //Search
  tryPeekProperlyNestedBodyElement() {
    return this.stackTop >= 1 && this.tagIDs[1] === l.BODY ? this.items[1] : null;
  }
  contains(t) {
    return this._indexOf(t) > -1;
  }
  getCommonAncestor(t) {
    const a = this._indexOf(t) - 1;
    return a >= 0 ? this.items[a] : null;
  }
  isRootHtmlElementCurrent() {
    return this.stackTop === 0 && this.tagIDs[0] === l.HTML;
  }
  //Element in scope
  hasInScope(t) {
    for (let a = this.stackTop; a >= 0; a--) {
      const r = this.tagIDs[a], n = this.treeAdapter.getNamespaceURI(this.items[a]);
      if (r === t && n === Y.HTML)
        return !0;
      if (kn.get(r) === n)
        return !1;
    }
    return !0;
  }
  hasNumberedHeaderInScope() {
    for (let t = this.stackTop; t >= 0; t--) {
      const a = this.tagIDs[t], r = this.treeAdapter.getNamespaceURI(this.items[t]);
      if (G0(a) && r === Y.HTML)
        return !0;
      if (kn.get(a) === r)
        return !1;
    }
    return !0;
  }
  hasInListItemScope(t) {
    for (let a = this.stackTop; a >= 0; a--) {
      const r = this.tagIDs[a], n = this.treeAdapter.getNamespaceURI(this.items[a]);
      if (r === t && n === Y.HTML)
        return !0;
      if ((r === l.UL || r === l.OL) && n === Y.HTML || kn.get(r) === n)
        return !1;
    }
    return !0;
  }
  hasInButtonScope(t) {
    for (let a = this.stackTop; a >= 0; a--) {
      const r = this.tagIDs[a], n = this.treeAdapter.getNamespaceURI(this.items[a]);
      if (r === t && n === Y.HTML)
        return !0;
      if (r === l.BUTTON && n === Y.HTML || kn.get(r) === n)
        return !1;
    }
    return !0;
  }
  hasInTableScope(t) {
    for (let a = this.stackTop; a >= 0; a--) {
      const r = this.tagIDs[a];
      if (this.treeAdapter.getNamespaceURI(this.items[a]) === Y.HTML) {
        if (r === t)
          return !0;
        if (r === l.TABLE || r === l.TEMPLATE || r === l.HTML)
          return !1;
      }
    }
    return !0;
  }
  hasTableBodyContextInTableScope() {
    for (let t = this.stackTop; t >= 0; t--) {
      const a = this.tagIDs[t];
      if (this.treeAdapter.getNamespaceURI(this.items[t]) === Y.HTML) {
        if (a === l.TBODY || a === l.THEAD || a === l.TFOOT)
          return !0;
        if (a === l.TABLE || a === l.HTML)
          return !1;
      }
    }
    return !0;
  }
  hasInSelectScope(t) {
    for (let a = this.stackTop; a >= 0; a--) {
      const r = this.tagIDs[a];
      if (this.treeAdapter.getNamespaceURI(this.items[a]) === Y.HTML) {
        if (r === t)
          return !0;
        if (r !== l.OPTION && r !== l.OPTGROUP)
          return !1;
      }
    }
    return !0;
  }
  //Implied end tags
  generateImpliedEndTags() {
    for (; Q0.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsThoroughly() {
    for (; sl.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsWithExclusion(t) {
    for (; this.currentTagId !== t && sl.has(this.currentTagId); )
      this.pop();
  }
}
const qs = 3;
var Vt;
(function(e) {
  e[e.Marker = 0] = "Marker", e[e.Element = 1] = "Element";
})(Vt = Vt || (Vt = {}));
const il = { type: Vt.Marker };
class GU {
  constructor(t) {
    this.treeAdapter = t, this.entries = [], this.bookmark = null;
  }
  //Noah Ark's condition
  //OPTIMIZATION: at first we try to find possible candidates for exclusion using
  //lightweight heuristics without thorough attributes check.
  _getNoahArkConditionCandidates(t, a) {
    const r = [], n = a.length, s = this.treeAdapter.getTagName(t), i = this.treeAdapter.getNamespaceURI(t);
    for (let o = 0; o < this.entries.length; o++) {
      const c = this.entries[o];
      if (c.type === Vt.Marker)
        break;
      const { element: u } = c;
      if (this.treeAdapter.getTagName(u) === s && this.treeAdapter.getNamespaceURI(u) === i) {
        const d = this.treeAdapter.getAttrList(u);
        d.length === n && r.push({ idx: o, attrs: d });
      }
    }
    return r;
  }
  _ensureNoahArkCondition(t) {
    if (this.entries.length < qs)
      return;
    const a = this.treeAdapter.getAttrList(t), r = this._getNoahArkConditionCandidates(t, a);
    if (r.length < qs)
      return;
    const n = new Map(a.map((i) => [i.name, i.value]));
    let s = 0;
    for (let i = 0; i < r.length; i++) {
      const o = r[i];
      o.attrs.every((c) => n.get(c.name) === c.value) && (s += 1, s >= qs && this.entries.splice(o.idx, 1));
    }
  }
  //Mutations
  insertMarker() {
    this.entries.unshift(il);
  }
  pushElement(t, a) {
    this._ensureNoahArkCondition(t), this.entries.unshift({
      type: Vt.Element,
      element: t,
      token: a
    });
  }
  insertElementAfterBookmark(t, a) {
    const r = this.entries.indexOf(this.bookmark);
    this.entries.splice(r, 0, {
      type: Vt.Element,
      element: t,
      token: a
    });
  }
  removeEntry(t) {
    const a = this.entries.indexOf(t);
    a >= 0 && this.entries.splice(a, 1);
  }
  /**
   * Clears the list of formatting elements up to the last marker.
   *
   * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker
   */
  clearToLastMarker() {
    const t = this.entries.indexOf(il);
    t >= 0 ? this.entries.splice(0, t + 1) : this.entries.length = 0;
  }
  //Search
  getElementEntryInScopeWithTagName(t) {
    const a = this.entries.find((r) => r.type === Vt.Marker || this.treeAdapter.getTagName(r.element) === t);
    return a && a.type === Vt.Element ? a : null;
  }
  getElementEntry(t) {
    return this.entries.find((a) => a.type === Vt.Element && a.element === t);
  }
}
function ol(e) {
  return {
    nodeName: "#text",
    value: e,
    parentNode: null
  };
}
const er = {
  //Node construction
  createDocument() {
    return {
      nodeName: "#document",
      mode: Nt.NO_QUIRKS,
      childNodes: []
    };
  },
  createDocumentFragment() {
    return {
      nodeName: "#document-fragment",
      childNodes: []
    };
  },
  createElement(e, t, a) {
    return {
      nodeName: e,
      tagName: e,
      attrs: a,
      namespaceURI: t,
      childNodes: [],
      parentNode: null
    };
  },
  createCommentNode(e) {
    return {
      nodeName: "#comment",
      data: e,
      parentNode: null
    };
  },
  //Tree mutation
  appendChild(e, t) {
    e.childNodes.push(t), t.parentNode = e;
  },
  insertBefore(e, t, a) {
    const r = e.childNodes.indexOf(a);
    e.childNodes.splice(r, 0, t), t.parentNode = e;
  },
  setTemplateContent(e, t) {
    e.content = t;
  },
  getTemplateContent(e) {
    return e.content;
  },
  setDocumentType(e, t, a, r) {
    const n = e.childNodes.find((s) => s.nodeName === "#documentType");
    if (n)
      n.name = t, n.publicId = a, n.systemId = r;
    else {
      const s = {
        nodeName: "#documentType",
        name: t,
        publicId: a,
        systemId: r,
        parentNode: null
      };
      er.appendChild(e, s);
    }
  },
  setDocumentMode(e, t) {
    e.mode = t;
  },
  getDocumentMode(e) {
    return e.mode;
  },
  detachNode(e) {
    if (e.parentNode) {
      const t = e.parentNode.childNodes.indexOf(e);
      e.parentNode.childNodes.splice(t, 1), e.parentNode = null;
    }
  },
  insertText(e, t) {
    if (e.childNodes.length > 0) {
      const a = e.childNodes[e.childNodes.length - 1];
      if (er.isTextNode(a)) {
        a.value += t;
        return;
      }
    }
    er.appendChild(e, ol(t));
  },
  insertTextBefore(e, t, a) {
    const r = e.childNodes[e.childNodes.indexOf(a) - 1];
    r && er.isTextNode(r) ? r.value += t : er.insertBefore(e, ol(t), a);
  },
  adoptAttributes(e, t) {
    const a = new Set(e.attrs.map((r) => r.name));
    for (let r = 0; r < t.length; r++)
      a.has(t[r].name) || e.attrs.push(t[r]);
  },
  //Tree traversing
  getFirstChild(e) {
    return e.childNodes[0];
  },
  getChildNodes(e) {
    return e.childNodes;
  },
  getParentNode(e) {
    return e.parentNode;
  },
  getAttrList(e) {
    return e.attrs;
  },
  //Node data
  getTagName(e) {
    return e.tagName;
  },
  getNamespaceURI(e) {
    return e.namespaceURI;
  },
  getTextNodeContent(e) {
    return e.value;
  },
  getCommentNodeContent(e) {
    return e.data;
  },
  getDocumentTypeNodeName(e) {
    return e.name;
  },
  getDocumentTypeNodePublicId(e) {
    return e.publicId;
  },
  getDocumentTypeNodeSystemId(e) {
    return e.systemId;
  },
  //Node types
  isTextNode(e) {
    return e.nodeName === "#text";
  },
  isCommentNode(e) {
    return e.nodeName === "#comment";
  },
  isDocumentTypeNode(e) {
    return e.nodeName === "#documentType";
  },
  isElementNode(e) {
    return Object.prototype.hasOwnProperty.call(e, "tagName");
  },
  // Source code location
  setNodeSourceCodeLocation(e, t) {
    e.sourceCodeLocation = t;
  },
  getNodeSourceCodeLocation(e) {
    return e.sourceCodeLocation;
  },
  updateNodeSourceCodeLocation(e, t) {
    e.sourceCodeLocation = { ...e.sourceCodeLocation, ...t };
  }
}, K0 = "html", WU = "about:legacy-compat", $U = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd", J0 = [
  "+//silmaril//dtd html pro v0r11 19970101//",
  "-//as//dtd html 3.0 aswedit + extensions//",
  "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
  "-//ietf//dtd html 2.0 level 1//",
  "-//ietf//dtd html 2.0 level 2//",
  "-//ietf//dtd html 2.0 strict level 1//",
  "-//ietf//dtd html 2.0 strict level 2//",
  "-//ietf//dtd html 2.0 strict//",
  "-//ietf//dtd html 2.0//",
  "-//ietf//dtd html 2.1e//",
  "-//ietf//dtd html 3.0//",
  "-//ietf//dtd html 3.2 final//",
  "-//ietf//dtd html 3.2//",
  "-//ietf//dtd html 3//",
  "-//ietf//dtd html level 0//",
  "-//ietf//dtd html level 1//",
  "-//ietf//dtd html level 2//",
  "-//ietf//dtd html level 3//",
  "-//ietf//dtd html strict level 0//",
  "-//ietf//dtd html strict level 1//",
  "-//ietf//dtd html strict level 2//",
  "-//ietf//dtd html strict level 3//",
  "-//ietf//dtd html strict//",
  "-//ietf//dtd html//",
  "-//metrius//dtd metrius presentational//",
  "-//microsoft//dtd internet explorer 2.0 html strict//",
  "-//microsoft//dtd internet explorer 2.0 html//",
  "-//microsoft//dtd internet explorer 2.0 tables//",
  "-//microsoft//dtd internet explorer 3.0 html strict//",
  "-//microsoft//dtd internet explorer 3.0 html//",
  "-//microsoft//dtd internet explorer 3.0 tables//",
  "-//netscape comm. corp.//dtd html//",
  "-//netscape comm. corp.//dtd strict html//",
  "-//o'reilly and associates//dtd html 2.0//",
  "-//o'reilly and associates//dtd html extended 1.0//",
  "-//o'reilly and associates//dtd html extended relaxed 1.0//",
  "-//sq//dtd html 2.0 hotmetal + extensions//",
  "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
  "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
  "-//spyglass//dtd html 2.0 extended//",
  "-//sun microsystems corp.//dtd hotjava html//",
  "-//sun microsystems corp.//dtd hotjava strict html//",
  "-//w3c//dtd html 3 1995-03-24//",
  "-//w3c//dtd html 3.2 draft//",
  "-//w3c//dtd html 3.2 final//",
  "-//w3c//dtd html 3.2//",
  "-//w3c//dtd html 3.2s draft//",
  "-//w3c//dtd html 4.0 frameset//",
  "-//w3c//dtd html 4.0 transitional//",
  "-//w3c//dtd html experimental 19960712//",
  "-//w3c//dtd html experimental 970421//",
  "-//w3c//dtd w3 html//",
  "-//w3o//dtd w3 html 3.0//",
  "-//webtechs//dtd mozilla html 2.0//",
  "-//webtechs//dtd mozilla html//"
], XU = [
  ...J0,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
], QU = /* @__PURE__ */ new Set([
  "-//w3o//dtd w3 html strict 3.0//en//",
  "-/w3c/dtd html 4.0 transitional/en",
  "html"
]), Z0 = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"], KU = [
  ...Z0,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
function cl(e, t) {
  return t.some((a) => e.startsWith(a));
}
function JU(e) {
  return e.name === K0 && e.publicId === null && (e.systemId === null || e.systemId === WU);
}
function ZU(e) {
  if (e.name !== K0)
    return Nt.QUIRKS;
  const { systemId: t } = e;
  if (t && t.toLowerCase() === $U)
    return Nt.QUIRKS;
  let { publicId: a } = e;
  if (a !== null) {
    if (a = a.toLowerCase(), QU.has(a))
      return Nt.QUIRKS;
    let r = t === null ? XU : J0;
    if (cl(a, r))
      return Nt.QUIRKS;
    if (r = t === null ? Z0 : KU, cl(a, r))
      return Nt.LIMITED_QUIRKS;
  }
  return Nt.NO_QUIRKS;
}
const ll = {
  TEXT_HTML: "text/html",
  APPLICATION_XML: "application/xhtml+xml"
}, ej = "definitionurl", tj = "definitionURL", aj = new Map([
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((e) => [e.toLowerCase(), e])), rj = /* @__PURE__ */ new Map([
  ["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: Y.XLINK }],
  ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: Y.XLINK }],
  ["xlink:href", { prefix: "xlink", name: "href", namespace: Y.XLINK }],
  ["xlink:role", { prefix: "xlink", name: "role", namespace: Y.XLINK }],
  ["xlink:show", { prefix: "xlink", name: "show", namespace: Y.XLINK }],
  ["xlink:title", { prefix: "xlink", name: "title", namespace: Y.XLINK }],
  ["xlink:type", { prefix: "xlink", name: "type", namespace: Y.XLINK }],
  ["xml:base", { prefix: "xml", name: "base", namespace: Y.XML }],
  ["xml:lang", { prefix: "xml", name: "lang", namespace: Y.XML }],
  ["xml:space", { prefix: "xml", name: "space", namespace: Y.XML }],
  ["xmlns", { prefix: "", name: "xmlns", namespace: Y.XMLNS }],
  ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: Y.XMLNS }]
]), nj = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((e) => [e.toLowerCase(), e])), sj = /* @__PURE__ */ new Set([
  l.B,
  l.BIG,
  l.BLOCKQUOTE,
  l.BODY,
  l.BR,
  l.CENTER,
  l.CODE,
  l.DD,
  l.DIV,
  l.DL,
  l.DT,
  l.EM,
  l.EMBED,
  l.H1,
  l.H2,
  l.H3,
  l.H4,
  l.H5,
  l.H6,
  l.HEAD,
  l.HR,
  l.I,
  l.IMG,
  l.LI,
  l.LISTING,
  l.MENU,
  l.META,
  l.NOBR,
  l.OL,
  l.P,
  l.PRE,
  l.RUBY,
  l.S,
  l.SMALL,
  l.SPAN,
  l.STRONG,
  l.STRIKE,
  l.SUB,
  l.SUP,
  l.TABLE,
  l.TT,
  l.U,
  l.UL,
  l.VAR
]);
function ij(e) {
  const t = e.tagID;
  return t === l.FONT && e.attrs.some(({ name: r }) => r === Aa.COLOR || r === Aa.SIZE || r === Aa.FACE) || sj.has(t);
}
function ef(e) {
  for (let t = 0; t < e.attrs.length; t++)
    if (e.attrs[t].name === ej) {
      e.attrs[t].name = tj;
      break;
    }
}
function tf(e) {
  for (let t = 0; t < e.attrs.length; t++) {
    const a = aj.get(e.attrs[t].name);
    a != null && (e.attrs[t].name = a);
  }
}
function no(e) {
  for (let t = 0; t < e.attrs.length; t++) {
    const a = rj.get(e.attrs[t].name);
    a && (e.attrs[t].prefix = a.prefix, e.attrs[t].name = a.name, e.attrs[t].namespace = a.namespace);
  }
}
function oj(e) {
  const t = nj.get(e.tagName);
  t != null && (e.tagName = t, e.tagID = dr(e.tagName));
}
function cj(e, t) {
  return t === Y.MATHML && (e === l.MI || e === l.MO || e === l.MN || e === l.MS || e === l.MTEXT);
}
function lj(e, t, a) {
  if (t === Y.MATHML && e === l.ANNOTATION_XML) {
    for (let r = 0; r < a.length; r++)
      if (a[r].name === Aa.ENCODING) {
        const n = a[r].value.toLowerCase();
        return n === ll.TEXT_HTML || n === ll.APPLICATION_XML;
      }
  }
  return t === Y.SVG && (e === l.FOREIGN_OBJECT || e === l.DESC || e === l.TITLE);
}
function uj(e, t, a, r) {
  return (!r || r === Y.HTML) && lj(e, t, a) || (!r || r === Y.MATHML) && cj(e, t);
}
const fj = "hidden", hj = 8, dj = 3;
var D;
(function(e) {
  e[e.INITIAL = 0] = "INITIAL", e[e.BEFORE_HTML = 1] = "BEFORE_HTML", e[e.BEFORE_HEAD = 2] = "BEFORE_HEAD", e[e.IN_HEAD = 3] = "IN_HEAD", e[e.IN_HEAD_NO_SCRIPT = 4] = "IN_HEAD_NO_SCRIPT", e[e.AFTER_HEAD = 5] = "AFTER_HEAD", e[e.IN_BODY = 6] = "IN_BODY", e[e.TEXT = 7] = "TEXT", e[e.IN_TABLE = 8] = "IN_TABLE", e[e.IN_TABLE_TEXT = 9] = "IN_TABLE_TEXT", e[e.IN_CAPTION = 10] = "IN_CAPTION", e[e.IN_COLUMN_GROUP = 11] = "IN_COLUMN_GROUP", e[e.IN_TABLE_BODY = 12] = "IN_TABLE_BODY", e[e.IN_ROW = 13] = "IN_ROW", e[e.IN_CELL = 14] = "IN_CELL", e[e.IN_SELECT = 15] = "IN_SELECT", e[e.IN_SELECT_IN_TABLE = 16] = "IN_SELECT_IN_TABLE", e[e.IN_TEMPLATE = 17] = "IN_TEMPLATE", e[e.AFTER_BODY = 18] = "AFTER_BODY", e[e.IN_FRAMESET = 19] = "IN_FRAMESET", e[e.AFTER_FRAMESET = 20] = "AFTER_FRAMESET", e[e.AFTER_AFTER_BODY = 21] = "AFTER_AFTER_BODY", e[e.AFTER_AFTER_FRAMESET = 22] = "AFTER_AFTER_FRAMESET";
})(D || (D = {}));
const mj = {
  startLine: -1,
  startCol: -1,
  startOffset: -1,
  endLine: -1,
  endCol: -1,
  endOffset: -1
}, af = /* @__PURE__ */ new Set([l.TABLE, l.TBODY, l.TFOOT, l.THEAD, l.TR]), ul = {
  scriptingEnabled: !0,
  sourceCodeLocationInfo: !1,
  treeAdapter: er,
  onParseError: null
};
class fl {
  constructor(t, a, r = null, n = null) {
    this.fragmentContext = r, this.scriptHandler = n, this.currentToken = null, this.stopped = !1, this.insertionMode = D.INITIAL, this.originalInsertionMode = D.INITIAL, this.headElement = null, this.formElement = null, this.currentNotInHTML = !1, this.tmplInsertionModeStack = [], this.pendingCharacterTokens = [], this.hasNonWhitespacePendingCharacterToken = !1, this.framesetOk = !0, this.skipNextNewLine = !1, this.fosterParentingEnabled = !1, this.options = {
      ...ul,
      ...t
    }, this.treeAdapter = this.options.treeAdapter, this.onParseError = this.options.onParseError, this.onParseError && (this.options.sourceCodeLocationInfo = !0), this.document = a ?? this.treeAdapter.createDocument(), this.tokenizer = new PU(this.options, this), this.activeFormattingElements = new GU(this.treeAdapter), this.fragmentContextID = r ? dr(this.treeAdapter.getTagName(r)) : l.UNKNOWN, this._setContextModes(r ?? this.document, this.fragmentContextID), this.openElements = new VU(this.document, this.treeAdapter, this);
  }
  // API
  static parse(t, a) {
    const r = new this(a);
    return r.tokenizer.write(t, !0), r.document;
  }
  static getFragmentParser(t, a) {
    const r = {
      ...ul,
      ...a
    };
    t ?? (t = r.treeAdapter.createElement(L.TEMPLATE, Y.HTML, []));
    const n = r.treeAdapter.createElement("documentmock", Y.HTML, []), s = new this(r, n, t);
    return s.fragmentContextID === l.TEMPLATE && s.tmplInsertionModeStack.unshift(D.IN_TEMPLATE), s._initTokenizerForFragmentParsing(), s._insertFakeRootElement(), s._resetInsertionMode(), s._findFormInFragmentContext(), s;
  }
  getFragment() {
    const t = this.treeAdapter.getFirstChild(this.document), a = this.treeAdapter.createDocumentFragment();
    return this._adoptNodes(t, a), a;
  }
  //Errors
  _err(t, a, r) {
    var n;
    if (!this.onParseError)
      return;
    const s = (n = t.location) !== null && n !== void 0 ? n : mj, i = {
      code: a,
      startLine: s.startLine,
      startCol: s.startCol,
      startOffset: s.startOffset,
      endLine: r ? s.startLine : s.endLine,
      endCol: r ? s.startCol : s.endCol,
      endOffset: r ? s.startOffset : s.endOffset
    };
    this.onParseError(i);
  }
  //Stack events
  onItemPush(t, a, r) {
    var n, s;
    (s = (n = this.treeAdapter).onItemPush) === null || s === void 0 || s.call(n, t), r && this.openElements.stackTop > 0 && this._setContextModes(t, a);
  }
  onItemPop(t, a) {
    var r, n;
    if (this.options.sourceCodeLocationInfo && this._setEndLocation(t, this.currentToken), (n = (r = this.treeAdapter).onItemPop) === null || n === void 0 || n.call(r, t, this.openElements.current), a) {
      let s, i;
      this.openElements.stackTop === 0 && this.fragmentContext ? (s = this.fragmentContext, i = this.fragmentContextID) : { current: s, currentTagId: i } = this.openElements, this._setContextModes(s, i);
    }
  }
  _setContextModes(t, a) {
    const r = t === this.document || this.treeAdapter.getNamespaceURI(t) === Y.HTML;
    this.currentNotInHTML = !r, this.tokenizer.inForeignNode = !r && !this._isIntegrationPoint(a, t);
  }
  _switchToTextParsing(t, a) {
    this._insertElement(t, Y.HTML), this.tokenizer.state = a, this.originalInsertionMode = this.insertionMode, this.insertionMode = D.TEXT;
  }
  switchToPlaintextParsing() {
    this.insertionMode = D.TEXT, this.originalInsertionMode = D.IN_BODY, this.tokenizer.state = Xe.PLAINTEXT;
  }
  //Fragment parsing
  _getAdjustedCurrentElement() {
    return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
  }
  _findFormInFragmentContext() {
    let t = this.fragmentContext;
    for (; t; ) {
      if (this.treeAdapter.getTagName(t) === L.FORM) {
        this.formElement = t;
        break;
      }
      t = this.treeAdapter.getParentNode(t);
    }
  }
  _initTokenizerForFragmentParsing() {
    if (!(!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== Y.HTML))
      switch (this.fragmentContextID) {
        case l.TITLE:
        case l.TEXTAREA: {
          this.tokenizer.state = Xe.RCDATA;
          break;
        }
        case l.STYLE:
        case l.XMP:
        case l.IFRAME:
        case l.NOEMBED:
        case l.NOFRAMES:
        case l.NOSCRIPT: {
          this.tokenizer.state = Xe.RAWTEXT;
          break;
        }
        case l.SCRIPT: {
          this.tokenizer.state = Xe.SCRIPT_DATA;
          break;
        }
        case l.PLAINTEXT: {
          this.tokenizer.state = Xe.PLAINTEXT;
          break;
        }
      }
  }
  //Tree mutation
  _setDocumentType(t) {
    const a = t.name || "", r = t.publicId || "", n = t.systemId || "";
    if (this.treeAdapter.setDocumentType(this.document, a, r, n), t.location) {
      const i = this.treeAdapter.getChildNodes(this.document).find((o) => this.treeAdapter.isDocumentTypeNode(o));
      i && this.treeAdapter.setNodeSourceCodeLocation(i, t.location);
    }
  }
  _attachElementToTree(t, a) {
    if (this.options.sourceCodeLocationInfo) {
      const r = a && {
        ...a,
        startTag: a
      };
      this.treeAdapter.setNodeSourceCodeLocation(t, r);
    }
    if (this._shouldFosterParentOnInsertion())
      this._fosterParentElement(t);
    else {
      const r = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.appendChild(r, t);
    }
  }
  _appendElement(t, a) {
    const r = this.treeAdapter.createElement(t.tagName, a, t.attrs);
    this._attachElementToTree(r, t.location);
  }
  _insertElement(t, a) {
    const r = this.treeAdapter.createElement(t.tagName, a, t.attrs);
    this._attachElementToTree(r, t.location), this.openElements.push(r, t.tagID);
  }
  _insertFakeElement(t, a) {
    const r = this.treeAdapter.createElement(t, Y.HTML, []);
    this._attachElementToTree(r, null), this.openElements.push(r, a);
  }
  _insertTemplate(t) {
    const a = this.treeAdapter.createElement(t.tagName, Y.HTML, t.attrs), r = this.treeAdapter.createDocumentFragment();
    this.treeAdapter.setTemplateContent(a, r), this._attachElementToTree(a, t.location), this.openElements.push(a, t.tagID), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r, null);
  }
  _insertFakeRootElement() {
    const t = this.treeAdapter.createElement(L.HTML, Y.HTML, []);
    this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(t, null), this.treeAdapter.appendChild(this.openElements.current, t), this.openElements.push(t, l.HTML);
  }
  _appendCommentNode(t, a) {
    const r = this.treeAdapter.createCommentNode(t.data);
    this.treeAdapter.appendChild(a, r), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r, t.location);
  }
  _insertCharacters(t) {
    let a, r;
    if (this._shouldFosterParentOnInsertion() ? ({ parent: a, beforeElement: r } = this._findFosterParentingLocation(), r ? this.treeAdapter.insertTextBefore(a, t.chars, r) : this.treeAdapter.insertText(a, t.chars)) : (a = this.openElements.currentTmplContentOrNode, this.treeAdapter.insertText(a, t.chars)), !t.location)
      return;
    const n = this.treeAdapter.getChildNodes(a), s = r ? n.lastIndexOf(r) : n.length, i = n[s - 1];
    if (this.treeAdapter.getNodeSourceCodeLocation(i)) {
      const { endLine: c, endCol: u, endOffset: d } = t.location;
      this.treeAdapter.updateNodeSourceCodeLocation(i, { endLine: c, endCol: u, endOffset: d });
    } else this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(i, t.location);
  }
  _adoptNodes(t, a) {
    for (let r = this.treeAdapter.getFirstChild(t); r; r = this.treeAdapter.getFirstChild(t))
      this.treeAdapter.detachNode(r), this.treeAdapter.appendChild(a, r);
  }
  _setEndLocation(t, a) {
    if (this.treeAdapter.getNodeSourceCodeLocation(t) && a.location) {
      const r = a.location, n = this.treeAdapter.getTagName(t), s = (
        // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
        // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
        a.type === ve.END_TAG && n === a.tagName ? {
          endTag: { ...r },
          endLine: r.endLine,
          endCol: r.endCol,
          endOffset: r.endOffset
        } : {
          endLine: r.startLine,
          endCol: r.startCol,
          endOffset: r.startOffset
        }
      );
      this.treeAdapter.updateNodeSourceCodeLocation(t, s);
    }
  }
  //Token processing
  shouldProcessStartTagTokenInForeignContent(t) {
    if (!this.currentNotInHTML)
      return !1;
    let a, r;
    return this.openElements.stackTop === 0 && this.fragmentContext ? (a = this.fragmentContext, r = this.fragmentContextID) : { current: a, currentTagId: r } = this.openElements, t.tagID === l.SVG && this.treeAdapter.getTagName(a) === L.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(a) === Y.MATHML ? !1 : (
      // Check that `current` is not an integration point for HTML or MathML elements.
      this.tokenizer.inForeignNode || // If it _is_ an integration point, then we might have to check that it is not an HTML
      // integration point.
      (t.tagID === l.MGLYPH || t.tagID === l.MALIGNMARK) && !this._isIntegrationPoint(r, a, Y.HTML)
    );
  }
  _processToken(t) {
    switch (t.type) {
      case ve.CHARACTER: {
        this.onCharacter(t);
        break;
      }
      case ve.NULL_CHARACTER: {
        this.onNullCharacter(t);
        break;
      }
      case ve.COMMENT: {
        this.onComment(t);
        break;
      }
      case ve.DOCTYPE: {
        this.onDoctype(t);
        break;
      }
      case ve.START_TAG: {
        this._processStartTag(t);
        break;
      }
      case ve.END_TAG: {
        this.onEndTag(t);
        break;
      }
      case ve.EOF: {
        this.onEof(t);
        break;
      }
      case ve.WHITESPACE_CHARACTER: {
        this.onWhitespaceCharacter(t);
        break;
      }
    }
  }
  //Integration points
  _isIntegrationPoint(t, a, r) {
    const n = this.treeAdapter.getNamespaceURI(a), s = this.treeAdapter.getAttrList(a);
    return uj(t, n, s, r);
  }
  //Active formatting elements reconstruction
  _reconstructActiveFormattingElements() {
    const t = this.activeFormattingElements.entries.length;
    if (t) {
      const a = this.activeFormattingElements.entries.findIndex((n) => n.type === Vt.Marker || this.openElements.contains(n.element)), r = a < 0 ? t - 1 : a - 1;
      for (let n = r; n >= 0; n--) {
        const s = this.activeFormattingElements.entries[n];
        this._insertElement(s.token, this.treeAdapter.getNamespaceURI(s.element)), s.element = this.openElements.current;
      }
    }
  }
  //Close elements
  _closeTableCell() {
    this.openElements.generateImpliedEndTags(), this.openElements.popUntilTableCellPopped(), this.activeFormattingElements.clearToLastMarker(), this.insertionMode = D.IN_ROW;
  }
  _closePElement() {
    this.openElements.generateImpliedEndTagsWithExclusion(l.P), this.openElements.popUntilTagNamePopped(l.P);
  }
  //Insertion modes
  _resetInsertionMode() {
    for (let t = this.openElements.stackTop; t >= 0; t--)
      switch (t === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[t]) {
        case l.TR: {
          this.insertionMode = D.IN_ROW;
          return;
        }
        case l.TBODY:
        case l.THEAD:
        case l.TFOOT: {
          this.insertionMode = D.IN_TABLE_BODY;
          return;
        }
        case l.CAPTION: {
          this.insertionMode = D.IN_CAPTION;
          return;
        }
        case l.COLGROUP: {
          this.insertionMode = D.IN_COLUMN_GROUP;
          return;
        }
        case l.TABLE: {
          this.insertionMode = D.IN_TABLE;
          return;
        }
        case l.BODY: {
          this.insertionMode = D.IN_BODY;
          return;
        }
        case l.FRAMESET: {
          this.insertionMode = D.IN_FRAMESET;
          return;
        }
        case l.SELECT: {
          this._resetInsertionModeForSelect(t);
          return;
        }
        case l.TEMPLATE: {
          this.insertionMode = this.tmplInsertionModeStack[0];
          return;
        }
        case l.HTML: {
          this.insertionMode = this.headElement ? D.AFTER_HEAD : D.BEFORE_HEAD;
          return;
        }
        case l.TD:
        case l.TH: {
          if (t > 0) {
            this.insertionMode = D.IN_CELL;
            return;
          }
          break;
        }
        case l.HEAD: {
          if (t > 0) {
            this.insertionMode = D.IN_HEAD;
            return;
          }
          break;
        }
      }
    this.insertionMode = D.IN_BODY;
  }
  _resetInsertionModeForSelect(t) {
    if (t > 0)
      for (let a = t - 1; a > 0; a--) {
        const r = this.openElements.tagIDs[a];
        if (r === l.TEMPLATE)
          break;
        if (r === l.TABLE) {
          this.insertionMode = D.IN_SELECT_IN_TABLE;
          return;
        }
      }
    this.insertionMode = D.IN_SELECT;
  }
  //Foster parenting
  _isElementCausesFosterParenting(t) {
    return af.has(t);
  }
  _shouldFosterParentOnInsertion() {
    return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.currentTagId);
  }
  _findFosterParentingLocation() {
    for (let t = this.openElements.stackTop; t >= 0; t--) {
      const a = this.openElements.items[t];
      switch (this.openElements.tagIDs[t]) {
        case l.TEMPLATE: {
          if (this.treeAdapter.getNamespaceURI(a) === Y.HTML)
            return { parent: this.treeAdapter.getTemplateContent(a), beforeElement: null };
          break;
        }
        case l.TABLE: {
          const r = this.treeAdapter.getParentNode(a);
          return r ? { parent: r, beforeElement: a } : { parent: this.openElements.items[t - 1], beforeElement: null };
        }
      }
    }
    return { parent: this.openElements.items[0], beforeElement: null };
  }
  _fosterParentElement(t) {
    const a = this._findFosterParentingLocation();
    a.beforeElement ? this.treeAdapter.insertBefore(a.parent, t, a.beforeElement) : this.treeAdapter.appendChild(a.parent, t);
  }
  //Special elements
  _isSpecialElement(t, a) {
    const r = this.treeAdapter.getNamespaceURI(t);
    return FU[r].has(a);
  }
  onCharacter(t) {
    if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) {
      Yq(this, t);
      return;
    }
    switch (this.insertionMode) {
      case D.INITIAL: {
        Sr(this, t);
        break;
      }
      case D.BEFORE_HTML: {
        Hr(this, t);
        break;
      }
      case D.BEFORE_HEAD: {
        Ur(this, t);
        break;
      }
      case D.IN_HEAD: {
        jr(this, t);
        break;
      }
      case D.IN_HEAD_NO_SCRIPT: {
        qr(this, t);
        break;
      }
      case D.AFTER_HEAD: {
        Yr(this, t);
        break;
      }
      case D.IN_BODY:
      case D.IN_CAPTION:
      case D.IN_CELL:
      case D.IN_TEMPLATE: {
        nf(this, t);
        break;
      }
      case D.TEXT:
      case D.IN_SELECT:
      case D.IN_SELECT_IN_TABLE: {
        this._insertCharacters(t);
        break;
      }
      case D.IN_TABLE:
      case D.IN_TABLE_BODY:
      case D.IN_ROW: {
        Ys(this, t);
        break;
      }
      case D.IN_TABLE_TEXT: {
        ff(this, t);
        break;
      }
      case D.IN_COLUMN_GROUP: {
        Mn(this, t);
        break;
      }
      case D.AFTER_BODY: {
        Bn(this, t);
        break;
      }
      case D.AFTER_AFTER_BODY: {
        Dn(this, t);
        break;
      }
    }
  }
  onNullCharacter(t) {
    if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) {
      qq(this, t);
      return;
    }
    switch (this.insertionMode) {
      case D.INITIAL: {
        Sr(this, t);
        break;
      }
      case D.BEFORE_HTML: {
        Hr(this, t);
        break;
      }
      case D.BEFORE_HEAD: {
        Ur(this, t);
        break;
      }
      case D.IN_HEAD: {
        jr(this, t);
        break;
      }
      case D.IN_HEAD_NO_SCRIPT: {
        qr(this, t);
        break;
      }
      case D.AFTER_HEAD: {
        Yr(this, t);
        break;
      }
      case D.TEXT: {
        this._insertCharacters(t);
        break;
      }
      case D.IN_TABLE:
      case D.IN_TABLE_BODY:
      case D.IN_ROW: {
        Ys(this, t);
        break;
      }
      case D.IN_COLUMN_GROUP: {
        Mn(this, t);
        break;
      }
      case D.AFTER_BODY: {
        Bn(this, t);
        break;
      }
      case D.AFTER_AFTER_BODY: {
        Dn(this, t);
        break;
      }
    }
  }
  onComment(t) {
    if (this.skipNextNewLine = !1, this.currentNotInHTML) {
      yi(this, t);
      return;
    }
    switch (this.insertionMode) {
      case D.INITIAL:
      case D.BEFORE_HTML:
      case D.BEFORE_HEAD:
      case D.IN_HEAD:
      case D.IN_HEAD_NO_SCRIPT:
      case D.AFTER_HEAD:
      case D.IN_BODY:
      case D.IN_TABLE:
      case D.IN_CAPTION:
      case D.IN_COLUMN_GROUP:
      case D.IN_TABLE_BODY:
      case D.IN_ROW:
      case D.IN_CELL:
      case D.IN_SELECT:
      case D.IN_SELECT_IN_TABLE:
      case D.IN_TEMPLATE:
      case D.IN_FRAMESET:
      case D.AFTER_FRAMESET: {
        yi(this, t);
        break;
      }
      case D.IN_TABLE_TEXT: {
        zr(this, t);
        break;
      }
      case D.AFTER_BODY: {
        wj(this, t);
        break;
      }
      case D.AFTER_AFTER_BODY:
      case D.AFTER_AFTER_FRAMESET: {
        Ej(this, t);
        break;
      }
    }
  }
  onDoctype(t) {
    switch (this.skipNextNewLine = !1, this.insertionMode) {
      case D.INITIAL: {
        Tj(this, t);
        break;
      }
      case D.BEFORE_HEAD:
      case D.IN_HEAD:
      case D.IN_HEAD_NO_SCRIPT:
      case D.AFTER_HEAD: {
        this._err(t, j.misplacedDoctype);
        break;
      }
      case D.IN_TABLE_TEXT: {
        zr(this, t);
        break;
      }
    }
  }
  onStartTag(t) {
    this.skipNextNewLine = !1, this.currentToken = t, this._processStartTag(t), t.selfClosing && !t.ackSelfClosing && this._err(t, j.nonVoidHtmlElementStartTagWithTrailingSolidus);
  }
  /**
   * Processes a given start tag.
   *
   * `onStartTag` checks if a self-closing tag was recognized. When a token
   * is moved inbetween multiple insertion modes, this check for self-closing
   * could lead to false positives. To avoid this, `_processStartTag` is used
   * for nested calls.
   *
   * @param token The token to process.
   */
  _processStartTag(t) {
    this.shouldProcessStartTagTokenInForeignContent(t) ? Vq(this, t) : this._startTagOutsideForeignContent(t);
  }
  _startTagOutsideForeignContent(t) {
    switch (this.insertionMode) {
      case D.INITIAL: {
        Sr(this, t);
        break;
      }
      case D.BEFORE_HTML: {
        vj(this, t);
        break;
      }
      case D.BEFORE_HEAD: {
        Aj(this, t);
        break;
      }
      case D.IN_HEAD: {
        Wt(this, t);
        break;
      }
      case D.IN_HEAD_NO_SCRIPT: {
        Sj(this, t);
        break;
      }
      case D.AFTER_HEAD: {
        Nj(this, t);
        break;
      }
      case D.IN_BODY: {
        dt(this, t);
        break;
      }
      case D.IN_TABLE: {
        sr(this, t);
        break;
      }
      case D.IN_TABLE_TEXT: {
        zr(this, t);
        break;
      }
      case D.IN_CAPTION: {
        Dq(this, t);
        break;
      }
      case D.IN_COLUMN_GROUP: {
        oo(this, t);
        break;
      }
      case D.IN_TABLE_BODY: {
        ts(this, t);
        break;
      }
      case D.IN_ROW: {
        as(this, t);
        break;
      }
      case D.IN_CELL: {
        zq(this, t);
        break;
      }
      case D.IN_SELECT: {
        mf(this, t);
        break;
      }
      case D.IN_SELECT_IN_TABLE: {
        Iq(this, t);
        break;
      }
      case D.IN_TEMPLATE: {
        Fq(this, t);
        break;
      }
      case D.AFTER_BODY: {
        Lq(this, t);
        break;
      }
      case D.IN_FRAMESET: {
        Mq(this, t);
        break;
      }
      case D.AFTER_FRAMESET: {
        Pq(this, t);
        break;
      }
      case D.AFTER_AFTER_BODY: {
        Uq(this, t);
        break;
      }
      case D.AFTER_AFTER_FRAMESET: {
        jq(this, t);
        break;
      }
    }
  }
  onEndTag(t) {
    this.skipNextNewLine = !1, this.currentToken = t, this.currentNotInHTML ? Gq(this, t) : this._endTagOutsideForeignContent(t);
  }
  _endTagOutsideForeignContent(t) {
    switch (this.insertionMode) {
      case D.INITIAL: {
        Sr(this, t);
        break;
      }
      case D.BEFORE_HTML: {
        xj(this, t);
        break;
      }
      case D.BEFORE_HEAD: {
        Dj(this, t);
        break;
      }
      case D.IN_HEAD: {
        Cj(this, t);
        break;
      }
      case D.IN_HEAD_NO_SCRIPT: {
        zj(this, t);
        break;
      }
      case D.AFTER_HEAD: {
        Ij(this, t);
        break;
      }
      case D.IN_BODY: {
        es(this, t);
        break;
      }
      case D.TEXT: {
        yq(this, t);
        break;
      }
      case D.IN_TABLE: {
        Xr(this, t);
        break;
      }
      case D.IN_TABLE_TEXT: {
        zr(this, t);
        break;
      }
      case D.IN_CAPTION: {
        Cq(this, t);
        break;
      }
      case D.IN_COLUMN_GROUP: {
        Sq(this, t);
        break;
      }
      case D.IN_TABLE_BODY: {
        _i(this, t);
        break;
      }
      case D.IN_ROW: {
        df(this, t);
        break;
      }
      case D.IN_CELL: {
        Nq(this, t);
        break;
      }
      case D.IN_SELECT: {
        pf(this, t);
        break;
      }
      case D.IN_SELECT_IN_TABLE: {
        Rq(this, t);
        break;
      }
      case D.IN_TEMPLATE: {
        Oq(this, t);
        break;
      }
      case D.AFTER_BODY: {
        yf(this, t);
        break;
      }
      case D.IN_FRAMESET: {
        Bq(this, t);
        break;
      }
      case D.AFTER_FRAMESET: {
        Hq(this, t);
        break;
      }
      case D.AFTER_AFTER_BODY: {
        Dn(this, t);
        break;
      }
    }
  }
  onEof(t) {
    switch (this.insertionMode) {
      case D.INITIAL: {
        Sr(this, t);
        break;
      }
      case D.BEFORE_HTML: {
        Hr(this, t);
        break;
      }
      case D.BEFORE_HEAD: {
        Ur(this, t);
        break;
      }
      case D.IN_HEAD: {
        jr(this, t);
        break;
      }
      case D.IN_HEAD_NO_SCRIPT: {
        qr(this, t);
        break;
      }
      case D.AFTER_HEAD: {
        Yr(this, t);
        break;
      }
      case D.IN_BODY:
      case D.IN_TABLE:
      case D.IN_CAPTION:
      case D.IN_COLUMN_GROUP:
      case D.IN_TABLE_BODY:
      case D.IN_ROW:
      case D.IN_CELL:
      case D.IN_SELECT:
      case D.IN_SELECT_IN_TABLE: {
        lf(this, t);
        break;
      }
      case D.TEXT: {
        _q(this, t);
        break;
      }
      case D.IN_TABLE_TEXT: {
        zr(this, t);
        break;
      }
      case D.IN_TEMPLATE: {
        gf(this, t);
        break;
      }
      case D.AFTER_BODY:
      case D.IN_FRAMESET:
      case D.AFTER_FRAMESET:
      case D.AFTER_AFTER_BODY:
      case D.AFTER_AFTER_FRAMESET: {
        io(this, t);
        break;
      }
    }
  }
  onWhitespaceCharacter(t) {
    if (this.skipNextNewLine && (this.skipNextNewLine = !1, t.chars.charCodeAt(0) === E.LINE_FEED)) {
      if (t.chars.length === 1)
        return;
      t.chars = t.chars.substr(1);
    }
    if (this.tokenizer.inForeignNode) {
      this._insertCharacters(t);
      return;
    }
    switch (this.insertionMode) {
      case D.IN_HEAD:
      case D.IN_HEAD_NO_SCRIPT:
      case D.AFTER_HEAD:
      case D.TEXT:
      case D.IN_COLUMN_GROUP:
      case D.IN_SELECT:
      case D.IN_SELECT_IN_TABLE:
      case D.IN_FRAMESET:
      case D.AFTER_FRAMESET: {
        this._insertCharacters(t);
        break;
      }
      case D.IN_BODY:
      case D.IN_CAPTION:
      case D.IN_CELL:
      case D.IN_TEMPLATE:
      case D.AFTER_BODY:
      case D.AFTER_AFTER_BODY:
      case D.AFTER_AFTER_FRAMESET: {
        rf(this, t);
        break;
      }
      case D.IN_TABLE:
      case D.IN_TABLE_BODY:
      case D.IN_ROW: {
        Ys(this, t);
        break;
      }
      case D.IN_TABLE_TEXT: {
        uf(this, t);
        break;
      }
    }
  }
}
function pj(e, t) {
  let a = e.activeFormattingElements.getElementEntryInScopeWithTagName(t.tagName);
  return a ? e.openElements.contains(a.element) ? e.openElements.hasInScope(t.tagID) || (a = null) : (e.activeFormattingElements.removeEntry(a), a = null) : cf(e, t), a;
}
function gj(e, t) {
  let a = null, r = e.openElements.stackTop;
  for (; r >= 0; r--) {
    const n = e.openElements.items[r];
    if (n === t.element)
      break;
    e._isSpecialElement(n, e.openElements.tagIDs[r]) && (a = n);
  }
  return a || (e.openElements.shortenToLength(r < 0 ? 0 : r), e.activeFormattingElements.removeEntry(t)), a;
}
function yj(e, t, a) {
  let r = t, n = e.openElements.getCommonAncestor(t);
  for (let s = 0, i = n; i !== a; s++, i = n) {
    n = e.openElements.getCommonAncestor(i);
    const o = e.activeFormattingElements.getElementEntry(i), c = o && s >= dj;
    !o || c ? (c && e.activeFormattingElements.removeEntry(o), e.openElements.remove(i)) : (i = _j(e, o), r === t && (e.activeFormattingElements.bookmark = o), e.treeAdapter.detachNode(r), e.treeAdapter.appendChild(i, r), r = i);
  }
  return r;
}
function _j(e, t) {
  const a = e.treeAdapter.getNamespaceURI(t.element), r = e.treeAdapter.createElement(t.token.tagName, a, t.token.attrs);
  return e.openElements.replace(t.element, r), t.element = r, r;
}
function bj(e, t, a) {
  const r = e.treeAdapter.getTagName(t), n = dr(r);
  if (e._isElementCausesFosterParenting(n))
    e._fosterParentElement(a);
  else {
    const s = e.treeAdapter.getNamespaceURI(t);
    n === l.TEMPLATE && s === Y.HTML && (t = e.treeAdapter.getTemplateContent(t)), e.treeAdapter.appendChild(t, a);
  }
}
function kj(e, t, a) {
  const r = e.treeAdapter.getNamespaceURI(a.element), { token: n } = a, s = e.treeAdapter.createElement(n.tagName, r, n.attrs);
  e._adoptNodes(t, s), e.treeAdapter.appendChild(t, s), e.activeFormattingElements.insertElementAfterBookmark(s, n), e.activeFormattingElements.removeEntry(a), e.openElements.remove(a.element), e.openElements.insertAfter(t, s, n.tagID);
}
function so(e, t) {
  for (let a = 0; a < hj; a++) {
    const r = pj(e, t);
    if (!r)
      break;
    const n = gj(e, r);
    if (!n)
      break;
    e.activeFormattingElements.bookmark = r;
    const s = yj(e, n, r.element), i = e.openElements.getCommonAncestor(r.element);
    e.treeAdapter.detachNode(s), i && bj(e, i, s), kj(e, n, r);
  }
}
function yi(e, t) {
  e._appendCommentNode(t, e.openElements.currentTmplContentOrNode);
}
function wj(e, t) {
  e._appendCommentNode(t, e.openElements.items[0]);
}
function Ej(e, t) {
  e._appendCommentNode(t, e.document);
}
function io(e, t) {
  if (e.stopped = !0, t.location) {
    const a = e.fragmentContext ? 0 : 2;
    for (let r = e.openElements.stackTop; r >= a; r--)
      e._setEndLocation(e.openElements.items[r], t);
    if (!e.fragmentContext && e.openElements.stackTop >= 0) {
      const r = e.openElements.items[0], n = e.treeAdapter.getNodeSourceCodeLocation(r);
      if (n && !n.endTag && (e._setEndLocation(r, t), e.openElements.stackTop >= 1)) {
        const s = e.openElements.items[1], i = e.treeAdapter.getNodeSourceCodeLocation(s);
        i && !i.endTag && e._setEndLocation(s, t);
      }
    }
  }
}
function Tj(e, t) {
  e._setDocumentType(t);
  const a = t.forceQuirks ? Nt.QUIRKS : ZU(t);
  JU(t) || e._err(t, j.nonConformingDoctype), e.treeAdapter.setDocumentMode(e.document, a), e.insertionMode = D.BEFORE_HTML;
}
function Sr(e, t) {
  e._err(t, j.missingDoctype, !0), e.treeAdapter.setDocumentMode(e.document, Nt.QUIRKS), e.insertionMode = D.BEFORE_HTML, e._processToken(t);
}
function vj(e, t) {
  t.tagID === l.HTML ? (e._insertElement(t, Y.HTML), e.insertionMode = D.BEFORE_HEAD) : Hr(e, t);
}
function xj(e, t) {
  const a = t.tagID;
  (a === l.HTML || a === l.HEAD || a === l.BODY || a === l.BR) && Hr(e, t);
}
function Hr(e, t) {
  e._insertFakeRootElement(), e.insertionMode = D.BEFORE_HEAD, e._processToken(t);
}
function Aj(e, t) {
  switch (t.tagID) {
    case l.HTML: {
      dt(e, t);
      break;
    }
    case l.HEAD: {
      e._insertElement(t, Y.HTML), e.headElement = e.openElements.current, e.insertionMode = D.IN_HEAD;
      break;
    }
    default:
      Ur(e, t);
  }
}
function Dj(e, t) {
  const a = t.tagID;
  a === l.HEAD || a === l.BODY || a === l.HTML || a === l.BR ? Ur(e, t) : e._err(t, j.endTagWithoutMatchingOpenElement);
}
function Ur(e, t) {
  e._insertFakeElement(L.HEAD, l.HEAD), e.headElement = e.openElements.current, e.insertionMode = D.IN_HEAD, e._processToken(t);
}
function Wt(e, t) {
  switch (t.tagID) {
    case l.HTML: {
      dt(e, t);
      break;
    }
    case l.BASE:
    case l.BASEFONT:
    case l.BGSOUND:
    case l.LINK:
    case l.META: {
      e._appendElement(t, Y.HTML), t.ackSelfClosing = !0;
      break;
    }
    case l.TITLE: {
      e._switchToTextParsing(t, Xe.RCDATA);
      break;
    }
    case l.NOSCRIPT: {
      e.options.scriptingEnabled ? e._switchToTextParsing(t, Xe.RAWTEXT) : (e._insertElement(t, Y.HTML), e.insertionMode = D.IN_HEAD_NO_SCRIPT);
      break;
    }
    case l.NOFRAMES:
    case l.STYLE: {
      e._switchToTextParsing(t, Xe.RAWTEXT);
      break;
    }
    case l.SCRIPT: {
      e._switchToTextParsing(t, Xe.SCRIPT_DATA);
      break;
    }
    case l.TEMPLATE: {
      e._insertTemplate(t), e.activeFormattingElements.insertMarker(), e.framesetOk = !1, e.insertionMode = D.IN_TEMPLATE, e.tmplInsertionModeStack.unshift(D.IN_TEMPLATE);
      break;
    }
    case l.HEAD: {
      e._err(t, j.misplacedStartTagForHeadElement);
      break;
    }
    default:
      jr(e, t);
  }
}
function Cj(e, t) {
  switch (t.tagID) {
    case l.HEAD: {
      e.openElements.pop(), e.insertionMode = D.AFTER_HEAD;
      break;
    }
    case l.BODY:
    case l.BR:
    case l.HTML: {
      jr(e, t);
      break;
    }
    case l.TEMPLATE: {
      Xa(e, t);
      break;
    }
    default:
      e._err(t, j.endTagWithoutMatchingOpenElement);
  }
}
function Xa(e, t) {
  e.openElements.tmplCount > 0 ? (e.openElements.generateImpliedEndTagsThoroughly(), e.openElements.currentTagId !== l.TEMPLATE && e._err(t, j.closingOfElementWithOpenChildElements), e.openElements.popUntilTagNamePopped(l.TEMPLATE), e.activeFormattingElements.clearToLastMarker(), e.tmplInsertionModeStack.shift(), e._resetInsertionMode()) : e._err(t, j.endTagWithoutMatchingOpenElement);
}
function jr(e, t) {
  e.openElements.pop(), e.insertionMode = D.AFTER_HEAD, e._processToken(t);
}
function Sj(e, t) {
  switch (t.tagID) {
    case l.HTML: {
      dt(e, t);
      break;
    }
    case l.BASEFONT:
    case l.BGSOUND:
    case l.HEAD:
    case l.LINK:
    case l.META:
    case l.NOFRAMES:
    case l.STYLE: {
      Wt(e, t);
      break;
    }
    case l.NOSCRIPT: {
      e._err(t, j.nestedNoscriptInHead);
      break;
    }
    default:
      qr(e, t);
  }
}
function zj(e, t) {
  switch (t.tagID) {
    case l.NOSCRIPT: {
      e.openElements.pop(), e.insertionMode = D.IN_HEAD;
      break;
    }
    case l.BR: {
      qr(e, t);
      break;
    }
    default:
      e._err(t, j.endTagWithoutMatchingOpenElement);
  }
}
function qr(e, t) {
  const a = t.type === ve.EOF ? j.openElementsLeftAfterEof : j.disallowedContentInNoscriptInHead;
  e._err(t, a), e.openElements.pop(), e.insertionMode = D.IN_HEAD, e._processToken(t);
}
function Nj(e, t) {
  switch (t.tagID) {
    case l.HTML: {
      dt(e, t);
      break;
    }
    case l.BODY: {
      e._insertElement(t, Y.HTML), e.framesetOk = !1, e.insertionMode = D.IN_BODY;
      break;
    }
    case l.FRAMESET: {
      e._insertElement(t, Y.HTML), e.insertionMode = D.IN_FRAMESET;
      break;
    }
    case l.BASE:
    case l.BASEFONT:
    case l.BGSOUND:
    case l.LINK:
    case l.META:
    case l.NOFRAMES:
    case l.SCRIPT:
    case l.STYLE:
    case l.TEMPLATE:
    case l.TITLE: {
      e._err(t, j.abandonedHeadElementChild), e.openElements.push(e.headElement, l.HEAD), Wt(e, t), e.openElements.remove(e.headElement);
      break;
    }
    case l.HEAD: {
      e._err(t, j.misplacedStartTagForHeadElement);
      break;
    }
    default:
      Yr(e, t);
  }
}
function Ij(e, t) {
  switch (t.tagID) {
    case l.BODY:
    case l.HTML:
    case l.BR: {
      Yr(e, t);
      break;
    }
    case l.TEMPLATE: {
      Xa(e, t);
      break;
    }
    default:
      e._err(t, j.endTagWithoutMatchingOpenElement);
  }
}
function Yr(e, t) {
  e._insertFakeElement(L.BODY, l.BODY), e.insertionMode = D.IN_BODY, Zn(e, t);
}
function Zn(e, t) {
  switch (t.type) {
    case ve.CHARACTER: {
      nf(e, t);
      break;
    }
    case ve.WHITESPACE_CHARACTER: {
      rf(e, t);
      break;
    }
    case ve.COMMENT: {
      yi(e, t);
      break;
    }
    case ve.START_TAG: {
      dt(e, t);
      break;
    }
    case ve.END_TAG: {
      es(e, t);
      break;
    }
    case ve.EOF: {
      lf(e, t);
      break;
    }
  }
}
function rf(e, t) {
  e._reconstructActiveFormattingElements(), e._insertCharacters(t);
}
function nf(e, t) {
  e._reconstructActiveFormattingElements(), e._insertCharacters(t), e.framesetOk = !1;
}
function Rj(e, t) {
  e.openElements.tmplCount === 0 && e.treeAdapter.adoptAttributes(e.openElements.items[0], t.attrs);
}
function Fj(e, t) {
  const a = e.openElements.tryPeekProperlyNestedBodyElement();
  a && e.openElements.tmplCount === 0 && (e.framesetOk = !1, e.treeAdapter.adoptAttributes(a, t.attrs));
}
function Oj(e, t) {
  const a = e.openElements.tryPeekProperlyNestedBodyElement();
  e.framesetOk && a && (e.treeAdapter.detachNode(a), e.openElements.popAllUpToHtmlElement(), e._insertElement(t, Y.HTML), e.insertionMode = D.IN_FRAMESET);
}
function Lj(e, t) {
  e.openElements.hasInButtonScope(l.P) && e._closePElement(), e._insertElement(t, Y.HTML);
}
function Mj(e, t) {
  e.openElements.hasInButtonScope(l.P) && e._closePElement(), G0(e.openElements.currentTagId) && e.openElements.pop(), e._insertElement(t, Y.HTML);
}
function Bj(e, t) {
  e.openElements.hasInButtonScope(l.P) && e._closePElement(), e._insertElement(t, Y.HTML), e.skipNextNewLine = !0, e.framesetOk = !1;
}
function Pj(e, t) {
  const a = e.openElements.tmplCount > 0;
  (!e.formElement || a) && (e.openElements.hasInButtonScope(l.P) && e._closePElement(), e._insertElement(t, Y.HTML), a || (e.formElement = e.openElements.current));
}
function Hj(e, t) {
  e.framesetOk = !1;
  const a = t.tagID;
  for (let r = e.openElements.stackTop; r >= 0; r--) {
    const n = e.openElements.tagIDs[r];
    if (a === l.LI && n === l.LI || (a === l.DD || a === l.DT) && (n === l.DD || n === l.DT)) {
      e.openElements.generateImpliedEndTagsWithExclusion(n), e.openElements.popUntilTagNamePopped(n);
      break;
    }
    if (n !== l.ADDRESS && n !== l.DIV && n !== l.P && e._isSpecialElement(e.openElements.items[r], n))
      break;
  }
  e.openElements.hasInButtonScope(l.P) && e._closePElement(), e._insertElement(t, Y.HTML);
}
function Uj(e, t) {
  e.openElements.hasInButtonScope(l.P) && e._closePElement(), e._insertElement(t, Y.HTML), e.tokenizer.state = Xe.PLAINTEXT;
}
function jj(e, t) {
  e.openElements.hasInScope(l.BUTTON) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(l.BUTTON)), e._reconstructActiveFormattingElements(), e._insertElement(t, Y.HTML), e.framesetOk = !1;
}
function qj(e, t) {
  const a = e.activeFormattingElements.getElementEntryInScopeWithTagName(L.A);
  a && (so(e, t), e.openElements.remove(a.element), e.activeFormattingElements.removeEntry(a)), e._reconstructActiveFormattingElements(), e._insertElement(t, Y.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function Yj(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, Y.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function Vj(e, t) {
  e._reconstructActiveFormattingElements(), e.openElements.hasInScope(l.NOBR) && (so(e, t), e._reconstructActiveFormattingElements()), e._insertElement(t, Y.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function Gj(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, Y.HTML), e.activeFormattingElements.insertMarker(), e.framesetOk = !1;
}
function Wj(e, t) {
  e.treeAdapter.getDocumentMode(e.document) !== Nt.QUIRKS && e.openElements.hasInButtonScope(l.P) && e._closePElement(), e._insertElement(t, Y.HTML), e.framesetOk = !1, e.insertionMode = D.IN_TABLE;
}
function sf(e, t) {
  e._reconstructActiveFormattingElements(), e._appendElement(t, Y.HTML), e.framesetOk = !1, t.ackSelfClosing = !0;
}
function of(e) {
  const t = q0(e, Aa.TYPE);
  return t != null && t.toLowerCase() === fj;
}
function $j(e, t) {
  e._reconstructActiveFormattingElements(), e._appendElement(t, Y.HTML), of(t) || (e.framesetOk = !1), t.ackSelfClosing = !0;
}
function Xj(e, t) {
  e._appendElement(t, Y.HTML), t.ackSelfClosing = !0;
}
function Qj(e, t) {
  e.openElements.hasInButtonScope(l.P) && e._closePElement(), e._appendElement(t, Y.HTML), e.framesetOk = !1, t.ackSelfClosing = !0;
}
function Kj(e, t) {
  t.tagName = L.IMG, t.tagID = l.IMG, sf(e, t);
}
function Jj(e, t) {
  e._insertElement(t, Y.HTML), e.skipNextNewLine = !0, e.tokenizer.state = Xe.RCDATA, e.originalInsertionMode = e.insertionMode, e.framesetOk = !1, e.insertionMode = D.TEXT;
}
function Zj(e, t) {
  e.openElements.hasInButtonScope(l.P) && e._closePElement(), e._reconstructActiveFormattingElements(), e.framesetOk = !1, e._switchToTextParsing(t, Xe.RAWTEXT);
}
function eq(e, t) {
  e.framesetOk = !1, e._switchToTextParsing(t, Xe.RAWTEXT);
}
function hl(e, t) {
  e._switchToTextParsing(t, Xe.RAWTEXT);
}
function tq(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, Y.HTML), e.framesetOk = !1, e.insertionMode = e.insertionMode === D.IN_TABLE || e.insertionMode === D.IN_CAPTION || e.insertionMode === D.IN_TABLE_BODY || e.insertionMode === D.IN_ROW || e.insertionMode === D.IN_CELL ? D.IN_SELECT_IN_TABLE : D.IN_SELECT;
}
function aq(e, t) {
  e.openElements.currentTagId === l.OPTION && e.openElements.pop(), e._reconstructActiveFormattingElements(), e._insertElement(t, Y.HTML);
}
function rq(e, t) {
  e.openElements.hasInScope(l.RUBY) && e.openElements.generateImpliedEndTags(), e._insertElement(t, Y.HTML);
}
function nq(e, t) {
  e.openElements.hasInScope(l.RUBY) && e.openElements.generateImpliedEndTagsWithExclusion(l.RTC), e._insertElement(t, Y.HTML);
}
function sq(e, t) {
  e._reconstructActiveFormattingElements(), ef(t), no(t), t.selfClosing ? e._appendElement(t, Y.MATHML) : e._insertElement(t, Y.MATHML), t.ackSelfClosing = !0;
}
function iq(e, t) {
  e._reconstructActiveFormattingElements(), tf(t), no(t), t.selfClosing ? e._appendElement(t, Y.SVG) : e._insertElement(t, Y.SVG), t.ackSelfClosing = !0;
}
function dl(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, Y.HTML);
}
function dt(e, t) {
  switch (t.tagID) {
    case l.I:
    case l.S:
    case l.B:
    case l.U:
    case l.EM:
    case l.TT:
    case l.BIG:
    case l.CODE:
    case l.FONT:
    case l.SMALL:
    case l.STRIKE:
    case l.STRONG: {
      Yj(e, t);
      break;
    }
    case l.A: {
      qj(e, t);
      break;
    }
    case l.H1:
    case l.H2:
    case l.H3:
    case l.H4:
    case l.H5:
    case l.H6: {
      Mj(e, t);
      break;
    }
    case l.P:
    case l.DL:
    case l.OL:
    case l.UL:
    case l.DIV:
    case l.DIR:
    case l.NAV:
    case l.MAIN:
    case l.MENU:
    case l.ASIDE:
    case l.CENTER:
    case l.FIGURE:
    case l.FOOTER:
    case l.HEADER:
    case l.HGROUP:
    case l.DIALOG:
    case l.DETAILS:
    case l.ADDRESS:
    case l.ARTICLE:
    case l.SECTION:
    case l.SUMMARY:
    case l.FIELDSET:
    case l.BLOCKQUOTE:
    case l.FIGCAPTION: {
      Lj(e, t);
      break;
    }
    case l.LI:
    case l.DD:
    case l.DT: {
      Hj(e, t);
      break;
    }
    case l.BR:
    case l.IMG:
    case l.WBR:
    case l.AREA:
    case l.EMBED:
    case l.KEYGEN: {
      sf(e, t);
      break;
    }
    case l.HR: {
      Qj(e, t);
      break;
    }
    case l.RB:
    case l.RTC: {
      rq(e, t);
      break;
    }
    case l.RT:
    case l.RP: {
      nq(e, t);
      break;
    }
    case l.PRE:
    case l.LISTING: {
      Bj(e, t);
      break;
    }
    case l.XMP: {
      Zj(e, t);
      break;
    }
    case l.SVG: {
      iq(e, t);
      break;
    }
    case l.HTML: {
      Rj(e, t);
      break;
    }
    case l.BASE:
    case l.LINK:
    case l.META:
    case l.STYLE:
    case l.TITLE:
    case l.SCRIPT:
    case l.BGSOUND:
    case l.BASEFONT:
    case l.TEMPLATE: {
      Wt(e, t);
      break;
    }
    case l.BODY: {
      Fj(e, t);
      break;
    }
    case l.FORM: {
      Pj(e, t);
      break;
    }
    case l.NOBR: {
      Vj(e, t);
      break;
    }
    case l.MATH: {
      sq(e, t);
      break;
    }
    case l.TABLE: {
      Wj(e, t);
      break;
    }
    case l.INPUT: {
      $j(e, t);
      break;
    }
    case l.PARAM:
    case l.TRACK:
    case l.SOURCE: {
      Xj(e, t);
      break;
    }
    case l.IMAGE: {
      Kj(e, t);
      break;
    }
    case l.BUTTON: {
      jj(e, t);
      break;
    }
    case l.APPLET:
    case l.OBJECT:
    case l.MARQUEE: {
      Gj(e, t);
      break;
    }
    case l.IFRAME: {
      eq(e, t);
      break;
    }
    case l.SELECT: {
      tq(e, t);
      break;
    }
    case l.OPTION:
    case l.OPTGROUP: {
      aq(e, t);
      break;
    }
    case l.NOEMBED: {
      hl(e, t);
      break;
    }
    case l.FRAMESET: {
      Oj(e, t);
      break;
    }
    case l.TEXTAREA: {
      Jj(e, t);
      break;
    }
    case l.NOSCRIPT: {
      e.options.scriptingEnabled ? hl(e, t) : dl(e, t);
      break;
    }
    case l.PLAINTEXT: {
      Uj(e, t);
      break;
    }
    case l.COL:
    case l.TH:
    case l.TD:
    case l.TR:
    case l.HEAD:
    case l.FRAME:
    case l.TBODY:
    case l.TFOOT:
    case l.THEAD:
    case l.CAPTION:
    case l.COLGROUP:
      break;
    default:
      dl(e, t);
  }
}
function oq(e, t) {
  if (e.openElements.hasInScope(l.BODY) && (e.insertionMode = D.AFTER_BODY, e.options.sourceCodeLocationInfo)) {
    const a = e.openElements.tryPeekProperlyNestedBodyElement();
    a && e._setEndLocation(a, t);
  }
}
function cq(e, t) {
  e.openElements.hasInScope(l.BODY) && (e.insertionMode = D.AFTER_BODY, yf(e, t));
}
function lq(e, t) {
  const a = t.tagID;
  e.openElements.hasInScope(a) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(a));
}
function uq(e) {
  const t = e.openElements.tmplCount > 0, { formElement: a } = e;
  t || (e.formElement = null), (a || t) && e.openElements.hasInScope(l.FORM) && (e.openElements.generateImpliedEndTags(), t ? e.openElements.popUntilTagNamePopped(l.FORM) : a && e.openElements.remove(a));
}
function fq(e) {
  e.openElements.hasInButtonScope(l.P) || e._insertFakeElement(L.P, l.P), e._closePElement();
}
function hq(e) {
  e.openElements.hasInListItemScope(l.LI) && (e.openElements.generateImpliedEndTagsWithExclusion(l.LI), e.openElements.popUntilTagNamePopped(l.LI));
}
function dq(e, t) {
  const a = t.tagID;
  e.openElements.hasInScope(a) && (e.openElements.generateImpliedEndTagsWithExclusion(a), e.openElements.popUntilTagNamePopped(a));
}
function mq(e) {
  e.openElements.hasNumberedHeaderInScope() && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilNumberedHeaderPopped());
}
function pq(e, t) {
  const a = t.tagID;
  e.openElements.hasInScope(a) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(a), e.activeFormattingElements.clearToLastMarker());
}
function gq(e) {
  e._reconstructActiveFormattingElements(), e._insertFakeElement(L.BR, l.BR), e.openElements.pop(), e.framesetOk = !1;
}
function cf(e, t) {
  const a = t.tagName, r = t.tagID;
  for (let n = e.openElements.stackTop; n > 0; n--) {
    const s = e.openElements.items[n], i = e.openElements.tagIDs[n];
    if (r === i && (r !== l.UNKNOWN || e.treeAdapter.getTagName(s) === a)) {
      e.openElements.generateImpliedEndTagsWithExclusion(r), e.openElements.stackTop >= n && e.openElements.shortenToLength(n);
      break;
    }
    if (e._isSpecialElement(s, i))
      break;
  }
}
function es(e, t) {
  switch (t.tagID) {
    case l.A:
    case l.B:
    case l.I:
    case l.S:
    case l.U:
    case l.EM:
    case l.TT:
    case l.BIG:
    case l.CODE:
    case l.FONT:
    case l.NOBR:
    case l.SMALL:
    case l.STRIKE:
    case l.STRONG: {
      so(e, t);
      break;
    }
    case l.P: {
      fq(e);
      break;
    }
    case l.DL:
    case l.UL:
    case l.OL:
    case l.DIR:
    case l.DIV:
    case l.NAV:
    case l.PRE:
    case l.MAIN:
    case l.MENU:
    case l.ASIDE:
    case l.BUTTON:
    case l.CENTER:
    case l.FIGURE:
    case l.FOOTER:
    case l.HEADER:
    case l.HGROUP:
    case l.DIALOG:
    case l.ADDRESS:
    case l.ARTICLE:
    case l.DETAILS:
    case l.SECTION:
    case l.SUMMARY:
    case l.LISTING:
    case l.FIELDSET:
    case l.BLOCKQUOTE:
    case l.FIGCAPTION: {
      lq(e, t);
      break;
    }
    case l.LI: {
      hq(e);
      break;
    }
    case l.DD:
    case l.DT: {
      dq(e, t);
      break;
    }
    case l.H1:
    case l.H2:
    case l.H3:
    case l.H4:
    case l.H5:
    case l.H6: {
      mq(e);
      break;
    }
    case l.BR: {
      gq(e);
      break;
    }
    case l.BODY: {
      oq(e, t);
      break;
    }
    case l.HTML: {
      cq(e, t);
      break;
    }
    case l.FORM: {
      uq(e);
      break;
    }
    case l.APPLET:
    case l.OBJECT:
    case l.MARQUEE: {
      pq(e, t);
      break;
    }
    case l.TEMPLATE: {
      Xa(e, t);
      break;
    }
    default:
      cf(e, t);
  }
}
function lf(e, t) {
  e.tmplInsertionModeStack.length > 0 ? gf(e, t) : io(e, t);
}
function yq(e, t) {
  var a;
  t.tagID === l.SCRIPT && ((a = e.scriptHandler) === null || a === void 0 || a.call(e, e.openElements.current)), e.openElements.pop(), e.insertionMode = e.originalInsertionMode;
}
function _q(e, t) {
  e._err(t, j.eofInElementThatCanContainOnlyText), e.openElements.pop(), e.insertionMode = e.originalInsertionMode, e.onEof(t);
}
function Ys(e, t) {
  if (af.has(e.openElements.currentTagId))
    switch (e.pendingCharacterTokens.length = 0, e.hasNonWhitespacePendingCharacterToken = !1, e.originalInsertionMode = e.insertionMode, e.insertionMode = D.IN_TABLE_TEXT, t.type) {
      case ve.CHARACTER: {
        ff(e, t);
        break;
      }
      case ve.WHITESPACE_CHARACTER: {
        uf(e, t);
        break;
      }
    }
  else
    rn(e, t);
}
function bq(e, t) {
  e.openElements.clearBackToTableContext(), e.activeFormattingElements.insertMarker(), e._insertElement(t, Y.HTML), e.insertionMode = D.IN_CAPTION;
}
function kq(e, t) {
  e.openElements.clearBackToTableContext(), e._insertElement(t, Y.HTML), e.insertionMode = D.IN_COLUMN_GROUP;
}
function wq(e, t) {
  e.openElements.clearBackToTableContext(), e._insertFakeElement(L.COLGROUP, l.COLGROUP), e.insertionMode = D.IN_COLUMN_GROUP, oo(e, t);
}
function Eq(e, t) {
  e.openElements.clearBackToTableContext(), e._insertElement(t, Y.HTML), e.insertionMode = D.IN_TABLE_BODY;
}
function Tq(e, t) {
  e.openElements.clearBackToTableContext(), e._insertFakeElement(L.TBODY, l.TBODY), e.insertionMode = D.IN_TABLE_BODY, ts(e, t);
}
function vq(e, t) {
  e.openElements.hasInTableScope(l.TABLE) && (e.openElements.popUntilTagNamePopped(l.TABLE), e._resetInsertionMode(), e._processStartTag(t));
}
function xq(e, t) {
  of(t) ? e._appendElement(t, Y.HTML) : rn(e, t), t.ackSelfClosing = !0;
}
function Aq(e, t) {
  !e.formElement && e.openElements.tmplCount === 0 && (e._insertElement(t, Y.HTML), e.formElement = e.openElements.current, e.openElements.pop());
}
function sr(e, t) {
  switch (t.tagID) {
    case l.TD:
    case l.TH:
    case l.TR: {
      Tq(e, t);
      break;
    }
    case l.STYLE:
    case l.SCRIPT:
    case l.TEMPLATE: {
      Wt(e, t);
      break;
    }
    case l.COL: {
      wq(e, t);
      break;
    }
    case l.FORM: {
      Aq(e, t);
      break;
    }
    case l.TABLE: {
      vq(e, t);
      break;
    }
    case l.TBODY:
    case l.TFOOT:
    case l.THEAD: {
      Eq(e, t);
      break;
    }
    case l.INPUT: {
      xq(e, t);
      break;
    }
    case l.CAPTION: {
      bq(e, t);
      break;
    }
    case l.COLGROUP: {
      kq(e, t);
      break;
    }
    default:
      rn(e, t);
  }
}
function Xr(e, t) {
  switch (t.tagID) {
    case l.TABLE: {
      e.openElements.hasInTableScope(l.TABLE) && (e.openElements.popUntilTagNamePopped(l.TABLE), e._resetInsertionMode());
      break;
    }
    case l.TEMPLATE: {
      Xa(e, t);
      break;
    }
    case l.BODY:
    case l.CAPTION:
    case l.COL:
    case l.COLGROUP:
    case l.HTML:
    case l.TBODY:
    case l.TD:
    case l.TFOOT:
    case l.TH:
    case l.THEAD:
    case l.TR:
      break;
    default:
      rn(e, t);
  }
}
function rn(e, t) {
  const a = e.fosterParentingEnabled;
  e.fosterParentingEnabled = !0, Zn(e, t), e.fosterParentingEnabled = a;
}
function uf(e, t) {
  e.pendingCharacterTokens.push(t);
}
function ff(e, t) {
  e.pendingCharacterTokens.push(t), e.hasNonWhitespacePendingCharacterToken = !0;
}
function zr(e, t) {
  let a = 0;
  if (e.hasNonWhitespacePendingCharacterToken)
    for (; a < e.pendingCharacterTokens.length; a++)
      rn(e, e.pendingCharacterTokens[a]);
  else
    for (; a < e.pendingCharacterTokens.length; a++)
      e._insertCharacters(e.pendingCharacterTokens[a]);
  e.insertionMode = e.originalInsertionMode, e._processToken(t);
}
const hf = /* @__PURE__ */ new Set([l.CAPTION, l.COL, l.COLGROUP, l.TBODY, l.TD, l.TFOOT, l.TH, l.THEAD, l.TR]);
function Dq(e, t) {
  const a = t.tagID;
  hf.has(a) ? e.openElements.hasInTableScope(l.CAPTION) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(l.CAPTION), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = D.IN_TABLE, sr(e, t)) : dt(e, t);
}
function Cq(e, t) {
  const a = t.tagID;
  switch (a) {
    case l.CAPTION:
    case l.TABLE: {
      e.openElements.hasInTableScope(l.CAPTION) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(l.CAPTION), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = D.IN_TABLE, a === l.TABLE && Xr(e, t));
      break;
    }
    case l.BODY:
    case l.COL:
    case l.COLGROUP:
    case l.HTML:
    case l.TBODY:
    case l.TD:
    case l.TFOOT:
    case l.TH:
    case l.THEAD:
    case l.TR:
      break;
    default:
      es(e, t);
  }
}
function oo(e, t) {
  switch (t.tagID) {
    case l.HTML: {
      dt(e, t);
      break;
    }
    case l.COL: {
      e._appendElement(t, Y.HTML), t.ackSelfClosing = !0;
      break;
    }
    case l.TEMPLATE: {
      Wt(e, t);
      break;
    }
    default:
      Mn(e, t);
  }
}
function Sq(e, t) {
  switch (t.tagID) {
    case l.COLGROUP: {
      e.openElements.currentTagId === l.COLGROUP && (e.openElements.pop(), e.insertionMode = D.IN_TABLE);
      break;
    }
    case l.TEMPLATE: {
      Xa(e, t);
      break;
    }
    case l.COL:
      break;
    default:
      Mn(e, t);
  }
}
function Mn(e, t) {
  e.openElements.currentTagId === l.COLGROUP && (e.openElements.pop(), e.insertionMode = D.IN_TABLE, e._processToken(t));
}
function ts(e, t) {
  switch (t.tagID) {
    case l.TR: {
      e.openElements.clearBackToTableBodyContext(), e._insertElement(t, Y.HTML), e.insertionMode = D.IN_ROW;
      break;
    }
    case l.TH:
    case l.TD: {
      e.openElements.clearBackToTableBodyContext(), e._insertFakeElement(L.TR, l.TR), e.insertionMode = D.IN_ROW, as(e, t);
      break;
    }
    case l.CAPTION:
    case l.COL:
    case l.COLGROUP:
    case l.TBODY:
    case l.TFOOT:
    case l.THEAD: {
      e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = D.IN_TABLE, sr(e, t));
      break;
    }
    default:
      sr(e, t);
  }
}
function _i(e, t) {
  const a = t.tagID;
  switch (t.tagID) {
    case l.TBODY:
    case l.TFOOT:
    case l.THEAD: {
      e.openElements.hasInTableScope(a) && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = D.IN_TABLE);
      break;
    }
    case l.TABLE: {
      e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = D.IN_TABLE, Xr(e, t));
      break;
    }
    case l.BODY:
    case l.CAPTION:
    case l.COL:
    case l.COLGROUP:
    case l.HTML:
    case l.TD:
    case l.TH:
    case l.TR:
      break;
    default:
      Xr(e, t);
  }
}
function as(e, t) {
  switch (t.tagID) {
    case l.TH:
    case l.TD: {
      e.openElements.clearBackToTableRowContext(), e._insertElement(t, Y.HTML), e.insertionMode = D.IN_CELL, e.activeFormattingElements.insertMarker();
      break;
    }
    case l.CAPTION:
    case l.COL:
    case l.COLGROUP:
    case l.TBODY:
    case l.TFOOT:
    case l.THEAD:
    case l.TR: {
      e.openElements.hasInTableScope(l.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = D.IN_TABLE_BODY, ts(e, t));
      break;
    }
    default:
      sr(e, t);
  }
}
function df(e, t) {
  switch (t.tagID) {
    case l.TR: {
      e.openElements.hasInTableScope(l.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = D.IN_TABLE_BODY);
      break;
    }
    case l.TABLE: {
      e.openElements.hasInTableScope(l.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = D.IN_TABLE_BODY, _i(e, t));
      break;
    }
    case l.TBODY:
    case l.TFOOT:
    case l.THEAD: {
      (e.openElements.hasInTableScope(t.tagID) || e.openElements.hasInTableScope(l.TR)) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = D.IN_TABLE_BODY, _i(e, t));
      break;
    }
    case l.BODY:
    case l.CAPTION:
    case l.COL:
    case l.COLGROUP:
    case l.HTML:
    case l.TD:
    case l.TH:
      break;
    default:
      Xr(e, t);
  }
}
function zq(e, t) {
  const a = t.tagID;
  hf.has(a) ? (e.openElements.hasInTableScope(l.TD) || e.openElements.hasInTableScope(l.TH)) && (e._closeTableCell(), as(e, t)) : dt(e, t);
}
function Nq(e, t) {
  const a = t.tagID;
  switch (a) {
    case l.TD:
    case l.TH: {
      e.openElements.hasInTableScope(a) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(a), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = D.IN_ROW);
      break;
    }
    case l.TABLE:
    case l.TBODY:
    case l.TFOOT:
    case l.THEAD:
    case l.TR: {
      e.openElements.hasInTableScope(a) && (e._closeTableCell(), df(e, t));
      break;
    }
    case l.BODY:
    case l.CAPTION:
    case l.COL:
    case l.COLGROUP:
    case l.HTML:
      break;
    default:
      es(e, t);
  }
}
function mf(e, t) {
  switch (t.tagID) {
    case l.HTML: {
      dt(e, t);
      break;
    }
    case l.OPTION: {
      e.openElements.currentTagId === l.OPTION && e.openElements.pop(), e._insertElement(t, Y.HTML);
      break;
    }
    case l.OPTGROUP: {
      e.openElements.currentTagId === l.OPTION && e.openElements.pop(), e.openElements.currentTagId === l.OPTGROUP && e.openElements.pop(), e._insertElement(t, Y.HTML);
      break;
    }
    case l.INPUT:
    case l.KEYGEN:
    case l.TEXTAREA:
    case l.SELECT: {
      e.openElements.hasInSelectScope(l.SELECT) && (e.openElements.popUntilTagNamePopped(l.SELECT), e._resetInsertionMode(), t.tagID !== l.SELECT && e._processStartTag(t));
      break;
    }
    case l.SCRIPT:
    case l.TEMPLATE: {
      Wt(e, t);
      break;
    }
  }
}
function pf(e, t) {
  switch (t.tagID) {
    case l.OPTGROUP: {
      e.openElements.stackTop > 0 && e.openElements.currentTagId === l.OPTION && e.openElements.tagIDs[e.openElements.stackTop - 1] === l.OPTGROUP && e.openElements.pop(), e.openElements.currentTagId === l.OPTGROUP && e.openElements.pop();
      break;
    }
    case l.OPTION: {
      e.openElements.currentTagId === l.OPTION && e.openElements.pop();
      break;
    }
    case l.SELECT: {
      e.openElements.hasInSelectScope(l.SELECT) && (e.openElements.popUntilTagNamePopped(l.SELECT), e._resetInsertionMode());
      break;
    }
    case l.TEMPLATE: {
      Xa(e, t);
      break;
    }
  }
}
function Iq(e, t) {
  const a = t.tagID;
  a === l.CAPTION || a === l.TABLE || a === l.TBODY || a === l.TFOOT || a === l.THEAD || a === l.TR || a === l.TD || a === l.TH ? (e.openElements.popUntilTagNamePopped(l.SELECT), e._resetInsertionMode(), e._processStartTag(t)) : mf(e, t);
}
function Rq(e, t) {
  const a = t.tagID;
  a === l.CAPTION || a === l.TABLE || a === l.TBODY || a === l.TFOOT || a === l.THEAD || a === l.TR || a === l.TD || a === l.TH ? e.openElements.hasInTableScope(a) && (e.openElements.popUntilTagNamePopped(l.SELECT), e._resetInsertionMode(), e.onEndTag(t)) : pf(e, t);
}
function Fq(e, t) {
  switch (t.tagID) {
    case l.BASE:
    case l.BASEFONT:
    case l.BGSOUND:
    case l.LINK:
    case l.META:
    case l.NOFRAMES:
    case l.SCRIPT:
    case l.STYLE:
    case l.TEMPLATE:
    case l.TITLE: {
      Wt(e, t);
      break;
    }
    case l.CAPTION:
    case l.COLGROUP:
    case l.TBODY:
    case l.TFOOT:
    case l.THEAD: {
      e.tmplInsertionModeStack[0] = D.IN_TABLE, e.insertionMode = D.IN_TABLE, sr(e, t);
      break;
    }
    case l.COL: {
      e.tmplInsertionModeStack[0] = D.IN_COLUMN_GROUP, e.insertionMode = D.IN_COLUMN_GROUP, oo(e, t);
      break;
    }
    case l.TR: {
      e.tmplInsertionModeStack[0] = D.IN_TABLE_BODY, e.insertionMode = D.IN_TABLE_BODY, ts(e, t);
      break;
    }
    case l.TD:
    case l.TH: {
      e.tmplInsertionModeStack[0] = D.IN_ROW, e.insertionMode = D.IN_ROW, as(e, t);
      break;
    }
    default:
      e.tmplInsertionModeStack[0] = D.IN_BODY, e.insertionMode = D.IN_BODY, dt(e, t);
  }
}
function Oq(e, t) {
  t.tagID === l.TEMPLATE && Xa(e, t);
}
function gf(e, t) {
  e.openElements.tmplCount > 0 ? (e.openElements.popUntilTagNamePopped(l.TEMPLATE), e.activeFormattingElements.clearToLastMarker(), e.tmplInsertionModeStack.shift(), e._resetInsertionMode(), e.onEof(t)) : io(e, t);
}
function Lq(e, t) {
  t.tagID === l.HTML ? dt(e, t) : Bn(e, t);
}
function yf(e, t) {
  var a;
  if (t.tagID === l.HTML) {
    if (e.fragmentContext || (e.insertionMode = D.AFTER_AFTER_BODY), e.options.sourceCodeLocationInfo && e.openElements.tagIDs[0] === l.HTML) {
      e._setEndLocation(e.openElements.items[0], t);
      const r = e.openElements.items[1];
      r && !(!((a = e.treeAdapter.getNodeSourceCodeLocation(r)) === null || a === void 0) && a.endTag) && e._setEndLocation(r, t);
    }
  } else
    Bn(e, t);
}
function Bn(e, t) {
  e.insertionMode = D.IN_BODY, Zn(e, t);
}
function Mq(e, t) {
  switch (t.tagID) {
    case l.HTML: {
      dt(e, t);
      break;
    }
    case l.FRAMESET: {
      e._insertElement(t, Y.HTML);
      break;
    }
    case l.FRAME: {
      e._appendElement(t, Y.HTML), t.ackSelfClosing = !0;
      break;
    }
    case l.NOFRAMES: {
      Wt(e, t);
      break;
    }
  }
}
function Bq(e, t) {
  t.tagID === l.FRAMESET && !e.openElements.isRootHtmlElementCurrent() && (e.openElements.pop(), !e.fragmentContext && e.openElements.currentTagId !== l.FRAMESET && (e.insertionMode = D.AFTER_FRAMESET));
}
function Pq(e, t) {
  switch (t.tagID) {
    case l.HTML: {
      dt(e, t);
      break;
    }
    case l.NOFRAMES: {
      Wt(e, t);
      break;
    }
  }
}
function Hq(e, t) {
  t.tagID === l.HTML && (e.insertionMode = D.AFTER_AFTER_FRAMESET);
}
function Uq(e, t) {
  t.tagID === l.HTML ? dt(e, t) : Dn(e, t);
}
function Dn(e, t) {
  e.insertionMode = D.IN_BODY, Zn(e, t);
}
function jq(e, t) {
  switch (t.tagID) {
    case l.HTML: {
      dt(e, t);
      break;
    }
    case l.NOFRAMES: {
      Wt(e, t);
      break;
    }
  }
}
function qq(e, t) {
  t.chars = qe, e._insertCharacters(t);
}
function Yq(e, t) {
  e._insertCharacters(t), e.framesetOk = !1;
}
function _f(e) {
  for (; e.treeAdapter.getNamespaceURI(e.openElements.current) !== Y.HTML && !e._isIntegrationPoint(e.openElements.currentTagId, e.openElements.current); )
    e.openElements.pop();
}
function Vq(e, t) {
  if (ij(t))
    _f(e), e._startTagOutsideForeignContent(t);
  else {
    const a = e._getAdjustedCurrentElement(), r = e.treeAdapter.getNamespaceURI(a);
    r === Y.MATHML ? ef(t) : r === Y.SVG && (oj(t), tf(t)), no(t), t.selfClosing ? e._appendElement(t, r) : e._insertElement(t, r), t.ackSelfClosing = !0;
  }
}
function Gq(e, t) {
  if (t.tagID === l.P || t.tagID === l.BR) {
    _f(e), e._endTagOutsideForeignContent(t);
    return;
  }
  for (let a = e.openElements.stackTop; a > 0; a--) {
    const r = e.openElements.items[a];
    if (e.treeAdapter.getNamespaceURI(r) === Y.HTML) {
      e._endTagOutsideForeignContent(t);
      break;
    }
    const n = e.treeAdapter.getTagName(r);
    if (n.toLowerCase() === t.tagName) {
      t.tagName = n, e.openElements.shortenToLength(a);
      break;
    }
  }
}
L.AREA, L.BASE, L.BASEFONT, L.BGSOUND, L.BR, L.COL, L.EMBED, L.FRAME, L.HR, L.IMG, L.INPUT, L.KEYGEN, L.LINK, L.META, L.PARAM, L.SOURCE, L.TRACK, L.WBR;
const Wq = /* @__PURE__ */ new Set([
  "mdxFlowExpression",
  "mdxJsxFlowElement",
  "mdxJsxTextElement",
  "mdxTextExpression",
  "mdxjsEsm"
]), ml = { sourceCodeLocationInfo: !0, scriptingEnabled: !1 };
function bf(e, t) {
  const a = rY(e), r = ou("type", {
    handlers: { root: $q, element: Xq, text: Qq, comment: wf, doctype: Kq, raw: Zq },
    unknown: eY
  }), n = {
    parser: a ? new fl(ml) : fl.getFragmentParser(void 0, ml),
    handle(o) {
      r(o, n);
    },
    stitches: !1,
    options: t || {}
  };
  r(e, n), mr(n, ta());
  const s = a ? n.parser.document : n.parser.getFragment(), i = sU(s, {
    // To do: support `space`?
    file: n.options.file
  });
  return n.stitches && lr(i, "comment", function(o, c, u) {
    const d = (
      /** @type {Stitch} */
      /** @type {unknown} */
      o
    );
    if (d.value.stitch && u && c !== void 0) {
      const m = u.children;
      return m[c] = d.value.stitch, c;
    }
  }), i.type === "root" && i.children.length === 1 && i.children[0].type === e.type ? i.children[0] : i;
}
function kf(e, t) {
  let a = -1;
  if (e)
    for (; ++a < e.length; )
      t.handle(e[a]);
}
function $q(e, t) {
  kf(e.children, t);
}
function Xq(e, t) {
  tY(e, t), kf(e.children, t), aY(e, t);
}
function Qq(e, t) {
  t.parser.tokenizer.state > 4 && (t.parser.tokenizer.state = 0);
  const a = {
    type: ve.CHARACTER,
    chars: e.value,
    location: nn(e)
  };
  mr(t, ta(e)), t.parser.currentToken = a, t.parser._processToken(t.parser.currentToken);
}
function Kq(e, t) {
  const a = {
    type: ve.DOCTYPE,
    name: "html",
    forceQuirks: !1,
    publicId: "",
    systemId: "",
    location: nn(e)
  };
  mr(t, ta(e)), t.parser.currentToken = a, t.parser._processToken(t.parser.currentToken);
}
function Jq(e, t) {
  t.stitches = !0;
  const a = nY(e);
  if ("children" in e && "children" in a) {
    const r = (
      /** @type {Root} */
      bf({ type: "root", children: e.children }, t.options)
    );
    a.children = r.children;
  }
  wf({ type: "comment", value: { stitch: a } }, t);
}
function wf(e, t) {
  const a = e.value, r = {
    type: ve.COMMENT,
    data: a,
    location: nn(e)
  };
  mr(t, ta(e)), t.parser.currentToken = r, t.parser._processToken(t.parser.currentToken);
}
function Zq(e, t) {
  if (t.parser.tokenizer.preprocessor.html = "", t.parser.tokenizer.preprocessor.pos = -1, t.parser.tokenizer.preprocessor.lastGapPos = -2, t.parser.tokenizer.preprocessor.gapStack = [], t.parser.tokenizer.preprocessor.skipNextNewLine = !1, t.parser.tokenizer.preprocessor.lastChunkWritten = !1, t.parser.tokenizer.preprocessor.endOfChunkHit = !1, t.parser.tokenizer.preprocessor.isEol = !1, Ef(t, ta(e)), t.parser.tokenizer.write(e.value, !1), t.parser.tokenizer._runParsingLoop(), t.parser.tokenizer.state === 72 || t.parser.tokenizer.state === 78) {
    t.parser.tokenizer.preprocessor.lastChunkWritten = !0;
    const a = t.parser.tokenizer._consume();
    t.parser.tokenizer._callState(a);
  }
}
function eY(e, t) {
  const a = (
    /** @type {Nodes} */
    e
  );
  if (t.options.passThrough && t.options.passThrough.includes(a.type))
    Jq(a, t);
  else {
    let r = "";
    throw Wq.has(a.type) && (r = ". It looks like you are using MDX nodes with `hast-util-raw` (or `rehype-raw`). If you use this because you are using remark or rehype plugins that inject `'html'` nodes, then please raise an issue with that plugin, as its a bad and slow idea. If you use this because you are using markdown syntax, then you have to configure this utility (or plugin) to pass through these nodes (see `passThrough` in docs), but you can also migrate to use the MDX syntax"), new Error("Cannot compile `" + a.type + "` node" + r);
  }
}
function mr(e, t) {
  Ef(e, t);
  const a = e.parser.tokenizer.currentCharacterToken;
  a && a.location && (a.location.endLine = e.parser.tokenizer.preprocessor.line, a.location.endCol = e.parser.tokenizer.preprocessor.col + 1, a.location.endOffset = e.parser.tokenizer.preprocessor.offset + 1, e.parser.currentToken = a, e.parser._processToken(e.parser.currentToken)), e.parser.tokenizer.paused = !1, e.parser.tokenizer.inLoop = !1, e.parser.tokenizer.active = !1, e.parser.tokenizer.returnState = Xe.DATA, e.parser.tokenizer.charRefCode = -1, e.parser.tokenizer.consumedAfterSnapshot = -1, e.parser.tokenizer.currentLocation = null, e.parser.tokenizer.currentCharacterToken = null, e.parser.tokenizer.currentToken = null, e.parser.tokenizer.currentAttr = { name: "", value: "" };
}
function Ef(e, t) {
  if (t && t.offset !== void 0) {
    const a = {
      startLine: t.line,
      startCol: t.column,
      startOffset: t.offset,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    };
    e.parser.tokenizer.preprocessor.lineStartPos = -t.column + 1, e.parser.tokenizer.preprocessor.droppedBufferSize = t.offset, e.parser.tokenizer.preprocessor.line = t.line, e.parser.tokenizer.currentLocation = a;
  }
}
function tY(e, t) {
  const a = e.tagName.toLowerCase();
  if (t.parser.tokenizer.state === Xe.PLAINTEXT) return;
  mr(t, ta(e));
  const r = t.parser.openElements.current;
  let n = "namespaceURI" in r ? r.namespaceURI : Zt.html;
  n === Zt.html && a === "svg" && (n = Zt.svg);
  const s = uU(
    // Shallow clone to not delve into `children`: we only need the attributes.
    { ...e, children: [] },
    { space: n === Zt.svg ? "svg" : "html" }
  ), i = {
    type: ve.START_TAG,
    tagName: a,
    tagID: dr(a),
    // We always send start and end tags.
    selfClosing: !1,
    ackSelfClosing: !1,
    // Always element.
    /* c8 ignore next */
    attrs: "attrs" in s ? s.attrs : [],
    location: nn(e)
  };
  t.parser.currentToken = i, t.parser._processToken(t.parser.currentToken), t.parser.tokenizer.lastStartTagName = a;
}
function aY(e, t) {
  const a = e.tagName.toLowerCase();
  if (!t.parser.tokenizer.inForeignNode && _U.includes(a) || t.parser.tokenizer.state === Xe.PLAINTEXT) return;
  mr(t, Un(e));
  const r = {
    type: ve.END_TAG,
    tagName: a,
    tagID: dr(a),
    selfClosing: !1,
    ackSelfClosing: !1,
    attrs: [],
    location: nn(e)
  };
  t.parser.currentToken = r, t.parser._processToken(t.parser.currentToken), // Current element is closed.
  a === t.parser.tokenizer.lastStartTagName && // `<textarea>` and `<title>`
  (t.parser.tokenizer.state === Xe.RCDATA || // `<iframe>`, `<noembed>`, `<style>`, `<xmp>`
  t.parser.tokenizer.state === Xe.RAWTEXT || // `<script>`
  t.parser.tokenizer.state === Xe.SCRIPT_DATA) && (t.parser.tokenizer.state = Xe.DATA);
}
function rY(e) {
  const t = e.type === "root" ? e.children[0] : e;
  return !!(t && (t.type === "doctype" || t.type === "element" && t.tagName.toLowerCase() === "html"));
}
function nn(e) {
  const t = ta(e) || {
    line: void 0,
    column: void 0,
    offset: void 0
  }, a = Un(e) || {
    line: void 0,
    column: void 0,
    offset: void 0
  };
  return {
    startLine: t.line,
    startCol: t.column,
    startOffset: t.offset,
    endLine: a.line,
    endCol: a.column,
    endOffset: a.offset
  };
}
function nY(e) {
  return "children" in e ? Da({ ...e, children: [] }) : Da(e);
}
function sY(e) {
  return function(t, a) {
    return (
      /** @type {Root} */
      bf(t, { ...e, file: a })
    );
  };
}
function iY(e) {
  const t = e.type === "element" ? e.tagName.toLowerCase() : "", a = t.length === 2 && t.charCodeAt(0) === 104 ? t.charCodeAt(1) : 0;
  return a > 48 && a < 55 ? a - 48 : void 0;
}
function oY(e) {
  return "children" in e ? Tf(e) : "value" in e ? e.value : "";
}
function cY(e) {
  return e.type === "text" ? e.value : "children" in e ? Tf(e) : "";
}
function Tf(e) {
  let t = -1;
  const a = [];
  for (; ++t < e.children.length; )
    a[t] = cY(e.children[t]);
  return a.join("");
}
const lY = {}, pl = new A0();
function uY(e) {
  const a = (e || lY).prefix || "";
  return function(r) {
    pl.reset(), lr(r, "element", function(n) {
      iY(n) && !n.properties.id && (n.properties.id = a + pl.slug(oY(n)));
    });
  };
}
var Nr = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var gl;
function fY() {
  if (gl) return Nr;
  gl = 1;
  var e = Pn, t = Symbol.for("react.element"), a = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, n = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function i(o, c, u) {
    var d, m = {}, h = null, y = null;
    u !== void 0 && (h = "" + u), c.key !== void 0 && (h = "" + c.key), c.ref !== void 0 && (y = c.ref);
    for (d in c) r.call(c, d) && !s.hasOwnProperty(d) && (m[d] = c[d]);
    if (o && o.defaultProps) for (d in c = o.defaultProps, c) m[d] === void 0 && (m[d] = c[d]);
    return { $$typeof: t, type: o, key: h, ref: y, props: m, _owner: n.current };
  }
  return Nr.Fragment = a, Nr.jsx = i, Nr.jsxs = i, Nr;
}
var wn = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var yl;
function hY() {
  return yl || (yl = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Pn, t = Symbol.for("react.element"), a = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), i = Symbol.for("react.provider"), o = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), d = Symbol.for("react.suspense_list"), m = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), y = Symbol.for("react.offscreen"), w = Symbol.iterator, v = "@@iterator";
    function F(_) {
      if (_ === null || typeof _ != "object")
        return null;
      var R = w && _[w] || _[v];
      return typeof R == "function" ? R : null;
    }
    var z = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function C(_) {
      {
        for (var R = arguments.length, H = new Array(R > 1 ? R - 1 : 0), X = 1; X < R; X++)
          H[X - 1] = arguments[X];
        U("error", _, H);
      }
    }
    function U(_, R, H) {
      {
        var X = z.ReactDebugCurrentFrame, ce = X.getStackAddendum();
        ce !== "" && (R += "%s", H = H.concat([ce]));
        var he = H.map(function(oe) {
          return String(oe);
        });
        he.unshift("Warning: " + R), Function.prototype.apply.call(console[_], console, he);
      }
    }
    var $ = !1, O = !1, p = !1, M = !1, te = !1, Z;
    Z = Symbol.for("react.module.reference");
    function P(_) {
      return !!(typeof _ == "string" || typeof _ == "function" || _ === r || _ === s || te || _ === n || _ === u || _ === d || M || _ === y || $ || O || p || typeof _ == "object" && _ !== null && (_.$$typeof === h || _.$$typeof === m || _.$$typeof === i || _.$$typeof === o || _.$$typeof === c || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      _.$$typeof === Z || _.getModuleId !== void 0));
    }
    function re(_, R, H) {
      var X = _.displayName;
      if (X)
        return X;
      var ce = R.displayName || R.name || "";
      return ce !== "" ? H + "(" + ce + ")" : H;
    }
    function ae(_) {
      return _.displayName || "Context";
    }
    function ue(_) {
      if (_ == null)
        return null;
      if (typeof _.tag == "number" && C("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof _ == "function")
        return _.displayName || _.name || null;
      if (typeof _ == "string")
        return _;
      switch (_) {
        case r:
          return "Fragment";
        case a:
          return "Portal";
        case s:
          return "Profiler";
        case n:
          return "StrictMode";
        case u:
          return "Suspense";
        case d:
          return "SuspenseList";
      }
      if (typeof _ == "object")
        switch (_.$$typeof) {
          case o:
            var R = _;
            return ae(R) + ".Consumer";
          case i:
            var H = _;
            return ae(H._context) + ".Provider";
          case c:
            return re(_, _.render, "ForwardRef");
          case m:
            var X = _.displayName || null;
            return X !== null ? X : ue(_.type) || "Memo";
          case h: {
            var ce = _, he = ce._payload, oe = ce._init;
            try {
              return ue(oe(he));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var de = Object.assign, fe = 0, Se, Ne, je, et, S, Me, Re;
    function N() {
    }
    N.__reactDisabledLog = !0;
    function tt() {
      {
        if (fe === 0) {
          Se = console.log, Ne = console.info, je = console.warn, et = console.error, S = console.group, Me = console.groupCollapsed, Re = console.groupEnd;
          var _ = {
            configurable: !0,
            enumerable: !0,
            value: N,
            writable: !0
          };
          Object.defineProperties(console, {
            info: _,
            log: _,
            warn: _,
            error: _,
            group: _,
            groupCollapsed: _,
            groupEnd: _
          });
        }
        fe++;
      }
    }
    function st() {
      {
        if (fe--, fe === 0) {
          var _ = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: de({}, _, {
              value: Se
            }),
            info: de({}, _, {
              value: Ne
            }),
            warn: de({}, _, {
              value: je
            }),
            error: de({}, _, {
              value: et
            }),
            group: de({}, _, {
              value: S
            }),
            groupCollapsed: de({}, _, {
              value: Me
            }),
            groupEnd: de({}, _, {
              value: Re
            })
          });
        }
        fe < 0 && C("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Fe = z.ReactCurrentDispatcher, Ke;
    function He(_, R, H) {
      {
        if (Ke === void 0)
          try {
            throw Error();
          } catch (ce) {
            var X = ce.stack.trim().match(/\n( *(at )?)/);
            Ke = X && X[1] || "";
          }
        return `
` + Ke + _;
      }
    }
    var at = !1, $e;
    {
      var $t = typeof WeakMap == "function" ? WeakMap : Map;
      $e = new $t();
    }
    function ia(_, R) {
      if (!_ || at)
        return "";
      {
        var H = $e.get(_);
        if (H !== void 0)
          return H;
      }
      var X;
      at = !0;
      var ce = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var he;
      he = Fe.current, Fe.current = null, tt();
      try {
        if (R) {
          var oe = function() {
            throw Error();
          };
          if (Object.defineProperty(oe.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(oe, []);
            } catch (Ie) {
              X = Ie;
            }
            Reflect.construct(_, [], oe);
          } else {
            try {
              oe.call();
            } catch (Ie) {
              X = Ie;
            }
            _.call(oe.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ie) {
            X = Ie;
          }
          _();
        }
      } catch (Ie) {
        if (Ie && X && typeof Ie.stack == "string") {
          for (var se = Ie.stack.split(`
`), ze = X.stack.split(`
`), be = se.length - 1, Ee = ze.length - 1; be >= 1 && Ee >= 0 && se[be] !== ze[Ee]; )
            Ee--;
          for (; be >= 1 && Ee >= 0; be--, Ee--)
            if (se[be] !== ze[Ee]) {
              if (be !== 1 || Ee !== 1)
                do
                  if (be--, Ee--, Ee < 0 || se[be] !== ze[Ee]) {
                    var Ue = `
` + se[be].replace(" at new ", " at ");
                    return _.displayName && Ue.includes("<anonymous>") && (Ue = Ue.replace("<anonymous>", _.displayName)), typeof _ == "function" && $e.set(_, Ue), Ue;
                  }
                while (be >= 1 && Ee >= 0);
              break;
            }
        }
      } finally {
        at = !1, Fe.current = he, st(), Error.prepareStackTrace = ce;
      }
      var Dt = _ ? _.displayName || _.name : "", pt = Dt ? He(Dt) : "";
      return typeof _ == "function" && $e.set(_, pt), pt;
    }
    function Fa(_, R, H) {
      return ia(_, !1);
    }
    function oa(_) {
      var R = _.prototype;
      return !!(R && R.isReactComponent);
    }
    function mt(_, R, H) {
      if (_ == null)
        return "";
      if (typeof _ == "function")
        return ia(_, oa(_));
      if (typeof _ == "string")
        return He(_);
      switch (_) {
        case u:
          return He("Suspense");
        case d:
          return He("SuspenseList");
      }
      if (typeof _ == "object")
        switch (_.$$typeof) {
          case c:
            return Fa(_.render);
          case m:
            return mt(_.type, R, H);
          case h: {
            var X = _, ce = X._payload, he = X._init;
            try {
              return mt(he(ce), R, H);
            } catch {
            }
          }
        }
      return "";
    }
    var ct = Object.prototype.hasOwnProperty, Rt = {}, Ft = z.ReactDebugCurrentFrame;
    function lt(_) {
      if (_) {
        var R = _._owner, H = mt(_.type, _._source, R ? R.type : null);
        Ft.setExtraStackFrame(H);
      } else
        Ft.setExtraStackFrame(null);
    }
    function Qa(_, R, H, X, ce) {
      {
        var he = Function.call.bind(ct);
        for (var oe in _)
          if (he(_, oe)) {
            var se = void 0;
            try {
              if (typeof _[oe] != "function") {
                var ze = Error((X || "React class") + ": " + H + " type `" + oe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof _[oe] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw ze.name = "Invariant Violation", ze;
              }
              se = _[oe](R, oe, X, H, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (be) {
              se = be;
            }
            se && !(se instanceof Error) && (lt(ce), C("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", X || "React class", H, oe, typeof se), lt(null)), se instanceof Error && !(se.message in Rt) && (Rt[se.message] = !0, lt(ce), C("Failed %s type: %s", H, se.message), lt(null));
          }
      }
    }
    var pr = Array.isArray;
    function ca(_) {
      return pr(_);
    }
    function gr(_) {
      {
        var R = typeof Symbol == "function" && Symbol.toStringTag, H = R && _[Symbol.toStringTag] || _.constructor.name || "Object";
        return H;
      }
    }
    function yr(_) {
      try {
        return Oa(_), !1;
      } catch {
        return !0;
      }
    }
    function Oa(_) {
      return "" + _;
    }
    function q(_) {
      if (yr(_))
        return C("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", gr(_)), Oa(_);
    }
    var K = z.ReactCurrentOwner, _e = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, we, De, rt;
    rt = {};
    function qt(_) {
      if (ct.call(_, "ref")) {
        var R = Object.getOwnPropertyDescriptor(_, "ref").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return _.ref !== void 0;
    }
    function vt(_) {
      if (ct.call(_, "key")) {
        var R = Object.getOwnPropertyDescriptor(_, "key").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return _.key !== void 0;
    }
    function la(_, R) {
      if (typeof _.ref == "string" && K.current && R && K.current.stateNode !== R) {
        var H = ue(K.current.type);
        rt[H] || (C('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', ue(K.current.type), _.ref), rt[H] = !0);
      }
    }
    function ua(_, R) {
      {
        var H = function() {
          we || (we = !0, C("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        H.isReactWarning = !0, Object.defineProperty(_, "key", {
          get: H,
          configurable: !0
        });
      }
    }
    function ut(_, R) {
      {
        var H = function() {
          De || (De = !0, C("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        H.isReactWarning = !0, Object.defineProperty(_, "ref", {
          get: H,
          configurable: !0
        });
      }
    }
    var Xt = function(_, R, H, X, ce, he, oe) {
      var se = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: _,
        key: R,
        ref: H,
        props: oe,
        // Record the component responsible for creating this element.
        _owner: he
      };
      return se._store = {}, Object.defineProperty(se._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(se, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: X
      }), Object.defineProperty(se, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ce
      }), Object.freeze && (Object.freeze(se.props), Object.freeze(se)), se;
    };
    function xt(_, R, H, X, ce) {
      {
        var he, oe = {}, se = null, ze = null;
        H !== void 0 && (q(H), se = "" + H), vt(R) && (q(R.key), se = "" + R.key), qt(R) && (ze = R.ref, la(R, ce));
        for (he in R)
          ct.call(R, he) && !_e.hasOwnProperty(he) && (oe[he] = R[he]);
        if (_ && _.defaultProps) {
          var be = _.defaultProps;
          for (he in be)
            oe[he] === void 0 && (oe[he] = be[he]);
        }
        if (se || ze) {
          var Ee = typeof _ == "function" ? _.displayName || _.name || "Unknown" : _;
          se && ua(oe, Ee), ze && ut(oe, Ee);
        }
        return Xt(_, se, ze, ce, X, K.current, oe);
      }
    }
    var La = z.ReactCurrentOwner, _r = z.ReactDebugCurrentFrame;
    function At(_) {
      if (_) {
        var R = _._owner, H = mt(_.type, _._source, R ? R.type : null);
        _r.setExtraStackFrame(H);
      } else
        _r.setExtraStackFrame(null);
    }
    var Ma;
    Ma = !1;
    function Ba(_) {
      return typeof _ == "object" && _ !== null && _.$$typeof === t;
    }
    function br() {
      {
        if (La.current) {
          var _ = ue(La.current.type);
          if (_)
            return `

Check the render method of \`` + _ + "`.";
        }
        return "";
      }
    }
    function rs(_) {
      return "";
    }
    var kr = {};
    function ns(_) {
      {
        var R = br();
        if (!R) {
          var H = typeof _ == "string" ? _ : _.displayName || _.name;
          H && (R = `

Check the top-level render call using <` + H + ">.");
        }
        return R;
      }
    }
    function wr(_, R) {
      {
        if (!_._store || _._store.validated || _.key != null)
          return;
        _._store.validated = !0;
        var H = ns(R);
        if (kr[H])
          return;
        kr[H] = !0;
        var X = "";
        _ && _._owner && _._owner !== La.current && (X = " It was passed a child from " + ue(_._owner.type) + "."), At(_), C('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', H, X), At(null);
      }
    }
    function Er(_, R) {
      {
        if (typeof _ != "object")
          return;
        if (ca(_))
          for (var H = 0; H < _.length; H++) {
            var X = _[H];
            Ba(X) && wr(X, R);
          }
        else if (Ba(_))
          _._store && (_._store.validated = !0);
        else if (_) {
          var ce = F(_);
          if (typeof ce == "function" && ce !== _.entries)
            for (var he = ce.call(_), oe; !(oe = he.next()).done; )
              Ba(oe.value) && wr(oe.value, R);
        }
      }
    }
    function ss(_) {
      {
        var R = _.type;
        if (R == null || typeof R == "string")
          return;
        var H;
        if (typeof R == "function")
          H = R.propTypes;
        else if (typeof R == "object" && (R.$$typeof === c || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        R.$$typeof === m))
          H = R.propTypes;
        else
          return;
        if (H) {
          var X = ue(R);
          Qa(H, _.props, "prop", X, _);
        } else if (R.PropTypes !== void 0 && !Ma) {
          Ma = !0;
          var ce = ue(R);
          C("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ce || "Unknown");
        }
        typeof R.getDefaultProps == "function" && !R.getDefaultProps.isReactClassApproved && C("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function is(_) {
      {
        for (var R = Object.keys(_.props), H = 0; H < R.length; H++) {
          var X = R[H];
          if (X !== "children" && X !== "key") {
            At(_), C("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", X), At(null);
            break;
          }
        }
        _.ref !== null && (At(_), C("Invalid attribute `ref` supplied to `React.Fragment`."), At(null));
      }
    }
    var Tr = {};
    function vr(_, R, H, X, ce, he) {
      {
        var oe = P(_);
        if (!oe) {
          var se = "";
          (_ === void 0 || typeof _ == "object" && _ !== null && Object.keys(_).length === 0) && (se += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var ze = rs();
          ze ? se += ze : se += br();
          var be;
          _ === null ? be = "null" : ca(_) ? be = "array" : _ !== void 0 && _.$$typeof === t ? (be = "<" + (ue(_.type) || "Unknown") + " />", se = " Did you accidentally export a JSX literal instead of a component?") : be = typeof _, C("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", be, se);
        }
        var Ee = xt(_, R, H, ce, he);
        if (Ee == null)
          return Ee;
        if (oe) {
          var Ue = R.children;
          if (Ue !== void 0)
            if (X)
              if (ca(Ue)) {
                for (var Dt = 0; Dt < Ue.length; Dt++)
                  Er(Ue[Dt], _);
                Object.freeze && Object.freeze(Ue);
              } else
                C("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Er(Ue, _);
        }
        if (ct.call(R, "key")) {
          var pt = ue(_), Ie = Object.keys(R).filter(function(hs) {
            return hs !== "key";
          }), Pa = Ie.length > 0 ? "{key: someKey, " + Ie.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Tr[pt + Pa]) {
            var fs = Ie.length > 0 ? "{" + Ie.join(": ..., ") + ": ...}" : "{}";
            C(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Pa, pt, fs, pt), Tr[pt + Pa] = !0;
          }
        }
        return _ === r ? is(Ee) : ss(Ee), Ee;
      }
    }
    function os(_, R, H) {
      return vr(_, R, H, !0);
    }
    function cs(_, R, H) {
      return vr(_, R, H, !1);
    }
    var ls = cs, us = os;
    wn.Fragment = r, wn.jsx = ls, wn.jsxs = us;
  }()), wn;
}
process.env.NODE_ENV === "production" ? fY() : hY();
const dY = (e) => {
  const t = vf(null), a = t;
  return xf(() => {
    const r = a.current;
    if (!r) return;
    const n = (s) => {
      var i, o;
      const c = s.target;
      if (c.tagName === "A" && (i = c.getAttribute("href")) != null && i.startsWith("#")) {
        s.preventDefault();
        const u = (o = c.getAttribute("href")) == null ? void 0 : o.slice(1), d = r.querySelector(`#${u}`);
        d && d.scrollIntoView({ behavior: "smooth" });
      }
    };
    return r.addEventListener("click", n), () => r.removeEventListener("click", n);
  }, [a]), a;
}, mY = ({
  markdownString: e,
  components: t,
  tocTitle: a = "Table Of Contents"
}) => {
  const r = dY(), n = [
    sY,
    uY,
    aU
  ];
  return /* @__PURE__ */ St.jsx("div", { ref: r, children: /* @__PURE__ */ St.jsx(
    Vp,
    {
      remarkPlugins: [
        ey,
        c2,
        yH,
        [xH, { heading: a, tight: !0 }]
      ],
      rehypePlugins: n,
      components: t,
      children: e
    }
  ) });
}, gY = ({
  markdownString: e,
  components: t,
  externalReactComponents: a,
  externalToggleLabel: r = "Show Controls",
  showExternalToggle: n = !1
}) => {
  const [s, i] = Af(!1), o = () => {
    i(!s);
  };
  return /* @__PURE__ */ St.jsxs("div", { className: "container mt-4", children: [
    n && /* @__PURE__ */ St.jsxs("div", { className: "form-check form-switch mb-3", children: [
      /* @__PURE__ */ St.jsx(
        "input",
        {
          className: "form-check-input",
          type: "checkbox",
          id: "flexSwitchCheckDefault",
          checked: s,
          onChange: o
        }
      ),
      /* @__PURE__ */ St.jsx("label", { className: "form-check-label", htmlFor: "flexSwitchCheckDefault", children: r })
    ] }),
    a.map((c, u) => /* @__PURE__ */ St.jsx("div", { style: { display: s ? "block" : "none" }, children: c }, u)),
    /* @__PURE__ */ St.jsx(
      "div",
      {
        className: "card",
        children: /* @__PURE__ */ St.jsx("div", { className: "card-body", children: /* @__PURE__ */ St.jsx(
          mY,
          {
            markdownString: e,
            components: t
          }
        ) })
      }
    )
  ] });
};
export {
  mY as MarkdownRenderer,
  gY as Talkative
};
